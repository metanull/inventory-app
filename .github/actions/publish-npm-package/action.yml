name: 'Publish NPM Package'
description: 'Publishes an NPM package to a registry'

inputs:
  package_directory:
    description: 'Directory containing the package to publish'
    required: true
    default: 'api-client'
  registry:
    description: 'NPM registry URL'
    required: true
    default: 'https://npm.pkg.github.com/'
  token:
    description: 'Authentication token for the registry'
    required: true

runs:
  using: "composite"
  steps:
    - name: "Read package info"
      id: package-info
      shell: bash
      working-directory: ${{ inputs.package_directory }}
      run: |
        PACKAGE_NAME=$(jq -r '.name' package.json)
        PACKAGE_VERSION=$(jq -r '.version' package.json)
        echo "package_name=$PACKAGE_NAME" >> $GITHUB_OUTPUT
        echo "package_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
        echo "Publishing: $PACKAGE_NAME@$PACKAGE_VERSION"

    - name: "Configure authentication"
      shell: bash
      working-directory: ${{ inputs.package_directory }}
      run: |
        REGISTRY="${{ inputs.registry }}"
        REGISTRY_HOST=$(echo "$REGISTRY" | sed 's|https\?://||' | sed 's|/$||')
        
        # Create .npmrc for authentication
        cat > .npmrc << EOF
        @metanull:registry=$REGISTRY
        //$REGISTRY_HOST/:_authToken=\${NODE_AUTH_TOKEN}
        EOF
        
        echo "Authentication configured for registry: $REGISTRY"

    - name: "Normalize version"
      id: normalize-version
      shell: bash
      working-directory: ${{ inputs.package_directory }}
      run: |
        PACKAGE_VERSION="${{ steps.package-info.outputs.package_version }}"
        ORIGINAL_VERSION="$PACKAGE_VERSION"
        
        echo "Original version: $PACKAGE_VERSION"
        
        # Handle version with build metadata (format: x.y.z-prerelease+buildmeta)
        # npm doesn't support build metadata (+suffix), so we need to convert it
        if [[ $PACKAGE_VERSION =~ ^(.+)\+(.+)$ ]]; then
          CLEAN_VERSION="${BASH_REMATCH[1]}"
          BUILD_METADATA="${BASH_REMATCH[2]}"
          
          echo "Found build metadata: $BUILD_METADATA"
          
          # Parse the date from build metadata (expected format: yyyyMMdd.HHmm)
          if [[ $BUILD_METADATA =~ ([0-9]{8})\.([0-9]{4}) ]]; then
            DATE_PART="${BASH_REMATCH[1]}"
            TIME_PART="${BASH_REMATCH[2]}"
            
            # Create a unique suffix based on the build timestamp (mmdd.HHMM format)
            UNIQUE_SUFFIX="${DATE_PART:4:4}.${TIME_PART}"
            
            # If it's already a prerelease version (has a dash), add the unique suffix after it
            if [[ $CLEAN_VERSION =~ ^(.+)-(.+)$ ]]; then
              VERSION_BASE="${BASH_REMATCH[1]}"
              PRE_RELEASE_TAG="${BASH_REMATCH[2]}"
              UNIQUE_VERSION="${VERSION_BASE}-${PRE_RELEASE_TAG}.${UNIQUE_SUFFIX}"
            else
              # Otherwise add it as a prerelease suffix
              UNIQUE_VERSION="${CLEAN_VERSION}-${UNIQUE_SUFFIX}"
            fi
            
            # Update package.json with the unique version
            jq --arg version "$UNIQUE_VERSION" '.version = $version' package.json > package.json.tmp
            mv package.json.tmp package.json
            
            echo "Modified version for npm compatibility: $UNIQUE_VERSION (from $ORIGINAL_VERSION)"
            PACKAGE_VERSION="$UNIQUE_VERSION"
          else
            # Fallback if we can't parse the build metadata - just remove it
            jq --arg version "$CLEAN_VERSION" '.version = $version' package.json > package.json.tmp
            mv package.json.tmp package.json
            
            echo "Removed build metadata from version for npm compatibility: $CLEAN_VERSION"
            PACKAGE_VERSION="$CLEAN_VERSION"
          fi
        fi
        
        echo "final_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
        echo "Final version to publish: $PACKAGE_VERSION"

    - name: "Determine npm tag"
      id: npm-tag
      shell: bash
      run: |
        PACKAGE_VERSION="${{ steps.normalize-version.outputs.final_version }}"
        
        # Check if version contains a dash (prerelease indicator)
        if [[ $PACKAGE_VERSION =~ - ]]; then
          NPM_TAG="dev"
          echo "Detected prerelease version, will use tag: dev"
        else
          NPM_TAG="latest"
          echo "Detected stable version, will use tag: latest"
        fi
        
        echo "npm_tag=$NPM_TAG" >> $GITHUB_OUTPUT

    - name: "Publish to registry"
      shell: bash
      working-directory: ${{ inputs.package_directory }}
      env:
        NODE_AUTH_TOKEN: ${{ inputs.token }}
      run: |
        REGISTRY="${{ inputs.registry }}"
        NPM_TAG="${{ steps.npm-tag.outputs.npm_tag }}"
        PACKAGE_NAME="${{ steps.package-info.outputs.package_name }}"
        FINAL_VERSION="${{ steps.normalize-version.outputs.final_version }}"
        
        echo "Publishing $PACKAGE_NAME@$FINAL_VERSION to $REGISTRY with tag: $NPM_TAG"
        
        # Publish to npm
        npm publish --access public --registry "$REGISTRY" --tag "$NPM_TAG"
        
        if [ $? -eq 0 ]; then
          echo "✔ Package published successfully!"
          echo "Published: $PACKAGE_NAME@$FINAL_VERSION"
          echo "Install with: npm install $PACKAGE_NAME"
        else
          echo "❌ npm publish failed"
          exit 1
        fi

    - name: "Summary"
      shell: bash
      run: |
        echo "=== Publication Summary ==="
        echo "Package: ${{ steps.package-info.outputs.package_name }}"
        echo "Original Version: ${{ steps.package-info.outputs.package_version }}"
        echo "Published Version: ${{ steps.normalize-version.outputs.final_version }}"
        echo "NPM Tag: ${{ steps.npm-tag.outputs.npm_tag }}"
        echo "Registry: ${{ inputs.registry }}"
        echo ""
        echo "Installation:"
        echo "  npm install ${{ steps.package-info.outputs.package_name }}"
