/* tslint:disable */
/* eslint-disable */
/**
 * Inventory-App
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AcquireTokenMobileAppAuthenticationRequest {
    'email': string;
    'password': string;
    'device_name': string;
    'wipe_tokens'?: boolean;
    'two_factor_code'?: string;
    'recovery_code'?: string;
}
export interface AddressIndex200Response {
    'data': Array<AddressResource>;
    'links': AddressIndex200ResponseLinks;
    'meta': AddressIndex200ResponseMeta;
}
export interface AddressIndex200ResponseLinks {
    'first': string | null;
    'last': string | null;
    'prev': string | null;
    'next': string | null;
}
export interface AddressIndex200ResponseMeta {
    'current_page': number;
    'from': number | null;
    'last_page': number;
    /**
     * Generated paginator links.
     */
    'links': Array<AddressIndex200ResponseMetaLinksInner>;
    /**
     * Base path for paginator generated URLs.
     */
    'path': string | null;
    /**
     * Number of items shown per page.
     */
    'per_page': number;
    /**
     * Number of the last item in the slice.
     */
    'to': number | null;
    /**
     * Total number of items being paginated.
     */
    'total': number;
}
export interface AddressIndex200ResponseMetaLinksInner {
    'url': string | null;
    'label': string;
    'active': boolean;
}
export interface AddressResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The country this address belongs to (CountryResource id)
     */
    'country_id': string;
    /**
     * Translations for this address (AddressTranslationResource[])
     */
    'translations'?: Array<AddressTranslationResource>;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface AddressShow200Response {
    'data': AddressResource;
}
export interface AddressTranslationIndex200Response {
    'data': Array<AddressTranslationResource>;
}
export interface AddressTranslationResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The address this translation belongs to (AddressResource id)
     */
    'address_id': string;
    /**
     * The language of this translation (LanguageResource id)
     */
    'language_id': string;
    /**
     * The address translation text
     */
    'address': string;
    /**
     * The description of the address translation
     */
    'description': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface AddressTranslationShow200Response {
    'data': AddressTranslationResource;
}
export interface ArtistResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The name of the artist
     */
    'name': string;
    /**
     * The place of birth of the artist
     */
    'place_of_birth': string | null;
    /**
     * The place of death of the artist
     */
    'place_of_death': string | null;
    /**
     * The date of birth of the artist
     */
    'date_of_birth': string | null;
    /**
     * The date of death of the artist
     */
    'date_of_death': string | null;
    /**
     * The period of activity of the artist
     */
    'period_of_activity': string | null;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
    /**
     * Items associated with this artist (ItemResource[])
     */
    'items'?: Array<ItemResource>;
}
export interface AttachFromAvailableItemImageRequest {
    'available_image_id': string;
    'alt_text'?: string | null;
}
export interface AttachItemCollectionRequest {
    'item_id': string;
}
export interface AttachItemsCollectionRequest {
    'item_ids': Array<string>;
}
export interface AuthorResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The name of the author
     */
    'name': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string | null;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface AvailableImageIndex200Response {
    'data': Array<AvailableImageResource>;
    'links': AddressIndex200ResponseLinks;
    'meta': AddressIndex200ResponseMeta;
}
export interface AvailableImageResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The path to the picture file
     */
    'path': string | null;
    /**
     * A user defined comment associated with the file
     */
    'comment': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface AvailableImageShow200Response {
    'data': AvailableImageResource;
}
export interface CollectionAttachItem200Response {
    'data': OperationSuccessResource;
}
export interface CollectionByType200Response {
    'data': Array<CollectionResource>;
}
export interface CollectionIndex200Response {
    'data': Array<CollectionResource>;
    'links': AddressIndex200ResponseLinks;
    'meta': AddressIndex200ResponseMeta;
}
export interface CollectionResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The type of collection: \'collection\', \'exhibition\', or \'gallery\'
     */
    'type': string;
    /**
     * The language this collection belongs to (LanguageResource id)
     */
    'language_id': string;
    /**
     * The context this collection belongs to (ContextResource id)
     */
    'context_id': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
    /**
     * The language relationship (LanguageResource)
     */
    'language'?: LanguageResource;
    /**
     * The context relationship (ContextResource)
     */
    'context'?: ContextResource;
    /**
     * Translations for this collection (CollectionTranslationResource[])
     */
    'translations'?: Array<CollectionTranslationResource>;
    /**
     * Partners associated with this collection (PartnerResource[])
     */
    'partners'?: Array<PartnerResource>;
    /**
     * Items associated with this collection - primary relationship (ItemResource[])
     */
    'items'?: Array<ItemResource>;
    /**
     * Items attached to this collection via many-to-many relationship (ItemResource[])
     */
    'attachedItems'?: Array<ItemResource>;
    /**
     * The number of items in this collection (computed)
     */
    'items_count'?: string;
    'attached_items_count'?: string;
    'partners_count'?: string;
    'translations_count'?: string;
}
export interface CollectionShow200Response {
    'data': CollectionResource;
}
export interface CollectionTranslationResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The collection this translation belongs to (CollectionResource id)
     */
    'collection_id': string;
    /**
     * The language of this translation (LanguageResource id)
     */
    'language_id': string;
    /**
     * The context of this translation (ContextResource id)
     */
    'context_id': string;
    /**
     * The title of the collection translation
     */
    'title': string;
    /**
     * The description of the collection translation
     */
    'description': string;
    /**
     * The URL for the collection translation
     */
    'url': string | null;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * Extra data for translation (object, may be null)
     */
    'extra': object | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
    /**
     * The collection relationship (CollectionResource)
     */
    'collection'?: CollectionResource;
    /**
     * The language relationship (LanguageResource)
     */
    'language'?: LanguageResource;
    /**
     * The context relationship (ContextResource)
     */
    'context'?: ContextResource;
}
export interface ContactIndex200Response {
    'data': Array<ContactResource>;
    'links': AddressIndex200ResponseLinks;
    'meta': AddressIndex200ResponseMeta;
}
export interface ContactResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The phone number of the contact
     */
    'phone_number': string | null;
    /**
     * The formatted phone number of the contact
     */
    'formatted_phone_number': string | null;
    /**
     * The fax number of the contact
     */
    'fax_number': string | null;
    /**
     * The formatted fax number of the contact
     */
    'formatted_fax_number': string | null;
    /**
     * The email address of the contact
     */
    'email': string | null;
    /**
     * Translations for this contact (ContactTranslationResource[])
     */
    'translations'?: Array<ContactTranslationResource>;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface ContactShow200Response {
    'data': ContactResource;
}
export interface ContactTranslationIndex200Response {
    'data': Array<ContactTranslationResource>;
}
export interface ContactTranslationResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The contact this translation belongs to (ContactResource id)
     */
    'contact_id': string;
    /**
     * The language of this translation (LanguageResource id)
     */
    'language_id': string;
    /**
     * The label for the contact translation
     */
    'label': string;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface ContactTranslationShow200Response {
    'data': ContactTranslationResource;
}
export interface ContextClearDefault200Response {
    'data': MessageResource;
}
export interface ContextGetDefault200Response {
    'data': ContextResource;
}
export interface ContextGetDefault404Response {
    'message': string;
}
export interface ContextIndex200Response {
    'data': Array<ContextResource>;
    'links': AddressIndex200ResponseLinks;
    'meta': AddressIndex200ResponseMeta;
}
export interface ContextResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * Indicates if this context is the default one. There is one single default context for the entire database.
     */
    'is_default': boolean;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface ConversionResource {
    'success': string;
    'message': string;
    'data': string;
    'error': string;
    'errors': string;
}
export interface CountryIndex200Response {
    'data': Array<CountryResource>;
    'links': AddressIndex200ResponseLinks;
    'meta': AddressIndex200ResponseMeta;
}
export interface CountryResource {
    /**
     * The unique identifier (ISO 3166-1 alpha-3 code)
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface CountryShow200Response {
    'data': CountryResource;
}
export interface EmailCodeRequestResource {
    'message': string;
    'expires_in': string;
}
export interface ImageUploadIndex200Response {
    'data': Array<ImageUploadResource>;
}
export interface ImageUploadResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The path to the picture file
     */
    'path': string | null;
    /**
     * The original name of the uploaded file
     */
    'name': string | null;
    /**
     * The file extension of the uploaded file
     */
    'extension': string | null;
    /**
     * The MIME type of the uploaded file
     */
    'mime_type': string | null;
    /**
     * The size of the uploaded file in bytes
     */
    'size': number | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface ImageUploadShow200Response {
    'data': ImageUploadResource;
}
export interface ImageUploadStatus200Response {
    'data': ImageUploadStatusResource;
}
export interface ImageUploadStatus404Response {
    'status': string;
    'available_image': string;
}
export interface ImageUploadStatusResource {
    'status': string;
    'available_image': string;
}
export interface InfoVersion200Response {
    'data': VersionResource;
}
export interface InlineObject {
    /**
     * Error overview.
     */
    'message': string;
}
export interface InlineObject1 {
    /**
     * Errors overview.
     */
    'message': string;
    /**
     * A detailed description of each field that failed validation.
     */
    'errors': { [key: string]: Array<string>; };
}
export interface ItemForTag200Response {
    'data': Array<ItemResource>;
}
export interface ItemImageResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The item this image belongs to
     */
    'item_id': string;
    /**
     * The path to the image file
     */
    'path': string;
    /**
     * The original filename when uploaded
     */
    'original_name': string;
    /**
     * The MIME type of the image
     */
    'mime_type': string;
    /**
     * The file size in bytes
     */
    'size': number;
    /**
     * Alternative text for accessibility
     */
    'alt_text': string | null;
    /**
     * Display order for sorting images
     */
    'display_order': number;
    /**
     * The item this image belongs to (ItemResource)
     */
    'item'?: ItemResource;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface ItemImagesIndex200Response {
    'data': Array<ItemImageResource>;
}
export interface ItemImagesStore200Response {
    'data': ItemImageResource;
}
export interface ItemIndex200Response {
    'data': Array<ItemResource>;
    'links': AddressIndex200ResponseLinks;
    'meta': AddressIndex200ResponseMeta;
}
export interface ItemResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * The type of the item: \'object\', \'monument\', \'detail\', or \'picture\'.
     */
    'type': string;
    /**
     * The parent item ID (for hierarchical relationships), nullable
     */
    'parent_id': string | null;
    /**
     * Owner\'s reference number for the item (external reference from owner)
     */
    'owner_reference': string | null;
    /**
     * MWNF reference number for the item (reference from MWNF system)
     */
    'mwnf_reference': string | null;
    /**
     * The parent item (for hierarchical relationships), nullable (ItemResource)
     */
    'parent'?: ItemResource;
    /**
     * The child items (for hierarchical relationships) (ItemResource[])
     */
    'children'?: Array<ItemResource>;
    /**
     * The partner owning the item (PartnerResource)
     */
    'partner'?: PartnerResource;
    /**
     * The project this item belongs to, nullable (ProjectResource)
     */
    'project'?: ProjectResource;
    /**
     * The country this item is associated with, nullable (CountryResource)
     */
    'country'?: CountryResource;
    /**
     * The collection that contains this item (CollectionResource)
     */
    'collection'?: CollectionResource;
    /**
     * Artists associated with this item (ArtistResource[])
     */
    'artists'?: Array<ArtistResource>;
    /**
     * Workshops associated with this item (WorkshopResource[])
     */
    'workshops'?: Array<WorkshopResource>;
    /**
     * Tags associated with this item (TagResource[])
     */
    'tags'?: Array<TagResource>;
    /**
     * Translations for this item (internationalization and contextualization) (ItemTranslationResource[])
     */
    'translations'?: Array<ItemTranslationResource>;
    /**
     * Item images attached to this item with display ordering (ItemImageResource[])
     */
    'itemImages'?: Array<ItemImageResource>;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface ItemShow200Response {
    'data': ItemResource;
}
export interface ItemTranslationIndex200Response {
    'data': Array<ItemTranslationResource>;
    'links': AddressIndex200ResponseLinks;
    'meta': AddressIndex200ResponseMeta;
}
export interface ItemTranslationResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The item this translation belongs to (ItemResource id)
     */
    'item_id': string;
    /**
     * The language of this translation (LanguageResource id)
     */
    'language_id': string;
    /**
     * The context of this translation (ContextResource id)
     */
    'context_id': string;
    /**
     * The name of the item translation
     */
    'name': string;
    /**
     * The alternate name of the item translation
     */
    'alternate_name': string | null;
    /**
     * The description of the item translation
     */
    'description': string;
    /**
     * The type of the item translation
     */
    'type': string | null;
    /**
     * The holder of the item
     */
    'holder': string | null;
    /**
     * The owner of the item
     */
    'owner': string | null;
    /**
     * The initial owner of the item
     */
    'initial_owner': string | null;
    /**
     * The dates associated with the item
     */
    'dates': string | null;
    /**
     * The location associated with the item
     */
    'location': string | null;
    /**
     * The dimensions of the item
     */
    'dimensions': string | null;
    /**
     * The place of production of the item
     */
    'place_of_production': string | null;
    /**
     * The method for datation of the item
     */
    'method_for_datation': string | null;
    /**
     * The method for provenance of the item
     */
    'method_for_provenance': string | null;
    /**
     * The obtention of the item
     */
    'obtention': string | null;
    /**
     * The bibliography for the item
     */
    'bibliography': string | null;
    /**
     * The author of the item (AuthorResource id)
     */
    'author_id': string | null;
    /**
     * The copy-editor of the item (AuthorResource id)
     */
    'text_copy_editor_id': string | null;
    /**
     * The translator of the item translation (AuthorResource id)
     */
    'translator_id': string | null;
    /**
     * The copy-editor of the item translation (AuthorResource id)
     */
    'translation_copy_editor_id': string | null;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * Extra data for translation (object, may be null)
     */
    'extra': object | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
    /**
     * The item relationship (ItemResource)
     */
    'item'?: ItemResource;
    /**
     * The language relationship (LanguageResource)
     */
    'language'?: LanguageResource;
    /**
     * The context relationship (ContextResource)
     */
    'context'?: ContextResource;
    /**
     * The author relationship (AuthorResource)
     */
    'author'?: AuthorResource;
    /**
     * The copy-editor relationship (AuthorResource)
     */
    'text_copy_editor'?: AuthorResource;
    /**
     * The translator relationship (AuthorResource)
     */
    'translator'?: AuthorResource;
    /**
     * The translation copy-editor relationship (AuthorResource)
     */
    'translation_copy_editor'?: AuthorResource;
}
export interface ItemTranslationShow200Response {
    'data': ItemTranslationResource;
}
export interface LanguageGetDefault200Response {
    'data': LanguageResource;
}
export interface LanguageIndex200Response {
    'data': Array<LanguageResource>;
    'links': AddressIndex200ResponseLinks;
    'meta': AddressIndex200ResponseMeta;
}
export interface LanguageResource {
    /**
     * The unique identifier (ISO 639-1 code)
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * Indicates if this language is the default one. There is one single default language for the entire database.
     */
    'is_default': boolean;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface LocationIndex200Response {
    'data': Array<LocationResource>;
    'links': AddressIndex200ResponseLinks;
    'meta': AddressIndex200ResponseMeta;
}
export interface LocationResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The country this location belongs to (CountryResource id)
     */
    'country_id': string;
    /**
     * Translations for this location (LocationTranslationResource[])
     */
    'translations'?: Array<LocationTranslationResource>;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface LocationShow200Response {
    'data': LocationResource;
}
export interface LocationTranslationIndex200Response {
    'data': Array<LocationTranslationResource>;
}
export interface LocationTranslationResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The location this translation belongs to (LocationResource id)
     */
    'location_id': string;
    /**
     * The language of this translation (LanguageResource id)
     */
    'language_id': string;
    /**
     * The name of the location translation
     */
    'name': string;
    /**
     * The description of the location translation
     */
    'description': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface LocationTranslationShow200Response {
    'data': LocationTranslationResource;
}
export interface MarkdownFromHtmlRequest {
    'html': string;
}
export interface MarkdownIsMarkdownRequest {
    'content': string;
}
export interface MarkdownPreview422Response {
    'success': string;
    'message': string;
    'data': string;
    'error': string;
    'errors': string;
}
export interface MarkdownToHtmlRequest {
    'markdown': string;
}
export interface MessageResource {
    'message': string;
}
export interface OperationSuccessResource {
    'success': string;
    'message': string;
}
export interface PartnerIndex200Response {
    'data': Array<PartnerResource>;
    'links': AddressIndex200ResponseLinks;
    'meta': AddressIndex200ResponseMeta;
}
export interface PartnerResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * The type of the partner, either \'museum\', \'institution\' or \'individual\'.
     */
    'type': string;
    /**
     * The country this partner is associated with, nullable (CountryResource)
     */
    'country'?: CountryResource;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface PartnerShow200Response {
    'data': PartnerResource;
}
export interface ProjectEnabled200Response {
    'data': Array<ProjectResource>;
}
export interface ProjectIndex200Response {
    'data': Array<ProjectResource>;
    'links': AddressIndex200ResponseLinks;
    'meta': AddressIndex200ResponseMeta;
}
export interface ProjectResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * Launch date of the project, nullable
     */
    'launch_date': string | null;
    /**
     * Indicates if the project has been launched already
     */
    'is_launched': boolean;
    /**
     * Indicates if the project is enabled (active)
     */
    'is_enabled': boolean;
    /**
     * The default context used within the project (ContextResource)
     */
    'context'?: ContextResource;
    /**
     * The default language used within the project (LanguageResource)
     */
    'language'?: LanguageResource;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface ProjectShow200Response {
    'data': ProjectResource;
}
export interface ProvinceIndex200Response {
    'data': Array<ProvinceResource>;
    'links': AddressIndex200ResponseLinks;
    'meta': AddressIndex200ResponseMeta;
}
export interface ProvinceResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The country this province belongs to (CountryResource id)
     */
    'country_id': string;
    /**
     * Translations for this province (ProvinceTranslationResource[])
     */
    'translations'?: Array<ProvinceTranslationResource>;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface ProvinceShow200Response {
    'data': ProvinceResource;
}
export interface ProvinceTranslationIndex200Response {
    'data': Array<ProvinceTranslationResource>;
}
export interface ProvinceTranslationResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The province this translation belongs to (ProvinceResource id)
     */
    'province_id': string;
    /**
     * The language of this translation (LanguageResource id)
     */
    'language_id': string;
    /**
     * The name of the province translation
     */
    'name': string;
    /**
     * The description of the province translation
     */
    'description': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface ProvinceTranslationShow200Response {
    'data': ProvinceTranslationResource;
}
export interface RequestEmailCodeMobileAppAuthenticationRequest {
    'email': string;
    'password': string;
}
export interface SetDefaultContextRequest {
    'is_default': boolean;
}
export interface SetDefaultLanguageRequest {
    'is_default': boolean;
}
export interface SetEnabledProjectRequest {
    'is_enabled': boolean;
}
export interface SetLaunchedProjectRequest {
    'is_launched': boolean;
}
export interface StoreAddressRequest {
    'id'?: string;
    'internal_name': string;
    'country_id': number;
    'backward_compatibility'?: string | null;
    'translations'?: Array<StoreAddressRequestTranslationsInner>;
}
export interface StoreAddressRequestTranslationsInner {
    'language_id': number;
    'address': string;
    'description'?: string | null;
}
export interface StoreAddressTranslationRequest {
    'address_id': string;
    'language_id': string;
    'address': string;
    'description'?: string | null;
}
export interface StoreCollectionRequest {
    'internal_name': string;
    'type': StoreCollectionRequestTypeEnum;
    'language_id': string;
    'context_id': string;
    'backward_compatibility'?: string | null;
}

export const StoreCollectionRequestTypeEnum = {
    Collection: 'collection',
    Exhibition: 'exhibition',
    Gallery: 'gallery'
} as const;

export type StoreCollectionRequestTypeEnum = typeof StoreCollectionRequestTypeEnum[keyof typeof StoreCollectionRequestTypeEnum];

export interface StoreContactRequest {
    'internal_name': string;
    'phone_number'?: string | null;
    'fax_number'?: string | null;
    'email'?: string | null;
    'backward_compatibility'?: string | null;
    'translations': Array<StoreContactRequestTranslationsInner>;
}
export interface StoreContactRequestTranslationsInner {
    'language_id': number;
    'label': string;
}
export interface StoreContactTranslationRequest {
    'contact_id': string;
    'language_id': string;
    'label': string;
}
export interface StoreContextRequest {
    'id'?: string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
    'is_default'?: boolean;
}
export interface StoreCountryRequest {
    'id': string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
}
export interface StoreItemImageRequest {
    'path': string;
    'original_name': string;
    'mime_type': string;
    'size': number;
    'alt_text'?: string | null;
    'display_order'?: number;
}
export interface StoreItemRequest {
    'id'?: string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
    'type': StoreItemRequestTypeEnum;
    'parent_id'?: string | null;
    'country_id'?: string | null;
    'partner_id'?: string | null;
    'project_id'?: string | null;
    'collection_id'?: string | null;
    'owner_reference'?: string | null;
    'mwnf_reference'?: string | null;
}

export const StoreItemRequestTypeEnum = {
    Object: 'object',
    Monument: 'monument',
    Detail: 'detail',
    Picture: 'picture'
} as const;

export type StoreItemRequestTypeEnum = typeof StoreItemRequestTypeEnum[keyof typeof StoreItemRequestTypeEnum];

export interface StoreItemTranslationRequest {
    'id'?: string;
    'item_id': string;
    'language_id': string;
    'context_id': string;
    'name': string;
    'alternate_name'?: string | null;
    'description': string;
    'type'?: string | null;
    'holder'?: string | null;
    'owner'?: string | null;
    'initial_owner'?: string | null;
    'dates'?: string | null;
    'location'?: string | null;
    'dimensions'?: string | null;
    'place_of_production'?: string | null;
    'method_for_datation'?: string | null;
    'method_for_provenance'?: string | null;
    'obtention'?: string | null;
    'bibliography'?: string | null;
    'author_id'?: string | null;
    'text_copy_editor_id'?: string | null;
    'translator_id'?: string | null;
    'translation_copy_editor_id'?: string | null;
    'backward_compatibility'?: string | null;
    'extra'?: string | null;
}
export interface StoreLanguageRequest {
    'id': string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
    'is_default'?: boolean;
}
export interface StoreLocationRequest {
    'internal_name': string;
    'country_id': number;
    'backward_compatibility'?: string | null;
    'translations': Array<StoreLocationRequestTranslationsInner>;
}
export interface StoreLocationRequestTranslationsInner {
    'language_id': number;
    'name': string;
}
export interface StoreLocationTranslationRequest {
    'location_id': string;
    'language_id': string;
    'name': string;
    'description'?: string | null;
}
export interface StorePartnerRequest {
    'id'?: string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
    'type': StorePartnerRequestTypeEnum;
    'country_id'?: string | null;
}

export const StorePartnerRequestTypeEnum = {
    Museum: 'museum',
    Institution: 'institution',
    Individual: 'individual'
} as const;

export type StorePartnerRequestTypeEnum = typeof StorePartnerRequestTypeEnum[keyof typeof StorePartnerRequestTypeEnum];

export interface StoreProjectRequest {
    'id'?: string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
    'launch_date'?: string | null;
    'is_launched'?: boolean;
    'is_enabled'?: boolean;
    'context_id'?: string | null;
    'language_id'?: string | null;
}
export interface StoreProvinceRequest {
    'internal_name': string;
    'country_id': number;
    'backward_compatibility'?: string | null;
    'translations': Array<StoreLocationRequestTranslationsInner>;
}
export interface StoreProvinceTranslationRequest {
    'province_id': string;
    'language_id': string;
    'name': string;
    'description'?: string | null;
}
export interface StoreTagRequest {
    'id'?: string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
    'description': string;
}
export interface StoreThemeRequest {
    'exhibition_id': string;
    'parent_id'?: string | null;
    'internal_name': string;
    'backward_compatibility'?: string | null;
}
export interface StoreThemeTranslationRequest {
    'theme_id': string;
    'language_id': string;
    'context_id': string;
    'title': string;
    'description': string;
    'introduction': string;
    'backward_compatibility'?: string | null;
    'extra'?: string | null;
}
export interface TagForItem200Response {
    'data': Array<TagResource>;
    'links': AddressIndex200ResponseLinks;
    'meta': AddressIndex200ResponseMeta;
}
export interface TagResource {
    /**
     * The unique identifier of the tag (GUID)
     */
    'id': string;
    /**
     * The name of the tag, it shall only be used internally
     */
    'internal_name': string;
    /**
     * The legacy Id when this tag corresponds to a legacy tag from the previous database, nullable
     */
    'backward_compatibility': string | null;
    /**
     * The description of the tag
     */
    'description': string;
    /**
     * Date of creation
     */
    'created_at': string | null;
    /**
     * Date of last modification
     */
    'updated_at': string | null;
}
export interface TagShow200Response {
    'data': TagResource;
}
export interface ThemeIndex200Response {
    'data': Array<ThemeResource>;
    'links': AddressIndex200ResponseLinks;
    'meta': AddressIndex200ResponseMeta;
}
export interface ThemeResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The exhibition this theme belongs to (ExhibitionResource id)
     */
    'exhibition_id': string;
    /**
     * The parent theme of this theme (ThemeResource id)
     */
    'parent_id': string | null;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * Translations for this theme (ThemeTranslationResource[])
     */
    'translations'?: Array<ThemeTranslationResource>;
    /**
     * Subthemes of this theme (ThemeResource[])
     */
    'subthemes'?: Array<ThemeResource>;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface ThemeShow200Response {
    'data': ThemeResource;
}
export interface ThemeTranslationResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The theme this translation belongs to (ThemeResource id)
     */
    'theme_id': string;
    /**
     * The language of this translation (LanguageResource id)
     */
    'language_id': string;
    /**
     * The context of this translation (ContextResource id)
     */
    'context_id': string;
    /**
     * The title of the theme translation
     */
    'title': string;
    /**
     * The description of the theme translation
     */
    'description': string;
    /**
     * The introduction of the theme translation
     */
    'introduction': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * Extra data for translation (object, may be null)
     */
    'extra': object | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface ThemeTranslationShow200Response {
    'data': ThemeTranslationResource;
}
export interface TokenAcquire201Response {
    'token': string;
    'user': string;
}
export interface TokenAcquire202Response {
    'requires_two_factor': string;
    'available_methods': string;
    'primary_method': string;
    'message': string;
}
export interface TokenRequestEmailCode200Response {
    'data': EmailCodeRequestResource;
}
export interface TokenTwoFactorStatus200Response {
    'data': TwoFactorStatusResource;
}
export interface TwoFactorStatusMobileAppAuthenticationRequest {
    'email': string;
    'password': string;
}
export interface TwoFactorStatusResource {
    'two_factor_enabled': string;
    'available_methods': string;
    'primary_method': string;
    'requires_two_factor': string;
}
export interface UpdateAddressRequest {
    'id'?: string;
    'internal_name': string;
    'country_id': number;
    'backward_compatibility'?: string | null;
    'translations'?: Array<UpdateAddressRequestTranslationsInner>;
}
export interface UpdateAddressRequestTranslationsInner {
    'language_id'?: number;
    'address'?: string;
    'description'?: string | null;
}
export interface UpdateAddressTranslationRequest {
    'address_id'?: string;
    'language_id'?: string;
    'address'?: string;
    'description'?: string | null;
}
export interface UpdateAvailableImageRequest {
    'id'?: string;
    'path'?: string;
    'comment'?: string | null;
}
export interface UpdateCollectionRequest {
    'internal_name'?: string;
    'type'?: UpdateCollectionRequestTypeEnum;
    'language_id'?: string;
    'context_id'?: string;
    'backward_compatibility'?: string | null;
}

export const UpdateCollectionRequestTypeEnum = {
    Collection: 'collection',
    Exhibition: 'exhibition',
    Gallery: 'gallery'
} as const;

export type UpdateCollectionRequestTypeEnum = typeof UpdateCollectionRequestTypeEnum[keyof typeof UpdateCollectionRequestTypeEnum];

export interface UpdateContactRequest {
    'internal_name': string;
    'phone_number'?: string | null;
    'fax_number'?: string | null;
    'email'?: string | null;
    'backward_compatibility'?: string | null;
    'translations'?: Array<UpdateContactRequestTranslationsInner>;
}
export interface UpdateContactRequestTranslationsInner {
    'language_id'?: number;
    'label'?: string;
}
export interface UpdateContactTranslationRequest {
    'contact_id'?: string;
    'language_id'?: string;
    'label'?: string;
}
export interface UpdateContextRequest {
    'id'?: string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
    'is_default'?: boolean;
}
export interface UpdateCountryRequest {
    'id'?: string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
}
export interface UpdateItemImageRequest {
    /**
     * Path and item_id are immutable - not allowed in updates
     */
    'original_name'?: string;
    'mime_type'?: string;
    'size'?: number;
    'alt_text'?: string | null;
    'display_order'?: number;
    'include'?: string;
}
export interface UpdateItemRequest {
    'id'?: string;
    'internal_name'?: string;
    'backward_compatibility'?: string | null;
    'type'?: UpdateItemRequestTypeEnum;
    'parent_id'?: string | null;
    'country_id'?: string | null;
    'partner_id'?: string | null;
    'project_id'?: string | null;
    'collection_id'?: string | null;
    'owner_reference'?: string | null;
    'mwnf_reference'?: string | null;
}

export const UpdateItemRequestTypeEnum = {
    Object: 'object',
    Monument: 'monument',
    Detail: 'detail',
    Picture: 'picture'
} as const;

export type UpdateItemRequestTypeEnum = typeof UpdateItemRequestTypeEnum[keyof typeof UpdateItemRequestTypeEnum];

export interface UpdateItemTranslationRequest {
    'id'?: string;
    'item_id'?: string;
    'language_id'?: string;
    'context_id'?: string;
    'name'?: string;
    'alternate_name'?: string | null;
    'description'?: string;
    'type'?: string | null;
    'holder'?: string | null;
    'owner'?: string | null;
    'initial_owner'?: string | null;
    'dates'?: string | null;
    'location'?: string | null;
    'dimensions'?: string | null;
    'place_of_production'?: string | null;
    'method_for_datation'?: string | null;
    'method_for_provenance'?: string | null;
    'obtention'?: string | null;
    'bibliography'?: string | null;
    'author_id'?: string | null;
    'text_copy_editor_id'?: string | null;
    'translator_id'?: string | null;
    'translation_copy_editor_id'?: string | null;
    'backward_compatibility'?: string | null;
    'extra'?: string | null;
}
export interface UpdateLanguageRequest {
    'id'?: string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
    'is_default'?: boolean;
}
export interface UpdateLocationRequest {
    'internal_name': string;
    'country_id': number;
    'backward_compatibility'?: string | null;
    'translations'?: Array<UpdateLocationRequestTranslationsInner>;
}
export interface UpdateLocationRequestTranslationsInner {
    'language_id'?: number;
    'name'?: string;
}
export interface UpdateLocationTranslationRequest {
    'location_id'?: string;
    'language_id'?: string;
    'name'?: string;
    'description'?: string | null;
}
export interface UpdatePartnerRequest {
    'id'?: string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
    'type': UpdatePartnerRequestTypeEnum;
    'country_id'?: string | null;
}

export const UpdatePartnerRequestTypeEnum = {
    Museum: 'museum',
    Institution: 'institution',
    Individual: 'individual'
} as const;

export type UpdatePartnerRequestTypeEnum = typeof UpdatePartnerRequestTypeEnum[keyof typeof UpdatePartnerRequestTypeEnum];

export interface UpdateProjectRequest {
    'id'?: string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
    'launch_date'?: string | null;
    'is_launched'?: boolean;
    'is_enabled'?: boolean;
    'context_id'?: string | null;
    'language_id'?: string | null;
}
export interface UpdateProvinceRequest {
    'internal_name': string;
    'country_id': number;
    'backward_compatibility'?: string | null;
    'translations'?: Array<UpdateLocationRequestTranslationsInner>;
}
export interface UpdateProvinceTranslationRequest {
    'province_id'?: string;
    'language_id'?: string;
    'name'?: string;
    'description'?: string | null;
}
export interface UpdateTagRequest {
    'id'?: string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
    'description': string;
}
export interface UpdateTagsItemRequest {
    'attach'?: Array<string>;
    'detach'?: Array<string>;
}
export interface UpdateThemeRequest {
    'internal_name'?: string;
    'backward_compatibility'?: string | null;
}
export interface UpdateThemeTranslationRequest {
    'theme_id'?: string;
    'language_id'?: string;
    'context_id'?: string;
    'title'?: string;
    'description'?: string;
    'introduction'?: string;
    'backward_compatibility'?: string | null;
    'extra'?: string | null;
}
export interface UserPermissions200Response {
    'data': UserPermissionsResource;
}
export interface UserPermissionsResource {
    'permissions': string;
}
export interface VerifyTwoFactorMobileAppAuthenticationRequest {
    'email': string;
    'password': string;
    'device_name': string;
    'code': string;
    'method'?: VerifyTwoFactorMobileAppAuthenticationRequestMethodEnum;
    'wipe_tokens'?: boolean;
}

export const VerifyTwoFactorMobileAppAuthenticationRequestMethodEnum = {
    Totp: 'totp',
    Email: 'email'
} as const;

export type VerifyTwoFactorMobileAppAuthenticationRequestMethodEnum = typeof VerifyTwoFactorMobileAppAuthenticationRequestMethodEnum[keyof typeof VerifyTwoFactorMobileAppAuthenticationRequestMethodEnum];

export interface VersionResource {
    'repository': string;
    'build_timestamp': string;
    'repository_url': string;
    'api_client_version': string;
    'app_version': string;
    'commit_sha': string;
}
export interface WithAllTagsItemRequest {
    'include'?: string;
    'tags': Array<string>;
}
export interface WithAnyTagsItemRequest {
    'include'?: string;
    'tags': Array<string>;
}
export interface WorkshopResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The name of the workshop
     */
    'name': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
    /**
     * Items associated with this workshop (ItemResource[])
     */
    'items'?: Array<ItemResource>;
}

/**
 * AddressApi - axios parameter creator
 */
export const AddressApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified address
         * @param {string} address The address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressDestroy: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addressDestroy', 'address', address)
            const localVarPath = `/address/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of addresses
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified address
         * @param {string} address The address ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressShow: async (address: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addressShow', 'address', address)
            const localVarPath = `/address/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created address
         * @param {StoreAddressRequest} storeAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressStore: async (storeAddressRequest: StoreAddressRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeAddressRequest' is not null or undefined
            assertParamExists('addressStore', 'storeAddressRequest', storeAddressRequest)
            const localVarPath = `/address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified address
         * @param {string} address The address ID
         * @param {UpdateAddressRequest} updateAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUpdate: async (address: string, updateAddressRequest: UpdateAddressRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addressUpdate', 'address', address)
            // verify required parameter 'updateAddressRequest' is not null or undefined
            assertParamExists('addressUpdate', 'updateAddressRequest', updateAddressRequest)
            const localVarPath = `/address/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified address
         * @param {string} address The address ID
         * @param {UpdateAddressRequest} updateAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUpdate2: async (address: string, updateAddressRequest: UpdateAddressRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addressUpdate2', 'address', address)
            // verify required parameter 'updateAddressRequest' is not null or undefined
            assertParamExists('addressUpdate2', 'updateAddressRequest', updateAddressRequest)
            const localVarPath = `/address/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressApi - functional programming interface
 */
export const AddressApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified address
         * @param {string} address The address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressDestroy(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressDestroy(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.addressDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of addresses
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.addressIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified address
         * @param {string} address The address ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressShow(address: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressShow(address, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.addressShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created address
         * @param {StoreAddressRequest} storeAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressStore(storeAddressRequest: StoreAddressRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressStore(storeAddressRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.addressStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified address
         * @param {string} address The address ID
         * @param {UpdateAddressRequest} updateAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressUpdate(address: string, updateAddressRequest: UpdateAddressRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressUpdate(address, updateAddressRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.addressUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified address
         * @param {string} address The address ID
         * @param {UpdateAddressRequest} updateAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressUpdate2(address: string, updateAddressRequest: UpdateAddressRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressUpdate2(address, updateAddressRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.addressUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AddressApi - factory interface
 */
export const AddressApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified address
         * @param {string} address The address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressDestroy(address: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addressDestroy(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of addresses
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressIndex200Response> {
            return localVarFp.addressIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified address
         * @param {string} address The address ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressShow(address: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressShow200Response> {
            return localVarFp.addressShow(address, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created address
         * @param {StoreAddressRequest} storeAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressStore(storeAddressRequest: StoreAddressRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddressShow200Response> {
            return localVarFp.addressStore(storeAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified address
         * @param {string} address The address ID
         * @param {UpdateAddressRequest} updateAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUpdate(address: string, updateAddressRequest: UpdateAddressRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddressShow200Response> {
            return localVarFp.addressUpdate(address, updateAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified address
         * @param {string} address The address ID
         * @param {UpdateAddressRequest} updateAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUpdate2(address: string, updateAddressRequest: UpdateAddressRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddressShow200Response> {
            return localVarFp.addressUpdate2(address, updateAddressRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressApi - object-oriented interface
 */
export class AddressApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified address
     * @param {string} address The address ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addressDestroy(address: string, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).addressDestroy(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of addresses
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addressIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).addressIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified address
     * @param {string} address The address ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addressShow(address: string, include?: string, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).addressShow(address, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created address
     * @param {StoreAddressRequest} storeAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addressStore(storeAddressRequest: StoreAddressRequest, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).addressStore(storeAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified address
     * @param {string} address The address ID
     * @param {UpdateAddressRequest} updateAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addressUpdate(address: string, updateAddressRequest: UpdateAddressRequest, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).addressUpdate(address, updateAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified address
     * @param {string} address The address ID
     * @param {UpdateAddressRequest} updateAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addressUpdate2(address: string, updateAddressRequest: UpdateAddressRequest, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).addressUpdate2(address, updateAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AddressTranslationApi - axios parameter creator
 */
export const AddressTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationDestroy: async (addressTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressTranslation' is not null or undefined
            assertParamExists('addressTranslationDestroy', 'addressTranslation', addressTranslation)
            const localVarPath = `/address-translation/{addressTranslation}`
                .replace(`{${"addressTranslation"}}`, encodeURIComponent(String(addressTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/address-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationShow: async (addressTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressTranslation' is not null or undefined
            assertParamExists('addressTranslationShow', 'addressTranslation', addressTranslation)
            const localVarPath = `/address-translation/{addressTranslation}`
                .replace(`{${"addressTranslation"}}`, encodeURIComponent(String(addressTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreAddressTranslationRequest} storeAddressTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationStore: async (storeAddressTranslationRequest: StoreAddressTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeAddressTranslationRequest' is not null or undefined
            assertParamExists('addressTranslationStore', 'storeAddressTranslationRequest', storeAddressTranslationRequest)
            const localVarPath = `/address-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeAddressTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} addressTranslation The address translation ID
         * @param {UpdateAddressTranslationRequest} [updateAddressTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationUpdate: async (addressTranslation: string, updateAddressTranslationRequest?: UpdateAddressTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressTranslation' is not null or undefined
            assertParamExists('addressTranslationUpdate', 'addressTranslation', addressTranslation)
            const localVarPath = `/address-translation/{addressTranslation}`
                .replace(`{${"addressTranslation"}}`, encodeURIComponent(String(addressTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAddressTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} addressTranslation The address translation ID
         * @param {UpdateAddressTranslationRequest} [updateAddressTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationUpdate2: async (addressTranslation: string, updateAddressTranslationRequest?: UpdateAddressTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressTranslation' is not null or undefined
            assertParamExists('addressTranslationUpdate2', 'addressTranslation', addressTranslation)
            const localVarPath = `/address-translation/{addressTranslation}`
                .replace(`{${"addressTranslation"}}`, encodeURIComponent(String(addressTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAddressTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressTranslationApi - functional programming interface
 */
export const AddressTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressTranslationDestroy(addressTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressTranslationDestroy(addressTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressTranslationApi.addressTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressTranslationApi.addressTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressTranslationShow(addressTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressTranslationShow(addressTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressTranslationApi.addressTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreAddressTranslationRequest} storeAddressTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressTranslationStore(storeAddressTranslationRequest: StoreAddressTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressTranslationStore(storeAddressTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressTranslationApi.addressTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} addressTranslation The address translation ID
         * @param {UpdateAddressTranslationRequest} [updateAddressTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressTranslationUpdate(addressTranslation: string, updateAddressTranslationRequest?: UpdateAddressTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressTranslationUpdate(addressTranslation, updateAddressTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressTranslationApi.addressTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} addressTranslation The address translation ID
         * @param {UpdateAddressTranslationRequest} [updateAddressTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressTranslationUpdate2(addressTranslation: string, updateAddressTranslationRequest?: UpdateAddressTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressTranslationUpdate2(addressTranslation, updateAddressTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressTranslationApi.addressTranslationUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AddressTranslationApi - factory interface
 */
export const AddressTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationDestroy(addressTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addressTranslationDestroy(addressTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<AddressTranslationIndex200Response> {
            return localVarFp.addressTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationShow(addressTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressTranslationShow200Response> {
            return localVarFp.addressTranslationShow(addressTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreAddressTranslationRequest} storeAddressTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationStore(storeAddressTranslationRequest: StoreAddressTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddressTranslationShow200Response> {
            return localVarFp.addressTranslationStore(storeAddressTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} addressTranslation The address translation ID
         * @param {UpdateAddressTranslationRequest} [updateAddressTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationUpdate(addressTranslation: string, updateAddressTranslationRequest?: UpdateAddressTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddressTranslationShow200Response> {
            return localVarFp.addressTranslationUpdate(addressTranslation, updateAddressTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} addressTranslation The address translation ID
         * @param {UpdateAddressTranslationRequest} [updateAddressTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationUpdate2(addressTranslation: string, updateAddressTranslationRequest?: UpdateAddressTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddressTranslationShow200Response> {
            return localVarFp.addressTranslationUpdate2(addressTranslation, updateAddressTranslationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressTranslationApi - object-oriented interface
 */
export class AddressTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} addressTranslation The address translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addressTranslationDestroy(addressTranslation: string, options?: RawAxiosRequestConfig) {
        return AddressTranslationApiFp(this.configuration).addressTranslationDestroy(addressTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addressTranslationIndex(options?: RawAxiosRequestConfig) {
        return AddressTranslationApiFp(this.configuration).addressTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} addressTranslation The address translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addressTranslationShow(addressTranslation: string, options?: RawAxiosRequestConfig) {
        return AddressTranslationApiFp(this.configuration).addressTranslationShow(addressTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreAddressTranslationRequest} storeAddressTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addressTranslationStore(storeAddressTranslationRequest: StoreAddressTranslationRequest, options?: RawAxiosRequestConfig) {
        return AddressTranslationApiFp(this.configuration).addressTranslationStore(storeAddressTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} addressTranslation The address translation ID
     * @param {UpdateAddressTranslationRequest} [updateAddressTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addressTranslationUpdate(addressTranslation: string, updateAddressTranslationRequest?: UpdateAddressTranslationRequest, options?: RawAxiosRequestConfig) {
        return AddressTranslationApiFp(this.configuration).addressTranslationUpdate(addressTranslation, updateAddressTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} addressTranslation The address translation ID
     * @param {UpdateAddressTranslationRequest} [updateAddressTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addressTranslationUpdate2(addressTranslation: string, updateAddressTranslationRequest?: UpdateAddressTranslationRequest, options?: RawAxiosRequestConfig) {
        return AddressTranslationApiFp(this.configuration).addressTranslationUpdate2(addressTranslation, updateAddressTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AvailableImageApi - axios parameter creator
 */
export const AvailableImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageDestroy: async (availableImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageDestroy', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download the file to the caller
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageDownload: async (availableImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageDownload', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}/download`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/available-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageShow: async (availableImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageShow', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} availableImage The available image ID
         * @param {UpdateAvailableImageRequest} [updateAvailableImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageUpdate: async (availableImage: string, updateAvailableImageRequest?: UpdateAvailableImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageUpdate', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAvailableImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} availableImage The available image ID
         * @param {UpdateAvailableImageRequest} [updateAvailableImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageUpdate3: async (availableImage: string, updateAvailableImageRequest?: UpdateAvailableImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageUpdate3', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAvailableImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageView: async (availableImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageView', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}/view`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AvailableImageApi - functional programming interface
 */
export const AvailableImageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AvailableImageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageDestroy(availableImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageDestroy(availableImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download the file to the caller
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageDownload(availableImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageDownload(availableImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageDownload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableImageIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageShow(availableImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageShow(availableImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} availableImage The available image ID
         * @param {UpdateAvailableImageRequest} [updateAvailableImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageUpdate(availableImage: string, updateAvailableImageRequest?: UpdateAvailableImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageUpdate(availableImage, updateAvailableImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} availableImage The available image ID
         * @param {UpdateAvailableImageRequest} [updateAvailableImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageUpdate3(availableImage: string, updateAvailableImageRequest?: UpdateAvailableImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageUpdate3(availableImage, updateAvailableImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageUpdate3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageView(availableImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageView(availableImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AvailableImageApi - factory interface
 */
export const AvailableImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AvailableImageApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageDestroy(availableImage: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.availableImageDestroy(availableImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download the file to the caller
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageDownload(availableImage: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.availableImageDownload(availableImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<AvailableImageIndex200Response> {
            return localVarFp.availableImageIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageShow(availableImage: string, options?: RawAxiosRequestConfig): AxiosPromise<AvailableImageShow200Response> {
            return localVarFp.availableImageShow(availableImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} availableImage The available image ID
         * @param {UpdateAvailableImageRequest} [updateAvailableImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageUpdate(availableImage: string, updateAvailableImageRequest?: UpdateAvailableImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<AvailableImageShow200Response> {
            return localVarFp.availableImageUpdate(availableImage, updateAvailableImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} availableImage The available image ID
         * @param {UpdateAvailableImageRequest} [updateAvailableImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageUpdate3(availableImage: string, updateAvailableImageRequest?: UpdateAvailableImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<AvailableImageShow200Response> {
            return localVarFp.availableImageUpdate3(availableImage, updateAvailableImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageView(availableImage: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.availableImageView(availableImage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AvailableImageApi - object-oriented interface
 */
export class AvailableImageApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} availableImage The available image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public availableImageDestroy(availableImage: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageDestroy(availableImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download the file to the caller
     * @param {string} availableImage The available image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public availableImageDownload(availableImage: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageDownload(availableImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public availableImageIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} availableImage The available image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public availableImageShow(availableImage: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageShow(availableImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} availableImage The available image ID
     * @param {UpdateAvailableImageRequest} [updateAvailableImageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public availableImageUpdate(availableImage: string, updateAvailableImageRequest?: UpdateAvailableImageRequest, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageUpdate(availableImage, updateAvailableImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} availableImage The available image ID
     * @param {UpdateAvailableImageRequest} [updateAvailableImageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public availableImageUpdate3(availableImage: string, updateAvailableImageRequest?: UpdateAvailableImageRequest, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageUpdate3(availableImage, updateAvailableImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
     * @param {string} availableImage The available image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public availableImageView(availableImage: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageView(availableImage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CollectionApi - axios parameter creator
 */
export const CollectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Attach an item to a collection via many-to-many relationship
         * @param {string} collection The collection ID
         * @param {AttachItemCollectionRequest} attachItemCollectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionAttachItem: async (collection: string, attachItemCollectionRequest: AttachItemCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionAttachItem', 'collection', collection)
            // verify required parameter 'attachItemCollectionRequest' is not null or undefined
            assertParamExists('collectionAttachItem', 'attachItemCollectionRequest', attachItemCollectionRequest)
            const localVarPath = `/collection/{collection}/attach-item`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachItemCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Attach multiple items to a collection
         * @param {string} collection The collection ID
         * @param {AttachItemsCollectionRequest} attachItemsCollectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionAttachItems: async (collection: string, attachItemsCollectionRequest: AttachItemsCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionAttachItems', 'collection', collection)
            // verify required parameter 'attachItemsCollectionRequest' is not null or undefined
            assertParamExists('collectionAttachItems', 'attachItemsCollectionRequest', attachItemsCollectionRequest)
            const localVarPath = `/collection/{collection}/attach-items`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachItemsCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get collections by type
         * @param {string} type 
         * @param {CollectionByTypeTypeEnum} type2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionByType: async (type: string, type2: CollectionByTypeTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('collectionByType', 'type', type)
            // verify required parameter 'type2' is not null or undefined
            assertParamExists('collectionByType', 'type2', type2)
            const localVarPath = `/collection/type/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type2 !== undefined) {
                localVarQueryParameter['type'] = type2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified collection from storage
         * @param {string} collection The collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionDestroy: async (collection: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionDestroy', 'collection', collection)
            const localVarPath = `/collection/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach an item from a collection
         * @param {string} collection The collection ID
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionDetachItem: async (collection: string, itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionDetachItem', 'collection', collection)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('collectionDetachItem', 'itemId', itemId)
            const localVarPath = `/collection/{collection}/detach-item`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (itemId !== undefined) {
                localVarQueryParameter['item_id'] = itemId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach multiple items from a collection
         * @param {string} collection The collection ID
         * @param {Array<string>} itemIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionDetachItems: async (collection: string, itemIds: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionDetachItems', 'collection', collection)
            // verify required parameter 'itemIds' is not null or undefined
            assertParamExists('collectionDetachItems', 'itemIds', itemIds)
            const localVarPath = `/collection/{collection}/detach-items`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (itemIds) {
                localVarQueryParameter['item_ids[]'] = itemIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the collections
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified collection
         * @param {string} collection The collection ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionShow: async (collection: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionShow', 'collection', collection)
            const localVarPath = `/collection/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created collection in storage
         * @param {StoreCollectionRequest} storeCollectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionStore: async (storeCollectionRequest: StoreCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeCollectionRequest' is not null or undefined
            assertParamExists('collectionStore', 'storeCollectionRequest', storeCollectionRequest)
            const localVarPath = `/collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified collection in storage
         * @param {string} collection The collection ID
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionUpdate: async (collection: string, updateCollectionRequest?: UpdateCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionUpdate', 'collection', collection)
            const localVarPath = `/collection/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified collection in storage
         * @param {string} collection The collection ID
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionUpdate2: async (collection: string, updateCollectionRequest?: UpdateCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionUpdate2', 'collection', collection)
            const localVarPath = `/collection/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionApi - functional programming interface
 */
export const CollectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Attach an item to a collection via many-to-many relationship
         * @param {string} collection The collection ID
         * @param {AttachItemCollectionRequest} attachItemCollectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionAttachItem(collection: string, attachItemCollectionRequest: AttachItemCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionAttachItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionAttachItem(collection, attachItemCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionAttachItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Attach multiple items to a collection
         * @param {string} collection The collection ID
         * @param {AttachItemsCollectionRequest} attachItemsCollectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionAttachItems(collection: string, attachItemsCollectionRequest: AttachItemsCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionAttachItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionAttachItems(collection, attachItemsCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionAttachItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get collections by type
         * @param {string} type 
         * @param {CollectionByTypeTypeEnum} type2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionByType(type: string, type2: CollectionByTypeTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionByType200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionByType(type, type2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionByType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified collection from storage
         * @param {string} collection The collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionDestroy(collection: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionDestroy(collection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Detach an item from a collection
         * @param {string} collection The collection ID
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionDetachItem(collection: string, itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionAttachItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionDetachItem(collection, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionDetachItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Detach multiple items from a collection
         * @param {string} collection The collection ID
         * @param {Array<string>} itemIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionDetachItems(collection: string, itemIds: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionAttachItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionDetachItems(collection, itemIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionDetachItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the collections
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified collection
         * @param {string} collection The collection ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionShow(collection: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionShow(collection, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created collection in storage
         * @param {StoreCollectionRequest} storeCollectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionStore(storeCollectionRequest: StoreCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionStore(storeCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified collection in storage
         * @param {string} collection The collection ID
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionUpdate(collection: string, updateCollectionRequest?: UpdateCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionUpdate(collection, updateCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified collection in storage
         * @param {string} collection The collection ID
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionUpdate2(collection: string, updateCollectionRequest?: UpdateCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionUpdate2(collection, updateCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CollectionApi - factory interface
 */
export const CollectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionApiFp(configuration)
    return {
        /**
         * 
         * @summary Attach an item to a collection via many-to-many relationship
         * @param {string} collection The collection ID
         * @param {AttachItemCollectionRequest} attachItemCollectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionAttachItem(collection: string, attachItemCollectionRequest: AttachItemCollectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionAttachItem200Response> {
            return localVarFp.collectionAttachItem(collection, attachItemCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Attach multiple items to a collection
         * @param {string} collection The collection ID
         * @param {AttachItemsCollectionRequest} attachItemsCollectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionAttachItems(collection: string, attachItemsCollectionRequest: AttachItemsCollectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionAttachItem200Response> {
            return localVarFp.collectionAttachItems(collection, attachItemsCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get collections by type
         * @param {string} type 
         * @param {CollectionByTypeTypeEnum} type2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionByType(type: string, type2: CollectionByTypeTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<CollectionByType200Response> {
            return localVarFp.collectionByType(type, type2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified collection from storage
         * @param {string} collection The collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionDestroy(collection: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.collectionDestroy(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detach an item from a collection
         * @param {string} collection The collection ID
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionDetachItem(collection: string, itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionAttachItem200Response> {
            return localVarFp.collectionDetachItem(collection, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detach multiple items from a collection
         * @param {string} collection The collection ID
         * @param {Array<string>} itemIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionDetachItems(collection: string, itemIds: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CollectionAttachItem200Response> {
            return localVarFp.collectionDetachItems(collection, itemIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the collections
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionIndex200Response> {
            return localVarFp.collectionIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified collection
         * @param {string} collection The collection ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionShow(collection: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionShow200Response> {
            return localVarFp.collectionShow(collection, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created collection in storage
         * @param {StoreCollectionRequest} storeCollectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionStore(storeCollectionRequest: StoreCollectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionShow200Response> {
            return localVarFp.collectionStore(storeCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified collection in storage
         * @param {string} collection The collection ID
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionUpdate(collection: string, updateCollectionRequest?: UpdateCollectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionShow200Response> {
            return localVarFp.collectionUpdate(collection, updateCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified collection in storage
         * @param {string} collection The collection ID
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionUpdate2(collection: string, updateCollectionRequest?: UpdateCollectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionShow200Response> {
            return localVarFp.collectionUpdate2(collection, updateCollectionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionApi - object-oriented interface
 */
export class CollectionApi extends BaseAPI {
    /**
     * 
     * @summary Attach an item to a collection via many-to-many relationship
     * @param {string} collection The collection ID
     * @param {AttachItemCollectionRequest} attachItemCollectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionAttachItem(collection: string, attachItemCollectionRequest: AttachItemCollectionRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionAttachItem(collection, attachItemCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Attach multiple items to a collection
     * @param {string} collection The collection ID
     * @param {AttachItemsCollectionRequest} attachItemsCollectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionAttachItems(collection: string, attachItemsCollectionRequest: AttachItemsCollectionRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionAttachItems(collection, attachItemsCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get collections by type
     * @param {string} type 
     * @param {CollectionByTypeTypeEnum} type2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionByType(type: string, type2: CollectionByTypeTypeEnum, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionByType(type, type2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified collection from storage
     * @param {string} collection The collection ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionDestroy(collection: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionDestroy(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detach an item from a collection
     * @param {string} collection The collection ID
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionDetachItem(collection: string, itemId: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionDetachItem(collection, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detach multiple items from a collection
     * @param {string} collection The collection ID
     * @param {Array<string>} itemIds 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionDetachItems(collection: string, itemIds: Array<string>, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionDetachItems(collection, itemIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the collections
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified collection
     * @param {string} collection The collection ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionShow(collection: string, include?: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionShow(collection, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created collection in storage
     * @param {StoreCollectionRequest} storeCollectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionStore(storeCollectionRequest: StoreCollectionRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionStore(storeCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified collection in storage
     * @param {string} collection The collection ID
     * @param {UpdateCollectionRequest} [updateCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionUpdate(collection: string, updateCollectionRequest?: UpdateCollectionRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionUpdate(collection, updateCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified collection in storage
     * @param {string} collection The collection ID
     * @param {UpdateCollectionRequest} [updateCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionUpdate2(collection: string, updateCollectionRequest?: UpdateCollectionRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionUpdate2(collection, updateCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const CollectionByTypeTypeEnum = {
    Collection: 'collection',
    Exhibition: 'exhibition',
    Gallery: 'gallery'
} as const;
export type CollectionByTypeTypeEnum = typeof CollectionByTypeTypeEnum[keyof typeof CollectionByTypeTypeEnum];


/**
 * ContactApi - axios parameter creator
 */
export const ContactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified contact
         * @param {string} contact The contact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactDestroy: async (contact: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('contactDestroy', 'contact', contact)
            const localVarPath = `/contact/{contact}`
                .replace(`{${"contact"}}`, encodeURIComponent(String(contact)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of contacts
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified contact
         * @param {string} contact The contact ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactShow: async (contact: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('contactShow', 'contact', contact)
            const localVarPath = `/contact/{contact}`
                .replace(`{${"contact"}}`, encodeURIComponent(String(contact)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created contact
         * @param {StoreContactRequest} storeContactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactStore: async (storeContactRequest: StoreContactRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeContactRequest' is not null or undefined
            assertParamExists('contactStore', 'storeContactRequest', storeContactRequest)
            const localVarPath = `/contact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeContactRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified contact
         * @param {string} contact The contact ID
         * @param {UpdateContactRequest} updateContactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactUpdate: async (contact: string, updateContactRequest: UpdateContactRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('contactUpdate', 'contact', contact)
            // verify required parameter 'updateContactRequest' is not null or undefined
            assertParamExists('contactUpdate', 'updateContactRequest', updateContactRequest)
            const localVarPath = `/contact/{contact}`
                .replace(`{${"contact"}}`, encodeURIComponent(String(contact)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateContactRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified contact
         * @param {string} contact The contact ID
         * @param {UpdateContactRequest} updateContactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactUpdate2: async (contact: string, updateContactRequest: UpdateContactRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('contactUpdate2', 'contact', contact)
            // verify required parameter 'updateContactRequest' is not null or undefined
            assertParamExists('contactUpdate2', 'updateContactRequest', updateContactRequest)
            const localVarPath = `/contact/{contact}`
                .replace(`{${"contact"}}`, encodeURIComponent(String(contact)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateContactRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactApi - functional programming interface
 */
export const ContactApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified contact
         * @param {string} contact The contact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactDestroy(contact: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactDestroy(contact, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.contactDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of contacts
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.contactIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified contact
         * @param {string} contact The contact ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactShow(contact: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactShow(contact, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.contactShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created contact
         * @param {StoreContactRequest} storeContactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactStore(storeContactRequest: StoreContactRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactStore(storeContactRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.contactStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified contact
         * @param {string} contact The contact ID
         * @param {UpdateContactRequest} updateContactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactUpdate(contact: string, updateContactRequest: UpdateContactRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactUpdate(contact, updateContactRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.contactUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified contact
         * @param {string} contact The contact ID
         * @param {UpdateContactRequest} updateContactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactUpdate2(contact: string, updateContactRequest: UpdateContactRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactUpdate2(contact, updateContactRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.contactUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactApi - factory interface
 */
export const ContactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified contact
         * @param {string} contact The contact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactDestroy(contact: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.contactDestroy(contact, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of contacts
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContactIndex200Response> {
            return localVarFp.contactIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified contact
         * @param {string} contact The contact ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactShow(contact: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContactShow200Response> {
            return localVarFp.contactShow(contact, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created contact
         * @param {StoreContactRequest} storeContactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactStore(storeContactRequest: StoreContactRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContactShow200Response> {
            return localVarFp.contactStore(storeContactRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified contact
         * @param {string} contact The contact ID
         * @param {UpdateContactRequest} updateContactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactUpdate(contact: string, updateContactRequest: UpdateContactRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContactShow200Response> {
            return localVarFp.contactUpdate(contact, updateContactRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified contact
         * @param {string} contact The contact ID
         * @param {UpdateContactRequest} updateContactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactUpdate2(contact: string, updateContactRequest: UpdateContactRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContactShow200Response> {
            return localVarFp.contactUpdate2(contact, updateContactRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactApi - object-oriented interface
 */
export class ContactApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified contact
     * @param {string} contact The contact ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contactDestroy(contact: string, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactDestroy(contact, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of contacts
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contactIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified contact
     * @param {string} contact The contact ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contactShow(contact: string, include?: string, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactShow(contact, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created contact
     * @param {StoreContactRequest} storeContactRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contactStore(storeContactRequest: StoreContactRequest, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactStore(storeContactRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified contact
     * @param {string} contact The contact ID
     * @param {UpdateContactRequest} updateContactRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contactUpdate(contact: string, updateContactRequest: UpdateContactRequest, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactUpdate(contact, updateContactRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified contact
     * @param {string} contact The contact ID
     * @param {UpdateContactRequest} updateContactRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contactUpdate2(contact: string, updateContactRequest: UpdateContactRequest, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactUpdate2(contact, updateContactRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContactTranslationApi - axios parameter creator
 */
export const ContactTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationDestroy: async (contactTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactTranslation' is not null or undefined
            assertParamExists('contactTranslationDestroy', 'contactTranslation', contactTranslation)
            const localVarPath = `/contact-translation/{contactTranslation}`
                .replace(`{${"contactTranslation"}}`, encodeURIComponent(String(contactTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contact-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationShow: async (contactTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactTranslation' is not null or undefined
            assertParamExists('contactTranslationShow', 'contactTranslation', contactTranslation)
            const localVarPath = `/contact-translation/{contactTranslation}`
                .replace(`{${"contactTranslation"}}`, encodeURIComponent(String(contactTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreContactTranslationRequest} storeContactTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationStore: async (storeContactTranslationRequest: StoreContactTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeContactTranslationRequest' is not null or undefined
            assertParamExists('contactTranslationStore', 'storeContactTranslationRequest', storeContactTranslationRequest)
            const localVarPath = `/contact-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeContactTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} contactTranslation The contact translation ID
         * @param {UpdateContactTranslationRequest} [updateContactTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationUpdate: async (contactTranslation: string, updateContactTranslationRequest?: UpdateContactTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactTranslation' is not null or undefined
            assertParamExists('contactTranslationUpdate', 'contactTranslation', contactTranslation)
            const localVarPath = `/contact-translation/{contactTranslation}`
                .replace(`{${"contactTranslation"}}`, encodeURIComponent(String(contactTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateContactTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} contactTranslation The contact translation ID
         * @param {UpdateContactTranslationRequest} [updateContactTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationUpdate2: async (contactTranslation: string, updateContactTranslationRequest?: UpdateContactTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactTranslation' is not null or undefined
            assertParamExists('contactTranslationUpdate2', 'contactTranslation', contactTranslation)
            const localVarPath = `/contact-translation/{contactTranslation}`
                .replace(`{${"contactTranslation"}}`, encodeURIComponent(String(contactTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateContactTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactTranslationApi - functional programming interface
 */
export const ContactTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactTranslationDestroy(contactTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactTranslationDestroy(contactTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactTranslationApi.contactTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactTranslationApi.contactTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactTranslationShow(contactTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactTranslationShow(contactTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactTranslationApi.contactTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreContactTranslationRequest} storeContactTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactTranslationStore(storeContactTranslationRequest: StoreContactTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactTranslationStore(storeContactTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactTranslationApi.contactTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} contactTranslation The contact translation ID
         * @param {UpdateContactTranslationRequest} [updateContactTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactTranslationUpdate(contactTranslation: string, updateContactTranslationRequest?: UpdateContactTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactTranslationUpdate(contactTranslation, updateContactTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactTranslationApi.contactTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} contactTranslation The contact translation ID
         * @param {UpdateContactTranslationRequest} [updateContactTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactTranslationUpdate2(contactTranslation: string, updateContactTranslationRequest?: UpdateContactTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactTranslationUpdate2(contactTranslation, updateContactTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactTranslationApi.contactTranslationUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactTranslationApi - factory interface
 */
export const ContactTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationDestroy(contactTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.contactTranslationDestroy(contactTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<ContactTranslationIndex200Response> {
            return localVarFp.contactTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationShow(contactTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ContactTranslationShow200Response> {
            return localVarFp.contactTranslationShow(contactTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreContactTranslationRequest} storeContactTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationStore(storeContactTranslationRequest: StoreContactTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContactTranslationShow200Response> {
            return localVarFp.contactTranslationStore(storeContactTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} contactTranslation The contact translation ID
         * @param {UpdateContactTranslationRequest} [updateContactTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationUpdate(contactTranslation: string, updateContactTranslationRequest?: UpdateContactTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContactTranslationShow200Response> {
            return localVarFp.contactTranslationUpdate(contactTranslation, updateContactTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} contactTranslation The contact translation ID
         * @param {UpdateContactTranslationRequest} [updateContactTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationUpdate2(contactTranslation: string, updateContactTranslationRequest?: UpdateContactTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContactTranslationShow200Response> {
            return localVarFp.contactTranslationUpdate2(contactTranslation, updateContactTranslationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactTranslationApi - object-oriented interface
 */
export class ContactTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} contactTranslation The contact translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contactTranslationDestroy(contactTranslation: string, options?: RawAxiosRequestConfig) {
        return ContactTranslationApiFp(this.configuration).contactTranslationDestroy(contactTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contactTranslationIndex(options?: RawAxiosRequestConfig) {
        return ContactTranslationApiFp(this.configuration).contactTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} contactTranslation The contact translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contactTranslationShow(contactTranslation: string, options?: RawAxiosRequestConfig) {
        return ContactTranslationApiFp(this.configuration).contactTranslationShow(contactTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreContactTranslationRequest} storeContactTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contactTranslationStore(storeContactTranslationRequest: StoreContactTranslationRequest, options?: RawAxiosRequestConfig) {
        return ContactTranslationApiFp(this.configuration).contactTranslationStore(storeContactTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} contactTranslation The contact translation ID
     * @param {UpdateContactTranslationRequest} [updateContactTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contactTranslationUpdate(contactTranslation: string, updateContactTranslationRequest?: UpdateContactTranslationRequest, options?: RawAxiosRequestConfig) {
        return ContactTranslationApiFp(this.configuration).contactTranslationUpdate(contactTranslation, updateContactTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} contactTranslation The contact translation ID
     * @param {UpdateContactTranslationRequest} [updateContactTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contactTranslationUpdate2(contactTranslation: string, updateContactTranslationRequest?: UpdateContactTranslationRequest, options?: RawAxiosRequestConfig) {
        return ContactTranslationApiFp(this.configuration).contactTranslationUpdate2(contactTranslation, updateContactTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContextApi - axios parameter creator
 */
export const ContextApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clear the default flag from any context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextClearDefault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/context/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} context The context ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDestroy: async (context: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('contextDestroy', 'context', context)
            const localVarPath = `/context/{context}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the default context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextGetDefault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/context/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set or unset a context as the default one
         * @param {string} context The context ID
         * @param {SetDefaultContextRequest} setDefaultContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextSetDefault: async (context: string, setDefaultContextRequest: SetDefaultContextRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('contextSetDefault', 'context', context)
            // verify required parameter 'setDefaultContextRequest' is not null or undefined
            assertParamExists('contextSetDefault', 'setDefaultContextRequest', setDefaultContextRequest)
            const localVarPath = `/context/{context}/default`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setDefaultContextRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} context The context ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextShow: async (context: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('contextShow', 'context', context)
            const localVarPath = `/context/{context}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreContextRequest} storeContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextStore: async (storeContextRequest: StoreContextRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeContextRequest' is not null or undefined
            assertParamExists('contextStore', 'storeContextRequest', storeContextRequest)
            const localVarPath = `/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeContextRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} context The context ID
         * @param {UpdateContextRequest} updateContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextUpdate: async (context: string, updateContextRequest: UpdateContextRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('contextUpdate', 'context', context)
            // verify required parameter 'updateContextRequest' is not null or undefined
            assertParamExists('contextUpdate', 'updateContextRequest', updateContextRequest)
            const localVarPath = `/context/{context}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateContextRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} context The context ID
         * @param {UpdateContextRequest} updateContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextUpdate2: async (context: string, updateContextRequest: UpdateContextRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('contextUpdate2', 'context', context)
            // verify required parameter 'updateContextRequest' is not null or undefined
            assertParamExists('contextUpdate2', 'updateContextRequest', updateContextRequest)
            const localVarPath = `/context/{context}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateContextRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContextApi - functional programming interface
 */
export const ContextApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContextApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Clear the default flag from any context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextClearDefault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextClearDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextClearDefault(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextClearDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} context The context ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextDestroy(context: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextDestroy(context, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the default context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextGetDefault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextGetDefault(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextGetDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set or unset a context as the default one
         * @param {string} context The context ID
         * @param {SetDefaultContextRequest} setDefaultContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextSetDefault(context: string, setDefaultContextRequest: SetDefaultContextRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextSetDefault(context, setDefaultContextRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextSetDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} context The context ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextShow(context: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextShow(context, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreContextRequest} storeContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextStore(storeContextRequest: StoreContextRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextStore(storeContextRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} context The context ID
         * @param {UpdateContextRequest} updateContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextUpdate(context: string, updateContextRequest: UpdateContextRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextUpdate(context, updateContextRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} context The context ID
         * @param {UpdateContextRequest} updateContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextUpdate2(context: string, updateContextRequest: UpdateContextRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextUpdate2(context, updateContextRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContextApi - factory interface
 */
export const ContextApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContextApiFp(configuration)
    return {
        /**
         * 
         * @summary Clear the default flag from any context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextClearDefault(options?: RawAxiosRequestConfig): AxiosPromise<ContextClearDefault200Response> {
            return localVarFp.contextClearDefault(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} context The context ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDestroy(context: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.contextDestroy(context, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the default context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextGetDefault(options?: RawAxiosRequestConfig): AxiosPromise<ContextGetDefault200Response> {
            return localVarFp.contextGetDefault(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContextIndex200Response> {
            return localVarFp.contextIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set or unset a context as the default one
         * @param {string} context The context ID
         * @param {SetDefaultContextRequest} setDefaultContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextSetDefault(context: string, setDefaultContextRequest: SetDefaultContextRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContextGetDefault200Response> {
            return localVarFp.contextSetDefault(context, setDefaultContextRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} context The context ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextShow(context: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContextGetDefault200Response> {
            return localVarFp.contextShow(context, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreContextRequest} storeContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextStore(storeContextRequest: StoreContextRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContextGetDefault200Response> {
            return localVarFp.contextStore(storeContextRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} context The context ID
         * @param {UpdateContextRequest} updateContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextUpdate(context: string, updateContextRequest: UpdateContextRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContextGetDefault200Response> {
            return localVarFp.contextUpdate(context, updateContextRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} context The context ID
         * @param {UpdateContextRequest} updateContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextUpdate2(context: string, updateContextRequest: UpdateContextRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContextGetDefault200Response> {
            return localVarFp.contextUpdate2(context, updateContextRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContextApi - object-oriented interface
 */
export class ContextApi extends BaseAPI {
    /**
     * 
     * @summary Clear the default flag from any context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contextClearDefault(options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextClearDefault(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} context The context ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contextDestroy(context: string, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextDestroy(context, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the default context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contextGetDefault(options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextGetDefault(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contextIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set or unset a context as the default one
     * @param {string} context The context ID
     * @param {SetDefaultContextRequest} setDefaultContextRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contextSetDefault(context: string, setDefaultContextRequest: SetDefaultContextRequest, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextSetDefault(context, setDefaultContextRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} context The context ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contextShow(context: string, include?: string, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextShow(context, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreContextRequest} storeContextRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contextStore(storeContextRequest: StoreContextRequest, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextStore(storeContextRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} context The context ID
     * @param {UpdateContextRequest} updateContextRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contextUpdate(context: string, updateContextRequest: UpdateContextRequest, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextUpdate(context, updateContextRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} context The context ID
     * @param {UpdateContextRequest} updateContextRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contextUpdate2(context: string, updateContextRequest: UpdateContextRequest, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextUpdate2(context, updateContextRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CountryApi - axios parameter creator
 */
export const CountryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} country The country ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryDestroy: async (country: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('countryDestroy', 'country', country)
            const localVarPath = `/country/{country}`
                .replace(`{${"country"}}`, encodeURIComponent(String(country)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/country`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} country The country ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryShow: async (country: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('countryShow', 'country', country)
            const localVarPath = `/country/{country}`
                .replace(`{${"country"}}`, encodeURIComponent(String(country)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreCountryRequest} storeCountryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryStore: async (storeCountryRequest: StoreCountryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeCountryRequest' is not null or undefined
            assertParamExists('countryStore', 'storeCountryRequest', storeCountryRequest)
            const localVarPath = `/country`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeCountryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} country The country ID
         * @param {UpdateCountryRequest} updateCountryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryUpdate: async (country: string, updateCountryRequest: UpdateCountryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('countryUpdate', 'country', country)
            // verify required parameter 'updateCountryRequest' is not null or undefined
            assertParamExists('countryUpdate', 'updateCountryRequest', updateCountryRequest)
            const localVarPath = `/country/{country}`
                .replace(`{${"country"}}`, encodeURIComponent(String(country)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCountryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} country The country ID
         * @param {UpdateCountryRequest} updateCountryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryUpdate2: async (country: string, updateCountryRequest: UpdateCountryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('countryUpdate2', 'country', country)
            // verify required parameter 'updateCountryRequest' is not null or undefined
            assertParamExists('countryUpdate2', 'updateCountryRequest', updateCountryRequest)
            const localVarPath = `/country/{country}`
                .replace(`{${"country"}}`, encodeURIComponent(String(country)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCountryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountryApi - functional programming interface
 */
export const CountryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CountryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} country The country ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryDestroy(country: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryDestroy(country, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} country The country ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryShow(country: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryShow(country, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreCountryRequest} storeCountryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryStore(storeCountryRequest: StoreCountryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryStore(storeCountryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} country The country ID
         * @param {UpdateCountryRequest} updateCountryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryUpdate(country: string, updateCountryRequest: UpdateCountryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryUpdate(country, updateCountryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} country The country ID
         * @param {UpdateCountryRequest} updateCountryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryUpdate2(country: string, updateCountryRequest: UpdateCountryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryUpdate2(country, updateCountryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CountryApi - factory interface
 */
export const CountryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CountryApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} country The country ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryDestroy(country: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.countryDestroy(country, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<CountryIndex200Response> {
            return localVarFp.countryIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} country The country ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryShow(country: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<CountryShow200Response> {
            return localVarFp.countryShow(country, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreCountryRequest} storeCountryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryStore(storeCountryRequest: StoreCountryRequest, options?: RawAxiosRequestConfig): AxiosPromise<CountryShow200Response> {
            return localVarFp.countryStore(storeCountryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} country The country ID
         * @param {UpdateCountryRequest} updateCountryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryUpdate(country: string, updateCountryRequest: UpdateCountryRequest, options?: RawAxiosRequestConfig): AxiosPromise<CountryShow200Response> {
            return localVarFp.countryUpdate(country, updateCountryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} country The country ID
         * @param {UpdateCountryRequest} updateCountryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryUpdate2(country: string, updateCountryRequest: UpdateCountryRequest, options?: RawAxiosRequestConfig): AxiosPromise<CountryShow200Response> {
            return localVarFp.countryUpdate2(country, updateCountryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CountryApi - object-oriented interface
 */
export class CountryApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} country The country ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public countryDestroy(country: string, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryDestroy(country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public countryIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} country The country ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public countryShow(country: string, include?: string, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryShow(country, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreCountryRequest} storeCountryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public countryStore(storeCountryRequest: StoreCountryRequest, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryStore(storeCountryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} country The country ID
     * @param {UpdateCountryRequest} updateCountryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public countryUpdate(country: string, updateCountryRequest: UpdateCountryRequest, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryUpdate(country, updateCountryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} country The country ID
     * @param {UpdateCountryRequest} updateCountryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public countryUpdate2(country: string, updateCountryRequest: UpdateCountryRequest, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryUpdate2(country, updateCountryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImageUploadApi - axios parameter creator
 */
export const ImageUploadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadDestroy: async (imageUpload: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageUpload' is not null or undefined
            assertParamExists('imageUploadDestroy', 'imageUpload', imageUpload)
            const localVarPath = `/image-upload/{imageUpload}`
                .replace(`{${"imageUpload"}}`, encodeURIComponent(String(imageUpload)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/image-upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadShow: async (imageUpload: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageUpload' is not null or undefined
            assertParamExists('imageUploadShow', 'imageUpload', imageUpload)
            const localVarPath = `/image-upload/{imageUpload}`
                .replace(`{${"imageUpload"}}`, encodeURIComponent(String(imageUpload)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the processing status. If processing is complete, returns the AvailableImage details. If the ImageUpload no longer exists, check if an AvailableImage exists with the same ID.
         * @summary Get the processing status of an image upload
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadStatus: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageUploadStatus', 'id', id)
            const localVarPath = `/image-upload/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadStore: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('imageUploadStore', 'file', file)
            const localVarPath = `/image-upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageUploadApi - functional programming interface
 */
export const ImageUploadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImageUploadApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadDestroy(imageUpload: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadDestroy(imageUpload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadShow(imageUpload: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadShow(imageUpload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the processing status. If processing is complete, returns the AvailableImage details. If the ImageUpload no longer exists, check if an AvailableImage exists with the same ID.
         * @summary Get the processing status of an image upload
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadStatus(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadStatus(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadStore(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadStore(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImageUploadApi - factory interface
 */
export const ImageUploadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImageUploadApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadDestroy(imageUpload: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.imageUploadDestroy(imageUpload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadIndex(options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadIndex200Response> {
            return localVarFp.imageUploadIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadShow(imageUpload: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadShow200Response> {
            return localVarFp.imageUploadShow(imageUpload, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the processing status. If processing is complete, returns the AvailableImage details. If the ImageUpload no longer exists, check if an AvailableImage exists with the same ID.
         * @summary Get the processing status of an image upload
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadStatus(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadStatus200Response> {
            return localVarFp.imageUploadStatus(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadStore(file: File, options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadShow200Response> {
            return localVarFp.imageUploadStore(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImageUploadApi - object-oriented interface
 */
export class ImageUploadApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} imageUpload The image upload ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public imageUploadDestroy(imageUpload: string, options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadDestroy(imageUpload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public imageUploadIndex(options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} imageUpload The image upload ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public imageUploadShow(imageUpload: string, options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadShow(imageUpload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the processing status. If processing is complete, returns the AvailableImage details. If the ImageUpload no longer exists, check if an AvailableImage exists with the same ID.
     * @summary Get the processing status of an image upload
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public imageUploadStatus(id: string, options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadStatus(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public imageUploadStore(file: File, options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadStore(file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InfoApi - axios parameter creator
 */
export const InfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lightweight endpoint for health monitoring that returns only the essential health status information.
         * @summary Get only the health check status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns basic application information including: - Application name and version - Health check status for key services - Timestamp of the response
         * @summary Get application information including version and health status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple endpoint that returns just the version information for deployment tracking and API compatibility checks.
         * @summary Get application version information only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoVersion: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoApi - functional programming interface
 */
export const InfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfoApiAxiosParamCreator(configuration)
    return {
        /**
         * Lightweight endpoint for health monitoring that returns only the essential health status information.
         * @summary Get only the health check status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infoHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infoHealth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.infoHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns basic application information including: - Application name and version - Health check status for key services - Timestamp of the response
         * @summary Get application information including version and health status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infoIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infoIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.infoIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simple endpoint that returns just the version information for deployment tracking and API compatibility checks.
         * @summary Get application version information only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infoVersion(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InfoVersion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infoVersion(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.infoVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InfoApi - factory interface
 */
export const InfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfoApiFp(configuration)
    return {
        /**
         * Lightweight endpoint for health monitoring that returns only the essential health status information.
         * @summary Get only the health check status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoHealth(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.infoHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns basic application information including: - Application name and version - Health check status for key services - Timestamp of the response
         * @summary Get application information including version and health status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoIndex(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.infoIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * Simple endpoint that returns just the version information for deployment tracking and API compatibility checks.
         * @summary Get application version information only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoVersion(options?: RawAxiosRequestConfig): AxiosPromise<InfoVersion200Response> {
            return localVarFp.infoVersion(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfoApi - object-oriented interface
 */
export class InfoApi extends BaseAPI {
    /**
     * Lightweight endpoint for health monitoring that returns only the essential health status information.
     * @summary Get only the health check status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public infoHealth(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).infoHealth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns basic application information including: - Application name and version - Health check status for key services - Timestamp of the response
     * @summary Get application information including version and health status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public infoIndex(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).infoIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simple endpoint that returns just the version information for deployment tracking and API compatibility checks.
     * @summary Get application version information only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public infoVersion(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).infoVersion(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemApi - axios parameter creator
 */
export const ItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get items by type
         * @param {string} type 
         * @param {ItemByTypeTypeEnum} type2 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemByType: async (type: string, type2: ItemByTypeTypeEnum, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('itemByType', 'type', type)
            // verify required parameter 'type2' is not null or undefined
            assertParamExists('itemByType', 'type2', type2)
            const localVarPath = `/item/type/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type2 !== undefined) {
                localVarQueryParameter['type'] = type2;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get child items (items with a parent)
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemChildren: async (include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item/children`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDestroy: async (item: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemDestroy', 'item', item)
            const localVarPath = `/item/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get items for a specific tag
         * @param {string} tag The tag ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemForTag: async (tag: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('itemForTag', 'tag', tag)
            const localVarPath = `/item/for-tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get parent items (items with no parent)
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemParents: async (include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item/parents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} item The item ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemShow: async (item: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemShow', 'item', item)
            const localVarPath = `/item/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreItemRequest} storeItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemStore: async (storeItemRequest: StoreItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeItemRequest' is not null or undefined
            assertParamExists('itemStore', 'storeItemRequest', storeItemRequest)
            const localVarPath = `/item`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} item The item ID
         * @param {UpdateItemRequest} [updateItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdate: async (item: string, updateItemRequest?: UpdateItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemUpdate', 'item', item)
            const localVarPath = `/item/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} item The item ID
         * @param {UpdateItemRequest} [updateItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdate2: async (item: string, updateItemRequest?: UpdateItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemUpdate2', 'item', item)
            const localVarPath = `/item/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the tags associated with an item. This endpoint handles attaching and/or detaching tags from an item using a single operation. Designed for granular tag management, allowing callers to perform specific tag attach/detach operations without requiring a full item update
         * @param {string} item - The item to update tags for
         * @param {UpdateTagsItemRequest} [updateTagsItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdateTags: async (item: string, updateTagsItemRequest?: UpdateTagsItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemUpdateTags', 'item', item)
            const localVarPath = `/item/{item}/tags`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagsItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get items that have ALL of the specified tags (AND condition)
         * @param {WithAllTagsItemRequest} withAllTagsItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemWithAllTags: async (withAllTagsItemRequest: WithAllTagsItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withAllTagsItemRequest' is not null or undefined
            assertParamExists('itemWithAllTags', 'withAllTagsItemRequest', withAllTagsItemRequest)
            const localVarPath = `/item/with-all-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(withAllTagsItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get items that have ANY of the specified tags (OR condition)
         * @param {WithAnyTagsItemRequest} withAnyTagsItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemWithAnyTags: async (withAnyTagsItemRequest: WithAnyTagsItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withAnyTagsItemRequest' is not null or undefined
            assertParamExists('itemWithAnyTags', 'withAnyTagsItemRequest', withAnyTagsItemRequest)
            const localVarPath = `/item/with-any-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(withAnyTagsItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemApi - functional programming interface
 */
export const ItemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get items by type
         * @param {string} type 
         * @param {ItemByTypeTypeEnum} type2 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemByType(type: string, type2: ItemByTypeTypeEnum, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemForTag200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemByType(type, type2, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemByType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get child items (items with a parent)
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemChildren(include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemForTag200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemChildren(include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemChildren']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemDestroy(item: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemDestroy(item, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get items for a specific tag
         * @param {string} tag The tag ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemForTag(tag: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemForTag200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemForTag(tag, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemForTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get parent items (items with no parent)
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemParents(include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemForTag200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemParents(include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemParents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} item The item ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemShow(item: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemShow(item, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreItemRequest} storeItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemStore(storeItemRequest: StoreItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemStore(storeItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} item The item ID
         * @param {UpdateItemRequest} [updateItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemUpdate(item: string, updateItemRequest?: UpdateItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemUpdate(item, updateItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} item The item ID
         * @param {UpdateItemRequest} [updateItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemUpdate2(item: string, updateItemRequest?: UpdateItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemUpdate2(item, updateItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the tags associated with an item. This endpoint handles attaching and/or detaching tags from an item using a single operation. Designed for granular tag management, allowing callers to perform specific tag attach/detach operations without requiring a full item update
         * @param {string} item - The item to update tags for
         * @param {UpdateTagsItemRequest} [updateTagsItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemUpdateTags(item: string, updateTagsItemRequest?: UpdateTagsItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemUpdateTags(item, updateTagsItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemUpdateTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get items that have ALL of the specified tags (AND condition)
         * @param {WithAllTagsItemRequest} withAllTagsItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemWithAllTags(withAllTagsItemRequest: WithAllTagsItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemForTag200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemWithAllTags(withAllTagsItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemWithAllTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get items that have ANY of the specified tags (OR condition)
         * @param {WithAnyTagsItemRequest} withAnyTagsItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemWithAnyTags(withAnyTagsItemRequest: WithAnyTagsItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemForTag200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemWithAnyTags(withAnyTagsItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemWithAnyTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemApi - factory interface
 */
export const ItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemApiFp(configuration)
    return {
        /**
         * 
         * @summary Get items by type
         * @param {string} type 
         * @param {ItemByTypeTypeEnum} type2 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemByType(type: string, type2: ItemByTypeTypeEnum, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemForTag200Response> {
            return localVarFp.itemByType(type, type2, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get child items (items with a parent)
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemChildren(include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemForTag200Response> {
            return localVarFp.itemChildren(include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDestroy(item: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.itemDestroy(item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get items for a specific tag
         * @param {string} tag The tag ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemForTag(tag: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemForTag200Response> {
            return localVarFp.itemForTag(tag, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemIndex200Response> {
            return localVarFp.itemIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get parent items (items with no parent)
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemParents(include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemForTag200Response> {
            return localVarFp.itemParents(include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} item The item ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemShow(item: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemShow200Response> {
            return localVarFp.itemShow(item, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreItemRequest} storeItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemStore(storeItemRequest: StoreItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemShow200Response> {
            return localVarFp.itemStore(storeItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} item The item ID
         * @param {UpdateItemRequest} [updateItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdate(item: string, updateItemRequest?: UpdateItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemShow200Response> {
            return localVarFp.itemUpdate(item, updateItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} item The item ID
         * @param {UpdateItemRequest} [updateItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdate2(item: string, updateItemRequest?: UpdateItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemShow200Response> {
            return localVarFp.itemUpdate2(item, updateItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the tags associated with an item. This endpoint handles attaching and/or detaching tags from an item using a single operation. Designed for granular tag management, allowing callers to perform specific tag attach/detach operations without requiring a full item update
         * @param {string} item - The item to update tags for
         * @param {UpdateTagsItemRequest} [updateTagsItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdateTags(item: string, updateTagsItemRequest?: UpdateTagsItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemShow200Response> {
            return localVarFp.itemUpdateTags(item, updateTagsItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get items that have ALL of the specified tags (AND condition)
         * @param {WithAllTagsItemRequest} withAllTagsItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemWithAllTags(withAllTagsItemRequest: WithAllTagsItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemForTag200Response> {
            return localVarFp.itemWithAllTags(withAllTagsItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get items that have ANY of the specified tags (OR condition)
         * @param {WithAnyTagsItemRequest} withAnyTagsItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemWithAnyTags(withAnyTagsItemRequest: WithAnyTagsItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemForTag200Response> {
            return localVarFp.itemWithAnyTags(withAnyTagsItemRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemApi - object-oriented interface
 */
export class ItemApi extends BaseAPI {
    /**
     * 
     * @summary Get items by type
     * @param {string} type 
     * @param {ItemByTypeTypeEnum} type2 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemByType(type: string, type2: ItemByTypeTypeEnum, include?: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemByType(type, type2, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get child items (items with a parent)
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemChildren(include?: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemChildren(include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} item The item ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemDestroy(item: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemDestroy(item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get items for a specific tag
     * @param {string} tag The tag ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemForTag(tag: string, include?: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemForTag(tag, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get parent items (items with no parent)
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemParents(include?: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemParents(include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} item The item ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemShow(item: string, include?: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemShow(item, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreItemRequest} storeItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemStore(storeItemRequest: StoreItemRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemStore(storeItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} item The item ID
     * @param {UpdateItemRequest} [updateItemRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemUpdate(item: string, updateItemRequest?: UpdateItemRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemUpdate(item, updateItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} item The item ID
     * @param {UpdateItemRequest} [updateItemRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemUpdate2(item: string, updateItemRequest?: UpdateItemRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemUpdate2(item, updateItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the tags associated with an item. This endpoint handles attaching and/or detaching tags from an item using a single operation. Designed for granular tag management, allowing callers to perform specific tag attach/detach operations without requiring a full item update
     * @param {string} item - The item to update tags for
     * @param {UpdateTagsItemRequest} [updateTagsItemRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemUpdateTags(item: string, updateTagsItemRequest?: UpdateTagsItemRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemUpdateTags(item, updateTagsItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get items that have ALL of the specified tags (AND condition)
     * @param {WithAllTagsItemRequest} withAllTagsItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemWithAllTags(withAllTagsItemRequest: WithAllTagsItemRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemWithAllTags(withAllTagsItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get items that have ANY of the specified tags (OR condition)
     * @param {WithAnyTagsItemRequest} withAnyTagsItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemWithAnyTags(withAnyTagsItemRequest: WithAnyTagsItemRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemWithAnyTags(withAnyTagsItemRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ItemByTypeTypeEnum = {
    Object: 'object',
    Monument: 'monument',
    Detail: 'detail',
    Picture: 'picture'
} as const;
export type ItemByTypeTypeEnum = typeof ItemByTypeTypeEnum[keyof typeof ItemByTypeTypeEnum];


/**
 * ItemImageApi - axios parameter creator
 */
export const ItemImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Attach an available image to an item
         * @param {string} item The item ID
         * @param {AttachFromAvailableItemImageRequest} attachFromAvailableItemImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemAttachImage: async (item: string, attachFromAvailableItemImageRequest: AttachFromAvailableItemImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemAttachImage', 'item', item)
            // verify required parameter 'attachFromAvailableItemImageRequest' is not null or undefined
            assertParamExists('itemAttachImage', 'attachFromAvailableItemImageRequest', attachFromAvailableItemImageRequest)
            const localVarPath = `/item/{item}/attach-image`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachFromAvailableItemImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified item image
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageDestroy: async (itemImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageDestroy', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach an item image and convert it back to available image
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageDetach: async (itemImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageDetach', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}/detach`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageDownload: async (itemImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageDownload', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}/download`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move item image down in display order
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageMoveDown: async (itemImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageMoveDown', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}/move-down`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move item image up in display order
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageMoveUp: async (itemImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageMoveUp', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}/move-up`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified item image
         * @param {string} itemImage The item image ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageShow: async (itemImage: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageShow', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tighten ordering for all images of the item
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageTightenOrdering: async (itemImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageTightenOrdering', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}/tighten-ordering`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified item image
         * @param {string} itemImage The item image ID
         * @param {UpdateItemImageRequest} [updateItemImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageUpdate: async (itemImage: string, updateItemImageRequest?: UpdateItemImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageUpdate', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateItemImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified item image
         * @param {string} itemImage The item image ID
         * @param {UpdateItemImageRequest} [updateItemImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageUpdate2: async (itemImage: string, updateItemImageRequest?: UpdateItemImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageUpdate2', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateItemImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageView: async (itemImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageView', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}/view`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of item images for a specific item
         * @param {string} item The item ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImagesIndex: async (item: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemImagesIndex', 'item', item)
            const localVarPath = `/item/{item}/images`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created item image
         * @param {string} item The item ID
         * @param {StoreItemImageRequest} storeItemImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImagesStore: async (item: string, storeItemImageRequest: StoreItemImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemImagesStore', 'item', item)
            // verify required parameter 'storeItemImageRequest' is not null or undefined
            assertParamExists('itemImagesStore', 'storeItemImageRequest', storeItemImageRequest)
            const localVarPath = `/item/{item}/images`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeItemImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemImageApi - functional programming interface
 */
export const ItemImageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemImageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Attach an available image to an item
         * @param {string} item The item ID
         * @param {AttachFromAvailableItemImageRequest} attachFromAvailableItemImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemAttachImage(item: string, attachFromAvailableItemImageRequest: AttachFromAvailableItemImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemAttachImage(item, attachFromAvailableItemImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemAttachImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified item image
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageDestroy(itemImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageDestroy(itemImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Detach an item image and convert it back to available image
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageDetach(itemImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionAttachItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageDetach(itemImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageDetach']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageDownload(itemImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageDownload(itemImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageDownload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move item image down in display order
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageMoveDown(itemImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageMoveDown(itemImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageMoveDown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move item image up in display order
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageMoveUp(itemImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageMoveUp(itemImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageMoveUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified item image
         * @param {string} itemImage The item image ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageShow(itemImage: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageShow(itemImage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tighten ordering for all images of the item
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageTightenOrdering(itemImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionAttachItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageTightenOrdering(itemImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageTightenOrdering']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified item image
         * @param {string} itemImage The item image ID
         * @param {UpdateItemImageRequest} [updateItemImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageUpdate(itemImage: string, updateItemImageRequest?: UpdateItemImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageUpdate(itemImage, updateItemImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified item image
         * @param {string} itemImage The item image ID
         * @param {UpdateItemImageRequest} [updateItemImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageUpdate2(itemImage: string, updateItemImageRequest?: UpdateItemImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageUpdate2(itemImage, updateItemImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageView(itemImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageView(itemImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of item images for a specific item
         * @param {string} item The item ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImagesIndex(item: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImagesIndex(item, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImagesIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created item image
         * @param {string} item The item ID
         * @param {StoreItemImageRequest} storeItemImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImagesStore(item: string, storeItemImageRequest: StoreItemImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImagesStore(item, storeItemImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImagesStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemImageApi - factory interface
 */
export const ItemImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemImageApiFp(configuration)
    return {
        /**
         * 
         * @summary Attach an available image to an item
         * @param {string} item The item ID
         * @param {AttachFromAvailableItemImageRequest} attachFromAvailableItemImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemAttachImage(item: string, attachFromAvailableItemImageRequest: AttachFromAvailableItemImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesStore200Response> {
            return localVarFp.itemAttachImage(item, attachFromAvailableItemImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified item image
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageDestroy(itemImage: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.itemImageDestroy(itemImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detach an item image and convert it back to available image
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageDetach(itemImage: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionAttachItem200Response> {
            return localVarFp.itemImageDetach(itemImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageDownload(itemImage: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.itemImageDownload(itemImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move item image down in display order
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageMoveDown(itemImage: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesStore200Response> {
            return localVarFp.itemImageMoveDown(itemImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move item image up in display order
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageMoveUp(itemImage: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesStore200Response> {
            return localVarFp.itemImageMoveUp(itemImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified item image
         * @param {string} itemImage The item image ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageShow(itemImage: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesStore200Response> {
            return localVarFp.itemImageShow(itemImage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Tighten ordering for all images of the item
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageTightenOrdering(itemImage: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionAttachItem200Response> {
            return localVarFp.itemImageTightenOrdering(itemImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified item image
         * @param {string} itemImage The item image ID
         * @param {UpdateItemImageRequest} [updateItemImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageUpdate(itemImage: string, updateItemImageRequest?: UpdateItemImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesStore200Response> {
            return localVarFp.itemImageUpdate(itemImage, updateItemImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified item image
         * @param {string} itemImage The item image ID
         * @param {UpdateItemImageRequest} [updateItemImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageUpdate2(itemImage: string, updateItemImageRequest?: UpdateItemImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesStore200Response> {
            return localVarFp.itemImageUpdate2(itemImage, updateItemImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageView(itemImage: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.itemImageView(itemImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of item images for a specific item
         * @param {string} item The item ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImagesIndex(item: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesIndex200Response> {
            return localVarFp.itemImagesIndex(item, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created item image
         * @param {string} item The item ID
         * @param {StoreItemImageRequest} storeItemImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImagesStore(item: string, storeItemImageRequest: StoreItemImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesStore200Response> {
            return localVarFp.itemImagesStore(item, storeItemImageRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemImageApi - object-oriented interface
 */
export class ItemImageApi extends BaseAPI {
    /**
     * 
     * @summary Attach an available image to an item
     * @param {string} item The item ID
     * @param {AttachFromAvailableItemImageRequest} attachFromAvailableItemImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemAttachImage(item: string, attachFromAvailableItemImageRequest: AttachFromAvailableItemImageRequest, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemAttachImage(item, attachFromAvailableItemImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified item image
     * @param {string} itemImage The item image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImageDestroy(itemImage: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageDestroy(itemImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detach an item image and convert it back to available image
     * @param {string} itemImage The item image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImageDetach(itemImage: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageDetach(itemImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the file to the caller
     * @param {string} itemImage The item image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImageDownload(itemImage: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageDownload(itemImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move item image down in display order
     * @param {string} itemImage The item image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImageMoveDown(itemImage: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageMoveDown(itemImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move item image up in display order
     * @param {string} itemImage The item image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImageMoveUp(itemImage: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageMoveUp(itemImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified item image
     * @param {string} itemImage The item image ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImageShow(itemImage: string, include?: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageShow(itemImage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Tighten ordering for all images of the item
     * @param {string} itemImage The item image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImageTightenOrdering(itemImage: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageTightenOrdering(itemImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified item image
     * @param {string} itemImage The item image ID
     * @param {UpdateItemImageRequest} [updateItemImageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImageUpdate(itemImage: string, updateItemImageRequest?: UpdateItemImageRequest, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageUpdate(itemImage, updateItemImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified item image
     * @param {string} itemImage The item image ID
     * @param {UpdateItemImageRequest} [updateItemImageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImageUpdate2(itemImage: string, updateItemImageRequest?: UpdateItemImageRequest, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageUpdate2(itemImage, updateItemImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
     * @param {string} itemImage The item image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImageView(itemImage: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageView(itemImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of item images for a specific item
     * @param {string} item The item ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImagesIndex(item: string, include?: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImagesIndex(item, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created item image
     * @param {string} item The item ID
     * @param {StoreItemImageRequest} storeItemImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImagesStore(item: string, storeItemImageRequest: StoreItemImageRequest, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImagesStore(item, storeItemImageRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemTranslationApi - axios parameter creator
 */
export const ItemTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationDestroy: async (itemTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationDestroy', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [itemId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationIndex: async (page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (itemId !== undefined) {
                localVarQueryParameter['item_id'] = itemId;
            }

            if (languageId !== undefined) {
                localVarQueryParameter['language_id'] = languageId;
            }

            if (contextId !== undefined) {
                localVarQueryParameter['context_id'] = contextId;
            }

            if (defaultContext !== undefined) {
                localVarQueryParameter['default_context'] = defaultContext;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationShow: async (itemTranslation: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationShow', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {StoreItemTranslationRequest} storeItemTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationStore: async (storeItemTranslationRequest: StoreItemTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeItemTranslationRequest' is not null or undefined
            assertParamExists('itemTranslationStore', 'storeItemTranslationRequest', storeItemTranslationRequest)
            const localVarPath = `/item-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeItemTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate: async (itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationUpdate', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateItemTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate2: async (itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationUpdate2', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateItemTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemTranslationApi - functional programming interface
 */
export const ItemTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationDestroy(itemTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [itemId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationIndex(page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationIndex(page, perPage, itemId, languageId, contextId, defaultContext, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationShow(itemTranslation: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationShow(itemTranslation, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {StoreItemTranslationRequest} storeItemTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationStore(storeItemTranslationRequest: StoreItemTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationStore(storeItemTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationUpdate(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationUpdate(itemTranslation, updateItemTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationUpdate2(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationUpdate2(itemTranslation, updateItemTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemTranslationApi - factory interface
 */
export const ItemTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.itemTranslationDestroy(itemTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [itemId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationIndex(page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationIndex200Response> {
            return localVarFp.itemTranslationIndex(page, perPage, itemId, languageId, contextId, defaultContext, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationShow(itemTranslation: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationShow(itemTranslation, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {StoreItemTranslationRequest} storeItemTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationStore(storeItemTranslationRequest: StoreItemTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationStore(storeItemTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationUpdate(itemTranslation, updateItemTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate2(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationUpdate2(itemTranslation, updateItemTranslationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemTranslationApi - object-oriented interface
 */
export class ItemTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationDestroy(itemTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of item translations
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [itemId] 
     * @param {string} [languageId] 
     * @param {string} [contextId] 
     * @param {boolean} [defaultContext] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationIndex(page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationIndex(page, perPage, itemId, languageId, contextId, defaultContext, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationShow(itemTranslation: string, include?: string, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationShow(itemTranslation, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created item translation
     * @param {StoreItemTranslationRequest} storeItemTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationStore(storeItemTranslationRequest: StoreItemTranslationRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationStore(storeItemTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationUpdate(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationUpdate(itemTranslation, updateItemTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationUpdate2(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationUpdate2(itemTranslation, updateItemTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemTranslationsApi - axios parameter creator
 */
export const ItemTranslationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationDestroy: async (itemTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationDestroy', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [itemId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationIndex: async (page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (itemId !== undefined) {
                localVarQueryParameter['item_id'] = itemId;
            }

            if (languageId !== undefined) {
                localVarQueryParameter['language_id'] = languageId;
            }

            if (contextId !== undefined) {
                localVarQueryParameter['context_id'] = contextId;
            }

            if (defaultContext !== undefined) {
                localVarQueryParameter['default_context'] = defaultContext;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationShow: async (itemTranslation: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationShow', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {StoreItemTranslationRequest} storeItemTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationStore: async (storeItemTranslationRequest: StoreItemTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeItemTranslationRequest' is not null or undefined
            assertParamExists('itemTranslationStore', 'storeItemTranslationRequest', storeItemTranslationRequest)
            const localVarPath = `/item-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeItemTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate: async (itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationUpdate', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateItemTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate2: async (itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationUpdate2', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateItemTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemTranslationsApi - functional programming interface
 */
export const ItemTranslationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemTranslationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationDestroy(itemTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [itemId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationIndex(page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationIndex(page, perPage, itemId, languageId, contextId, defaultContext, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationShow(itemTranslation: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationShow(itemTranslation, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {StoreItemTranslationRequest} storeItemTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationStore(storeItemTranslationRequest: StoreItemTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationStore(storeItemTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationUpdate(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationUpdate(itemTranslation, updateItemTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationUpdate2(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationUpdate2(itemTranslation, updateItemTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemTranslationsApi - factory interface
 */
export const ItemTranslationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemTranslationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.itemTranslationDestroy(itemTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [itemId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationIndex(page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationIndex200Response> {
            return localVarFp.itemTranslationIndex(page, perPage, itemId, languageId, contextId, defaultContext, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationShow(itemTranslation: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationShow(itemTranslation, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {StoreItemTranslationRequest} storeItemTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationStore(storeItemTranslationRequest: StoreItemTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationStore(storeItemTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationUpdate(itemTranslation, updateItemTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate2(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationUpdate2(itemTranslation, updateItemTranslationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemTranslationsApi - object-oriented interface
 */
export class ItemTranslationsApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationDestroy(itemTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of item translations
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [itemId] 
     * @param {string} [languageId] 
     * @param {string} [contextId] 
     * @param {boolean} [defaultContext] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationIndex(page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationIndex(page, perPage, itemId, languageId, contextId, defaultContext, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationShow(itemTranslation: string, include?: string, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationShow(itemTranslation, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created item translation
     * @param {StoreItemTranslationRequest} storeItemTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationStore(storeItemTranslationRequest: StoreItemTranslationRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationStore(storeItemTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationUpdate(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationUpdate(itemTranslation, updateItemTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationUpdate2(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationUpdate2(itemTranslation, updateItemTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LanguageApi - axios parameter creator
 */
export const LanguageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clear the default flag from any language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageClearDefault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/language/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageDestroy: async (language: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('languageDestroy', 'language', language)
            const localVarPath = `/language/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the default Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageGetDefault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/language/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the english Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageGetEnglish: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/language/english`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageIndex: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/language`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set or unset a Language as the default one
         * @param {string} language The language ID
         * @param {SetDefaultLanguageRequest} setDefaultLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageSetDefault: async (language: string, setDefaultLanguageRequest: SetDefaultLanguageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('languageSetDefault', 'language', language)
            // verify required parameter 'setDefaultLanguageRequest' is not null or undefined
            assertParamExists('languageSetDefault', 'setDefaultLanguageRequest', setDefaultLanguageRequest)
            const localVarPath = `/language/{language}/default`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setDefaultLanguageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageShow: async (language: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('languageShow', 'language', language)
            const localVarPath = `/language/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreLanguageRequest} storeLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageStore: async (storeLanguageRequest: StoreLanguageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeLanguageRequest' is not null or undefined
            assertParamExists('languageStore', 'storeLanguageRequest', storeLanguageRequest)
            const localVarPath = `/language`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeLanguageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} language The language ID
         * @param {UpdateLanguageRequest} updateLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageUpdate: async (language: string, updateLanguageRequest: UpdateLanguageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('languageUpdate', 'language', language)
            // verify required parameter 'updateLanguageRequest' is not null or undefined
            assertParamExists('languageUpdate', 'updateLanguageRequest', updateLanguageRequest)
            const localVarPath = `/language/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLanguageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} language The language ID
         * @param {UpdateLanguageRequest} updateLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageUpdate2: async (language: string, updateLanguageRequest: UpdateLanguageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('languageUpdate2', 'language', language)
            // verify required parameter 'updateLanguageRequest' is not null or undefined
            assertParamExists('languageUpdate2', 'updateLanguageRequest', updateLanguageRequest)
            const localVarPath = `/language/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLanguageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LanguageApi - functional programming interface
 */
export const LanguageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LanguageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Clear the default flag from any language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageClearDefault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextClearDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageClearDefault(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageClearDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageDestroy(language: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageDestroy(language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the default Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageGetDefault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageGetDefault(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageGetDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the english Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageGetEnglish(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageGetEnglish(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageGetEnglish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageIndex(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageIndex(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set or unset a Language as the default one
         * @param {string} language The language ID
         * @param {SetDefaultLanguageRequest} setDefaultLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageSetDefault(language: string, setDefaultLanguageRequest: SetDefaultLanguageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageSetDefault(language, setDefaultLanguageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageSetDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageShow(language: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageShow(language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreLanguageRequest} storeLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageStore(storeLanguageRequest: StoreLanguageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageStore(storeLanguageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} language The language ID
         * @param {UpdateLanguageRequest} updateLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageUpdate(language: string, updateLanguageRequest: UpdateLanguageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageUpdate(language, updateLanguageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} language The language ID
         * @param {UpdateLanguageRequest} updateLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageUpdate2(language: string, updateLanguageRequest: UpdateLanguageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageUpdate2(language, updateLanguageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LanguageApi - factory interface
 */
export const LanguageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LanguageApiFp(configuration)
    return {
        /**
         * 
         * @summary Clear the default flag from any language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageClearDefault(options?: RawAxiosRequestConfig): AxiosPromise<ContextClearDefault200Response> {
            return localVarFp.languageClearDefault(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageDestroy(language: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.languageDestroy(language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the default Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageGetDefault(options?: RawAxiosRequestConfig): AxiosPromise<LanguageGetDefault200Response> {
            return localVarFp.languageGetDefault(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the english Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageGetEnglish(options?: RawAxiosRequestConfig): AxiosPromise<LanguageGetDefault200Response> {
            return localVarFp.languageGetEnglish(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageIndex(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<LanguageIndex200Response> {
            return localVarFp.languageIndex(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set or unset a Language as the default one
         * @param {string} language The language ID
         * @param {SetDefaultLanguageRequest} setDefaultLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageSetDefault(language: string, setDefaultLanguageRequest: SetDefaultLanguageRequest, options?: RawAxiosRequestConfig): AxiosPromise<LanguageGetDefault200Response> {
            return localVarFp.languageSetDefault(language, setDefaultLanguageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageShow(language: string, options?: RawAxiosRequestConfig): AxiosPromise<LanguageGetDefault200Response> {
            return localVarFp.languageShow(language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreLanguageRequest} storeLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageStore(storeLanguageRequest: StoreLanguageRequest, options?: RawAxiosRequestConfig): AxiosPromise<LanguageGetDefault200Response> {
            return localVarFp.languageStore(storeLanguageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} language The language ID
         * @param {UpdateLanguageRequest} updateLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageUpdate(language: string, updateLanguageRequest: UpdateLanguageRequest, options?: RawAxiosRequestConfig): AxiosPromise<LanguageGetDefault200Response> {
            return localVarFp.languageUpdate(language, updateLanguageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} language The language ID
         * @param {UpdateLanguageRequest} updateLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageUpdate2(language: string, updateLanguageRequest: UpdateLanguageRequest, options?: RawAxiosRequestConfig): AxiosPromise<LanguageGetDefault200Response> {
            return localVarFp.languageUpdate2(language, updateLanguageRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LanguageApi - object-oriented interface
 */
export class LanguageApi extends BaseAPI {
    /**
     * 
     * @summary Clear the default flag from any language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageClearDefault(options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageClearDefault(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} language The language ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageDestroy(language: string, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageDestroy(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the default Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageGetDefault(options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageGetDefault(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the english Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageGetEnglish(options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageGetEnglish(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageIndex(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageIndex(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set or unset a Language as the default one
     * @param {string} language The language ID
     * @param {SetDefaultLanguageRequest} setDefaultLanguageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageSetDefault(language: string, setDefaultLanguageRequest: SetDefaultLanguageRequest, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageSetDefault(language, setDefaultLanguageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} language The language ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageShow(language: string, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageShow(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreLanguageRequest} storeLanguageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageStore(storeLanguageRequest: StoreLanguageRequest, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageStore(storeLanguageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} language The language ID
     * @param {UpdateLanguageRequest} updateLanguageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageUpdate(language: string, updateLanguageRequest: UpdateLanguageRequest, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageUpdate(language, updateLanguageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} language The language ID
     * @param {UpdateLanguageRequest} updateLanguageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageUpdate2(language: string, updateLanguageRequest: UpdateLanguageRequest, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageUpdate2(language, updateLanguageRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationApi - axios parameter creator
 */
export const LocationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified location
         * @param {string} location The location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationDestroy: async (location: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('locationDestroy', 'location', location)
            const localVarPath = `/location/{location}`
                .replace(`{${"location"}}`, encodeURIComponent(String(location)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of locations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified location
         * @param {string} location The location ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationShow: async (location: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('locationShow', 'location', location)
            const localVarPath = `/location/{location}`
                .replace(`{${"location"}}`, encodeURIComponent(String(location)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created location
         * @param {StoreLocationRequest} storeLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationStore: async (storeLocationRequest: StoreLocationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeLocationRequest' is not null or undefined
            assertParamExists('locationStore', 'storeLocationRequest', storeLocationRequest)
            const localVarPath = `/location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified location
         * @param {string} location The location ID
         * @param {UpdateLocationRequest} updateLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationUpdate: async (location: string, updateLocationRequest: UpdateLocationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('locationUpdate', 'location', location)
            // verify required parameter 'updateLocationRequest' is not null or undefined
            assertParamExists('locationUpdate', 'updateLocationRequest', updateLocationRequest)
            const localVarPath = `/location/{location}`
                .replace(`{${"location"}}`, encodeURIComponent(String(location)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified location
         * @param {string} location The location ID
         * @param {UpdateLocationRequest} updateLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationUpdate2: async (location: string, updateLocationRequest: UpdateLocationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('locationUpdate2', 'location', location)
            // verify required parameter 'updateLocationRequest' is not null or undefined
            assertParamExists('locationUpdate2', 'updateLocationRequest', updateLocationRequest)
            const localVarPath = `/location/{location}`
                .replace(`{${"location"}}`, encodeURIComponent(String(location)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationApi - functional programming interface
 */
export const LocationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified location
         * @param {string} location The location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationDestroy(location: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationDestroy(location, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of locations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified location
         * @param {string} location The location ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationShow(location: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationShow(location, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created location
         * @param {StoreLocationRequest} storeLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationStore(storeLocationRequest: StoreLocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationStore(storeLocationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified location
         * @param {string} location The location ID
         * @param {UpdateLocationRequest} updateLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationUpdate(location: string, updateLocationRequest: UpdateLocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationUpdate(location, updateLocationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified location
         * @param {string} location The location ID
         * @param {UpdateLocationRequest} updateLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationUpdate2(location: string, updateLocationRequest: UpdateLocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationUpdate2(location, updateLocationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationApi - factory interface
 */
export const LocationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified location
         * @param {string} location The location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationDestroy(location: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.locationDestroy(location, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of locations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<LocationIndex200Response> {
            return localVarFp.locationIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified location
         * @param {string} location The location ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationShow(location: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<LocationShow200Response> {
            return localVarFp.locationShow(location, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created location
         * @param {StoreLocationRequest} storeLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationStore(storeLocationRequest: StoreLocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationShow200Response> {
            return localVarFp.locationStore(storeLocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified location
         * @param {string} location The location ID
         * @param {UpdateLocationRequest} updateLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationUpdate(location: string, updateLocationRequest: UpdateLocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationShow200Response> {
            return localVarFp.locationUpdate(location, updateLocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified location
         * @param {string} location The location ID
         * @param {UpdateLocationRequest} updateLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationUpdate2(location: string, updateLocationRequest: UpdateLocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationShow200Response> {
            return localVarFp.locationUpdate2(location, updateLocationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationApi - object-oriented interface
 */
export class LocationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified location
     * @param {string} location The location ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationDestroy(location: string, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationDestroy(location, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of locations
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified location
     * @param {string} location The location ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationShow(location: string, include?: string, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationShow(location, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created location
     * @param {StoreLocationRequest} storeLocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationStore(storeLocationRequest: StoreLocationRequest, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationStore(storeLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified location
     * @param {string} location The location ID
     * @param {UpdateLocationRequest} updateLocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationUpdate(location: string, updateLocationRequest: UpdateLocationRequest, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationUpdate(location, updateLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified location
     * @param {string} location The location ID
     * @param {UpdateLocationRequest} updateLocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationUpdate2(location: string, updateLocationRequest: UpdateLocationRequest, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationUpdate2(location, updateLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationTranslationApi - axios parameter creator
 */
export const LocationTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationDestroy: async (locationTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationTranslation' is not null or undefined
            assertParamExists('locationTranslationDestroy', 'locationTranslation', locationTranslation)
            const localVarPath = `/location-translation/{locationTranslation}`
                .replace(`{${"locationTranslation"}}`, encodeURIComponent(String(locationTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/location-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationShow: async (locationTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationTranslation' is not null or undefined
            assertParamExists('locationTranslationShow', 'locationTranslation', locationTranslation)
            const localVarPath = `/location-translation/{locationTranslation}`
                .replace(`{${"locationTranslation"}}`, encodeURIComponent(String(locationTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreLocationTranslationRequest} storeLocationTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationStore: async (storeLocationTranslationRequest: StoreLocationTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeLocationTranslationRequest' is not null or undefined
            assertParamExists('locationTranslationStore', 'storeLocationTranslationRequest', storeLocationTranslationRequest)
            const localVarPath = `/location-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeLocationTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} locationTranslation The location translation ID
         * @param {UpdateLocationTranslationRequest} [updateLocationTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationUpdate: async (locationTranslation: string, updateLocationTranslationRequest?: UpdateLocationTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationTranslation' is not null or undefined
            assertParamExists('locationTranslationUpdate', 'locationTranslation', locationTranslation)
            const localVarPath = `/location-translation/{locationTranslation}`
                .replace(`{${"locationTranslation"}}`, encodeURIComponent(String(locationTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLocationTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} locationTranslation The location translation ID
         * @param {UpdateLocationTranslationRequest} [updateLocationTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationUpdate2: async (locationTranslation: string, updateLocationTranslationRequest?: UpdateLocationTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationTranslation' is not null or undefined
            assertParamExists('locationTranslationUpdate2', 'locationTranslation', locationTranslation)
            const localVarPath = `/location-translation/{locationTranslation}`
                .replace(`{${"locationTranslation"}}`, encodeURIComponent(String(locationTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLocationTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationTranslationApi - functional programming interface
 */
export const LocationTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationDestroy(locationTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationDestroy(locationTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationShow(locationTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationShow(locationTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreLocationTranslationRequest} storeLocationTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationStore(storeLocationTranslationRequest: StoreLocationTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationStore(storeLocationTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} locationTranslation The location translation ID
         * @param {UpdateLocationTranslationRequest} [updateLocationTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationUpdate(locationTranslation: string, updateLocationTranslationRequest?: UpdateLocationTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationUpdate(locationTranslation, updateLocationTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} locationTranslation The location translation ID
         * @param {UpdateLocationTranslationRequest} [updateLocationTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationUpdate2(locationTranslation: string, updateLocationTranslationRequest?: UpdateLocationTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationUpdate2(locationTranslation, updateLocationTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationTranslationApi - factory interface
 */
export const LocationTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationDestroy(locationTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.locationTranslationDestroy(locationTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<LocationTranslationIndex200Response> {
            return localVarFp.locationTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationShow(locationTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<LocationTranslationShow200Response> {
            return localVarFp.locationTranslationShow(locationTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreLocationTranslationRequest} storeLocationTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationStore(storeLocationTranslationRequest: StoreLocationTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationTranslationShow200Response> {
            return localVarFp.locationTranslationStore(storeLocationTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} locationTranslation The location translation ID
         * @param {UpdateLocationTranslationRequest} [updateLocationTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationUpdate(locationTranslation: string, updateLocationTranslationRequest?: UpdateLocationTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationTranslationShow200Response> {
            return localVarFp.locationTranslationUpdate(locationTranslation, updateLocationTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} locationTranslation The location translation ID
         * @param {UpdateLocationTranslationRequest} [updateLocationTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationUpdate2(locationTranslation: string, updateLocationTranslationRequest?: UpdateLocationTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationTranslationShow200Response> {
            return localVarFp.locationTranslationUpdate2(locationTranslation, updateLocationTranslationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationTranslationApi - object-oriented interface
 */
export class LocationTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} locationTranslation The location translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationTranslationDestroy(locationTranslation: string, options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationDestroy(locationTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationTranslationIndex(options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} locationTranslation The location translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationTranslationShow(locationTranslation: string, options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationShow(locationTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreLocationTranslationRequest} storeLocationTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationTranslationStore(storeLocationTranslationRequest: StoreLocationTranslationRequest, options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationStore(storeLocationTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} locationTranslation The location translation ID
     * @param {UpdateLocationTranslationRequest} [updateLocationTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationTranslationUpdate(locationTranslation: string, updateLocationTranslationRequest?: UpdateLocationTranslationRequest, options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationUpdate(locationTranslation, updateLocationTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} locationTranslation The location translation ID
     * @param {UpdateLocationTranslationRequest} [updateLocationTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationTranslationUpdate2(locationTranslation: string, updateLocationTranslationRequest?: UpdateLocationTranslationRequest, options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationUpdate2(locationTranslation, updateLocationTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MarkdownApi - axios parameter creator
 */
export const MarkdownApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownAllowedElements: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markdown/allowed-elements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownFromHtml: async (markdownFromHtmlRequest: MarkdownFromHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownFromHtmlRequest' is not null or undefined
            assertParamExists('markdownFromHtml', 'markdownFromHtmlRequest', markdownFromHtmlRequest)
            const localVarPath = `/markdown/from-html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownFromHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownIsMarkdown: async (markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownIsMarkdownRequest' is not null or undefined
            assertParamExists('markdownIsMarkdown', 'markdownIsMarkdownRequest', markdownIsMarkdownRequest)
            const localVarPath = `/markdown/is-markdown`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownIsMarkdownRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownPreview: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markdown/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownToHtml: async (markdownToHtmlRequest: MarkdownToHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownToHtmlRequest' is not null or undefined
            assertParamExists('markdownToHtml', 'markdownToHtmlRequest', markdownToHtmlRequest)
            const localVarPath = `/markdown/to-html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownToHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownValidate: async (markdownToHtmlRequest: MarkdownToHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownToHtmlRequest' is not null or undefined
            assertParamExists('markdownValidate', 'markdownToHtmlRequest', markdownToHtmlRequest)
            const localVarPath = `/markdown/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownToHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarkdownApi - functional programming interface
 */
export const MarkdownApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarkdownApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownAllowedElements(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownAllowedElements(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownAllowedElements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownFromHtml(markdownFromHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownFromHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownIsMarkdown(markdownIsMarkdownRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownIsMarkdown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownPreview(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownPreview(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownPreview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownToHtml(markdownToHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownToHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownValidate(markdownToHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownValidate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MarkdownApi - factory interface
 */
export const MarkdownApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarkdownApiFp(configuration)
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownAllowedElements(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownAllowedElements(options).then((request) => request(axios, basePath));
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownFromHtml(markdownFromHtmlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownIsMarkdown(markdownIsMarkdownRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownPreview(options?: RawAxiosRequestConfig): AxiosPromise<ConversionResource> {
            return localVarFp.markdownPreview(options).then((request) => request(axios, basePath));
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownToHtml(markdownToHtmlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownValidate(markdownToHtmlRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarkdownApi - object-oriented interface
 */
export class MarkdownApi extends BaseAPI {
    /**
     * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
     * @summary Get allowed HTML tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownAllowedElements(options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownAllowedElements(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
     * @summary Convert HTML to Markdown
     * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownFromHtml(markdownFromHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
     * @summary Check if content is Markdown
     * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownIsMarkdown(markdownIsMarkdownRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
     * @summary Preview Markdown content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownPreview(options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownPreview(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
     * @summary Convert Markdown to HTML
     * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownToHtml(markdownToHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates Markdown content without converting it, useful for form validation.
     * @summary Validate Markdown content
     * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownValidate(markdownToHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi - axios parameter creator
 */
export const MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownAllowedElements: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markdown/allowed-elements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownFromHtml: async (markdownFromHtmlRequest: MarkdownFromHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownFromHtmlRequest' is not null or undefined
            assertParamExists('markdownFromHtml', 'markdownFromHtmlRequest', markdownFromHtmlRequest)
            const localVarPath = `/markdown/from-html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownFromHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownIsMarkdown: async (markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownIsMarkdownRequest' is not null or undefined
            assertParamExists('markdownIsMarkdown', 'markdownIsMarkdownRequest', markdownIsMarkdownRequest)
            const localVarPath = `/markdown/is-markdown`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownIsMarkdownRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownPreview: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markdown/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownToHtml: async (markdownToHtmlRequest: MarkdownToHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownToHtmlRequest' is not null or undefined
            assertParamExists('markdownToHtml', 'markdownToHtmlRequest', markdownToHtmlRequest)
            const localVarPath = `/markdown/to-html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownToHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownValidate: async (markdownToHtmlRequest: MarkdownToHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownToHtmlRequest' is not null or undefined
            assertParamExists('markdownValidate', 'markdownToHtmlRequest', markdownToHtmlRequest)
            const localVarPath = `/markdown/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownToHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi - functional programming interface
 */
export const MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownAllowedElements(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownAllowedElements(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownAllowedElements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownFromHtml(markdownFromHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownFromHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownIsMarkdown(markdownIsMarkdownRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownIsMarkdown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownPreview(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownPreview(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownPreview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownToHtml(markdownToHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownToHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownValidate(markdownToHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownValidate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi - factory interface
 */
export const MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(configuration)
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownAllowedElements(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownAllowedElements(options).then((request) => request(axios, basePath));
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownFromHtml(markdownFromHtmlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownIsMarkdown(markdownIsMarkdownRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownPreview(options?: RawAxiosRequestConfig): AxiosPromise<ConversionResource> {
            return localVarFp.markdownPreview(options).then((request) => request(axios, basePath));
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownToHtml(markdownToHtmlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownValidate(markdownToHtmlRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi - object-oriented interface
 */
export class MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi extends BaseAPI {
    /**
     * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
     * @summary Get allowed HTML tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownAllowedElements(options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownAllowedElements(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
     * @summary Convert HTML to Markdown
     * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownFromHtml(markdownFromHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
     * @summary Check if content is Markdown
     * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownIsMarkdown(markdownIsMarkdownRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
     * @summary Preview Markdown content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownPreview(options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownPreview(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
     * @summary Convert Markdown to HTML
     * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownToHtml(markdownToHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates Markdown content without converting it, useful for form validation.
     * @summary Validate Markdown content
     * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownValidate(markdownToHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MobileAppAuthenticationApi - axios parameter creator
 */
export const MobileAppAuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Acquire a token for the user
         * @param {AcquireTokenMobileAppAuthenticationRequest} acquireTokenMobileAppAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenAcquire: async (acquireTokenMobileAppAuthenticationRequest: AcquireTokenMobileAppAuthenticationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acquireTokenMobileAppAuthenticationRequest' is not null or undefined
            assertParamExists('tokenAcquire', 'acquireTokenMobileAppAuthenticationRequest', acquireTokenMobileAppAuthenticationRequest)
            const localVarPath = `/mobile/acquire-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(acquireTokenMobileAppAuthenticationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request an email 2FA code for mobile authentication
         * @param {RequestEmailCodeMobileAppAuthenticationRequest} requestEmailCodeMobileAppAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenRequestEmailCode: async (requestEmailCodeMobileAppAuthenticationRequest: RequestEmailCodeMobileAppAuthenticationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestEmailCodeMobileAppAuthenticationRequest' is not null or undefined
            assertParamExists('tokenRequestEmailCode', 'requestEmailCodeMobileAppAuthenticationRequest', requestEmailCodeMobileAppAuthenticationRequest)
            const localVarPath = `/mobile/request-email-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEmailCodeMobileAppAuthenticationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user\'s 2FA status and available methods
         * @param {TwoFactorStatusMobileAppAuthenticationRequest} twoFactorStatusMobileAppAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenTwoFactorStatus: async (twoFactorStatusMobileAppAuthenticationRequest: TwoFactorStatusMobileAppAuthenticationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFactorStatusMobileAppAuthenticationRequest' is not null or undefined
            assertParamExists('tokenTwoFactorStatus', 'twoFactorStatusMobileAppAuthenticationRequest', twoFactorStatusMobileAppAuthenticationRequest)
            const localVarPath = `/mobile/two-factor-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFactorStatusMobileAppAuthenticationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify two-factor authentication and acquire token
         * @param {VerifyTwoFactorMobileAppAuthenticationRequest} verifyTwoFactorMobileAppAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenVerifyTwoFactor: async (verifyTwoFactorMobileAppAuthenticationRequest: VerifyTwoFactorMobileAppAuthenticationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyTwoFactorMobileAppAuthenticationRequest' is not null or undefined
            assertParamExists('tokenVerifyTwoFactor', 'verifyTwoFactorMobileAppAuthenticationRequest', verifyTwoFactorMobileAppAuthenticationRequest)
            const localVarPath = `/mobile/verify-two-factor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyTwoFactorMobileAppAuthenticationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke all the token for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenWipe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mobile/wipe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MobileAppAuthenticationApi - functional programming interface
 */
export const MobileAppAuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MobileAppAuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Acquire a token for the user
         * @param {AcquireTokenMobileAppAuthenticationRequest} acquireTokenMobileAppAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenAcquire(acquireTokenMobileAppAuthenticationRequest: AcquireTokenMobileAppAuthenticationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenAcquire201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenAcquire(acquireTokenMobileAppAuthenticationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MobileAppAuthenticationApi.tokenAcquire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Request an email 2FA code for mobile authentication
         * @param {RequestEmailCodeMobileAppAuthenticationRequest} requestEmailCodeMobileAppAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenRequestEmailCode(requestEmailCodeMobileAppAuthenticationRequest: RequestEmailCodeMobileAppAuthenticationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRequestEmailCode200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenRequestEmailCode(requestEmailCodeMobileAppAuthenticationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MobileAppAuthenticationApi.tokenRequestEmailCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user\'s 2FA status and available methods
         * @param {TwoFactorStatusMobileAppAuthenticationRequest} twoFactorStatusMobileAppAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenTwoFactorStatus(twoFactorStatusMobileAppAuthenticationRequest: TwoFactorStatusMobileAppAuthenticationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenTwoFactorStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenTwoFactorStatus(twoFactorStatusMobileAppAuthenticationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MobileAppAuthenticationApi.tokenTwoFactorStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify two-factor authentication and acquire token
         * @param {VerifyTwoFactorMobileAppAuthenticationRequest} verifyTwoFactorMobileAppAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenVerifyTwoFactor(verifyTwoFactorMobileAppAuthenticationRequest: VerifyTwoFactorMobileAppAuthenticationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenAcquire201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenVerifyTwoFactor(verifyTwoFactorMobileAppAuthenticationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MobileAppAuthenticationApi.tokenVerifyTwoFactor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Revoke all the token for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenWipe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenWipe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MobileAppAuthenticationApi.tokenWipe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MobileAppAuthenticationApi - factory interface
 */
export const MobileAppAuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MobileAppAuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary Acquire a token for the user
         * @param {AcquireTokenMobileAppAuthenticationRequest} acquireTokenMobileAppAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenAcquire(acquireTokenMobileAppAuthenticationRequest: AcquireTokenMobileAppAuthenticationRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenAcquire201Response> {
            return localVarFp.tokenAcquire(acquireTokenMobileAppAuthenticationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request an email 2FA code for mobile authentication
         * @param {RequestEmailCodeMobileAppAuthenticationRequest} requestEmailCodeMobileAppAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenRequestEmailCode(requestEmailCodeMobileAppAuthenticationRequest: RequestEmailCodeMobileAppAuthenticationRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenRequestEmailCode200Response> {
            return localVarFp.tokenRequestEmailCode(requestEmailCodeMobileAppAuthenticationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user\'s 2FA status and available methods
         * @param {TwoFactorStatusMobileAppAuthenticationRequest} twoFactorStatusMobileAppAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenTwoFactorStatus(twoFactorStatusMobileAppAuthenticationRequest: TwoFactorStatusMobileAppAuthenticationRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenTwoFactorStatus200Response> {
            return localVarFp.tokenTwoFactorStatus(twoFactorStatusMobileAppAuthenticationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify two-factor authentication and acquire token
         * @param {VerifyTwoFactorMobileAppAuthenticationRequest} verifyTwoFactorMobileAppAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenVerifyTwoFactor(verifyTwoFactorMobileAppAuthenticationRequest: VerifyTwoFactorMobileAppAuthenticationRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenAcquire201Response> {
            return localVarFp.tokenVerifyTwoFactor(verifyTwoFactorMobileAppAuthenticationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke all the token for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenWipe(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tokenWipe(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MobileAppAuthenticationApi - object-oriented interface
 */
export class MobileAppAuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Acquire a token for the user
     * @param {AcquireTokenMobileAppAuthenticationRequest} acquireTokenMobileAppAuthenticationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tokenAcquire(acquireTokenMobileAppAuthenticationRequest: AcquireTokenMobileAppAuthenticationRequest, options?: RawAxiosRequestConfig) {
        return MobileAppAuthenticationApiFp(this.configuration).tokenAcquire(acquireTokenMobileAppAuthenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request an email 2FA code for mobile authentication
     * @param {RequestEmailCodeMobileAppAuthenticationRequest} requestEmailCodeMobileAppAuthenticationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tokenRequestEmailCode(requestEmailCodeMobileAppAuthenticationRequest: RequestEmailCodeMobileAppAuthenticationRequest, options?: RawAxiosRequestConfig) {
        return MobileAppAuthenticationApiFp(this.configuration).tokenRequestEmailCode(requestEmailCodeMobileAppAuthenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user\'s 2FA status and available methods
     * @param {TwoFactorStatusMobileAppAuthenticationRequest} twoFactorStatusMobileAppAuthenticationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tokenTwoFactorStatus(twoFactorStatusMobileAppAuthenticationRequest: TwoFactorStatusMobileAppAuthenticationRequest, options?: RawAxiosRequestConfig) {
        return MobileAppAuthenticationApiFp(this.configuration).tokenTwoFactorStatus(twoFactorStatusMobileAppAuthenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify two-factor authentication and acquire token
     * @param {VerifyTwoFactorMobileAppAuthenticationRequest} verifyTwoFactorMobileAppAuthenticationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tokenVerifyTwoFactor(verifyTwoFactorMobileAppAuthenticationRequest: VerifyTwoFactorMobileAppAuthenticationRequest, options?: RawAxiosRequestConfig) {
        return MobileAppAuthenticationApiFp(this.configuration).tokenVerifyTwoFactor(verifyTwoFactorMobileAppAuthenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke all the token for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tokenWipe(options?: RawAxiosRequestConfig) {
        return MobileAppAuthenticationApiFp(this.configuration).tokenWipe(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PartnerApi - axios parameter creator
 */
export const PartnerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerDestroy: async (partner: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partner' is not null or undefined
            assertParamExists('partnerDestroy', 'partner', partner)
            const localVarPath = `/partner/{partner}`
                .replace(`{${"partner"}}`, encodeURIComponent(String(partner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/partner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partner The partner ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerShow: async (partner: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partner' is not null or undefined
            assertParamExists('partnerShow', 'partner', partner)
            const localVarPath = `/partner/{partner}`
                .replace(`{${"partner"}}`, encodeURIComponent(String(partner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StorePartnerRequest} storePartnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerStore: async (storePartnerRequest: StorePartnerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storePartnerRequest' is not null or undefined
            assertParamExists('partnerStore', 'storePartnerRequest', storePartnerRequest)
            const localVarPath = `/partner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storePartnerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partner The partner ID
         * @param {UpdatePartnerRequest} updatePartnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerUpdate: async (partner: string, updatePartnerRequest: UpdatePartnerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partner' is not null or undefined
            assertParamExists('partnerUpdate', 'partner', partner)
            // verify required parameter 'updatePartnerRequest' is not null or undefined
            assertParamExists('partnerUpdate', 'updatePartnerRequest', updatePartnerRequest)
            const localVarPath = `/partner/{partner}`
                .replace(`{${"partner"}}`, encodeURIComponent(String(partner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePartnerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partner The partner ID
         * @param {UpdatePartnerRequest} updatePartnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerUpdate2: async (partner: string, updatePartnerRequest: UpdatePartnerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partner' is not null or undefined
            assertParamExists('partnerUpdate2', 'partner', partner)
            // verify required parameter 'updatePartnerRequest' is not null or undefined
            assertParamExists('partnerUpdate2', 'updatePartnerRequest', updatePartnerRequest)
            const localVarPath = `/partner/{partner}`
                .replace(`{${"partner"}}`, encodeURIComponent(String(partner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePartnerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnerApi - functional programming interface
 */
export const PartnerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartnerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerDestroy(partner: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerDestroy(partner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partner The partner ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerShow(partner: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerShow(partner, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StorePartnerRequest} storePartnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerStore(storePartnerRequest: StorePartnerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerStore(storePartnerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partner The partner ID
         * @param {UpdatePartnerRequest} updatePartnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerUpdate(partner: string, updatePartnerRequest: UpdatePartnerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerUpdate(partner, updatePartnerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partner The partner ID
         * @param {UpdatePartnerRequest} updatePartnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerUpdate2(partner: string, updatePartnerRequest: UpdatePartnerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerUpdate2(partner, updatePartnerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PartnerApi - factory interface
 */
export const PartnerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartnerApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerDestroy(partner: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.partnerDestroy(partner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<PartnerIndex200Response> {
            return localVarFp.partnerIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partner The partner ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerShow(partner: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<PartnerShow200Response> {
            return localVarFp.partnerShow(partner, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StorePartnerRequest} storePartnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerStore(storePartnerRequest: StorePartnerRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerShow200Response> {
            return localVarFp.partnerStore(storePartnerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partner The partner ID
         * @param {UpdatePartnerRequest} updatePartnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerUpdate(partner: string, updatePartnerRequest: UpdatePartnerRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerShow200Response> {
            return localVarFp.partnerUpdate(partner, updatePartnerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partner The partner ID
         * @param {UpdatePartnerRequest} updatePartnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerUpdate2(partner: string, updatePartnerRequest: UpdatePartnerRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerShow200Response> {
            return localVarFp.partnerUpdate2(partner, updatePartnerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartnerApi - object-oriented interface
 */
export class PartnerApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} partner The partner ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerDestroy(partner: string, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerDestroy(partner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} partner The partner ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerShow(partner: string, include?: string, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerShow(partner, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StorePartnerRequest} storePartnerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerStore(storePartnerRequest: StorePartnerRequest, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerStore(storePartnerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} partner The partner ID
     * @param {UpdatePartnerRequest} updatePartnerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerUpdate(partner: string, updatePartnerRequest: UpdatePartnerRequest, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerUpdate(partner, updatePartnerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} partner The partner ID
     * @param {UpdatePartnerRequest} updatePartnerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerUpdate2(partner: string, updatePartnerRequest: UpdatePartnerRequest, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerUpdate2(partner, updatePartnerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectApi - axios parameter creator
 */
export const ProjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} project The project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDestroy: async (project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectDestroy', 'project', project)
            const localVarPath = `/project/{project}`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all visible projects. The project becomes \"visible\" when all conditions are matched: - is_enabled is true - is_launched is true - current date >= launch_date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEnabled: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project/enabled`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggle Enable/disable on a project
         * @param {string} project The project ID
         * @param {SetEnabledProjectRequest} setEnabledProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSetEnabled: async (project: string, setEnabledProjectRequest: SetEnabledProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectSetEnabled', 'project', project)
            // verify required parameter 'setEnabledProjectRequest' is not null or undefined
            assertParamExists('projectSetEnabled', 'setEnabledProjectRequest', setEnabledProjectRequest)
            const localVarPath = `/project/{project}/enabled`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setEnabledProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggle Launched/not-launched on a project. Important: It is independant from the `launch_date` value. It is an idicator showing that the project is to be considered \'laucnhed\' as soon as the launch date it reached
         * @param {string} project The project ID
         * @param {SetLaunchedProjectRequest} setLaunchedProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSetLaunched: async (project: string, setLaunchedProjectRequest: SetLaunchedProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectSetLaunched', 'project', project)
            // verify required parameter 'setLaunchedProjectRequest' is not null or undefined
            assertParamExists('projectSetLaunched', 'setLaunchedProjectRequest', setLaunchedProjectRequest)
            const localVarPath = `/project/{project}/launched`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setLaunchedProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} project The project ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectShow: async (project: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectShow', 'project', project)
            const localVarPath = `/project/{project}`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreProjectRequest} storeProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStore: async (storeProjectRequest: StoreProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeProjectRequest' is not null or undefined
            assertParamExists('projectStore', 'storeProjectRequest', storeProjectRequest)
            const localVarPath = `/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} project The project ID
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectUpdate: async (project: string, updateProjectRequest: UpdateProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectUpdate', 'project', project)
            // verify required parameter 'updateProjectRequest' is not null or undefined
            assertParamExists('projectUpdate', 'updateProjectRequest', updateProjectRequest)
            const localVarPath = `/project/{project}`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} project The project ID
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectUpdate2: async (project: string, updateProjectRequest: UpdateProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectUpdate2', 'project', project)
            // verify required parameter 'updateProjectRequest' is not null or undefined
            assertParamExists('projectUpdate2', 'updateProjectRequest', updateProjectRequest)
            const localVarPath = `/project/{project}`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectApi - functional programming interface
 */
export const ProjectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} project The project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectDestroy(project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectDestroy(project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all visible projects. The project becomes \"visible\" when all conditions are matched: - is_enabled is true - is_launched is true - current date >= launch_date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectEnabled(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectEnabled200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectEnabled(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectEnabled']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Toggle Enable/disable on a project
         * @param {string} project The project ID
         * @param {SetEnabledProjectRequest} setEnabledProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectSetEnabled(project: string, setEnabledProjectRequest: SetEnabledProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectSetEnabled(project, setEnabledProjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectSetEnabled']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Toggle Launched/not-launched on a project. Important: It is independant from the `launch_date` value. It is an idicator showing that the project is to be considered \'laucnhed\' as soon as the launch date it reached
         * @param {string} project The project ID
         * @param {SetLaunchedProjectRequest} setLaunchedProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectSetLaunched(project: string, setLaunchedProjectRequest: SetLaunchedProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectSetLaunched(project, setLaunchedProjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectSetLaunched']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} project The project ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectShow(project: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectShow(project, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreProjectRequest} storeProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectStore(storeProjectRequest: StoreProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectStore(storeProjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} project The project ID
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectUpdate(project: string, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectUpdate(project, updateProjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} project The project ID
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectUpdate2(project: string, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectUpdate2(project, updateProjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectApi - factory interface
 */
export const ProjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} project The project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDestroy(project: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.projectDestroy(project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all visible projects. The project becomes \"visible\" when all conditions are matched: - is_enabled is true - is_launched is true - current date >= launch_date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEnabled(options?: RawAxiosRequestConfig): AxiosPromise<ProjectEnabled200Response> {
            return localVarFp.projectEnabled(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectIndex200Response> {
            return localVarFp.projectIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Toggle Enable/disable on a project
         * @param {string} project The project ID
         * @param {SetEnabledProjectRequest} setEnabledProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSetEnabled(project: string, setEnabledProjectRequest: SetEnabledProjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectShow200Response> {
            return localVarFp.projectSetEnabled(project, setEnabledProjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Toggle Launched/not-launched on a project. Important: It is independant from the `launch_date` value. It is an idicator showing that the project is to be considered \'laucnhed\' as soon as the launch date it reached
         * @param {string} project The project ID
         * @param {SetLaunchedProjectRequest} setLaunchedProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSetLaunched(project: string, setLaunchedProjectRequest: SetLaunchedProjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectShow200Response> {
            return localVarFp.projectSetLaunched(project, setLaunchedProjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} project The project ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectShow(project: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectShow200Response> {
            return localVarFp.projectShow(project, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreProjectRequest} storeProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStore(storeProjectRequest: StoreProjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectShow200Response> {
            return localVarFp.projectStore(storeProjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} project The project ID
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectUpdate(project: string, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectShow200Response> {
            return localVarFp.projectUpdate(project, updateProjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} project The project ID
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectUpdate2(project: string, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectShow200Response> {
            return localVarFp.projectUpdate2(project, updateProjectRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectApi - object-oriented interface
 */
export class ProjectApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} project The project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectDestroy(project: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectDestroy(project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all visible projects. The project becomes \"visible\" when all conditions are matched: - is_enabled is true - is_launched is true - current date >= launch_date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectEnabled(options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectEnabled(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Toggle Enable/disable on a project
     * @param {string} project The project ID
     * @param {SetEnabledProjectRequest} setEnabledProjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectSetEnabled(project: string, setEnabledProjectRequest: SetEnabledProjectRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectSetEnabled(project, setEnabledProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Toggle Launched/not-launched on a project. Important: It is independant from the `launch_date` value. It is an idicator showing that the project is to be considered \'laucnhed\' as soon as the launch date it reached
     * @param {string} project The project ID
     * @param {SetLaunchedProjectRequest} setLaunchedProjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectSetLaunched(project: string, setLaunchedProjectRequest: SetLaunchedProjectRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectSetLaunched(project, setLaunchedProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} project The project ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectShow(project: string, include?: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectShow(project, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreProjectRequest} storeProjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectStore(storeProjectRequest: StoreProjectRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectStore(storeProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} project The project ID
     * @param {UpdateProjectRequest} updateProjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectUpdate(project: string, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectUpdate(project, updateProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} project The project ID
     * @param {UpdateProjectRequest} updateProjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectUpdate2(project: string, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectUpdate2(project, updateProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProvinceApi - axios parameter creator
 */
export const ProvinceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified province
         * @param {string} province The province ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceDestroy: async (province: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'province' is not null or undefined
            assertParamExists('provinceDestroy', 'province', province)
            const localVarPath = `/province/{province}`
                .replace(`{${"province"}}`, encodeURIComponent(String(province)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of provinces
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/province`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified province
         * @param {string} province The province ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceShow: async (province: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'province' is not null or undefined
            assertParamExists('provinceShow', 'province', province)
            const localVarPath = `/province/{province}`
                .replace(`{${"province"}}`, encodeURIComponent(String(province)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created province
         * @param {StoreProvinceRequest} storeProvinceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceStore: async (storeProvinceRequest: StoreProvinceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeProvinceRequest' is not null or undefined
            assertParamExists('provinceStore', 'storeProvinceRequest', storeProvinceRequest)
            const localVarPath = `/province`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeProvinceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified province
         * @param {string} province The province ID
         * @param {UpdateProvinceRequest} updateProvinceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceUpdate: async (province: string, updateProvinceRequest: UpdateProvinceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'province' is not null or undefined
            assertParamExists('provinceUpdate', 'province', province)
            // verify required parameter 'updateProvinceRequest' is not null or undefined
            assertParamExists('provinceUpdate', 'updateProvinceRequest', updateProvinceRequest)
            const localVarPath = `/province/{province}`
                .replace(`{${"province"}}`, encodeURIComponent(String(province)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProvinceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified province
         * @param {string} province The province ID
         * @param {UpdateProvinceRequest} updateProvinceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceUpdate2: async (province: string, updateProvinceRequest: UpdateProvinceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'province' is not null or undefined
            assertParamExists('provinceUpdate2', 'province', province)
            // verify required parameter 'updateProvinceRequest' is not null or undefined
            assertParamExists('provinceUpdate2', 'updateProvinceRequest', updateProvinceRequest)
            const localVarPath = `/province/{province}`
                .replace(`{${"province"}}`, encodeURIComponent(String(province)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProvinceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvinceApi - functional programming interface
 */
export const ProvinceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProvinceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified province
         * @param {string} province The province ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceDestroy(province: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceDestroy(province, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of provinces
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified province
         * @param {string} province The province ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceShow(province: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceShow(province, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created province
         * @param {StoreProvinceRequest} storeProvinceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceStore(storeProvinceRequest: StoreProvinceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceStore(storeProvinceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified province
         * @param {string} province The province ID
         * @param {UpdateProvinceRequest} updateProvinceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceUpdate(province: string, updateProvinceRequest: UpdateProvinceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceUpdate(province, updateProvinceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified province
         * @param {string} province The province ID
         * @param {UpdateProvinceRequest} updateProvinceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceUpdate2(province: string, updateProvinceRequest: UpdateProvinceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceUpdate2(province, updateProvinceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProvinceApi - factory interface
 */
export const ProvinceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProvinceApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified province
         * @param {string} province The province ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceDestroy(province: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.provinceDestroy(province, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of provinces
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceIndex200Response> {
            return localVarFp.provinceIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified province
         * @param {string} province The province ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceShow(province: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceShow200Response> {
            return localVarFp.provinceShow(province, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created province
         * @param {StoreProvinceRequest} storeProvinceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceStore(storeProvinceRequest: StoreProvinceRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceShow200Response> {
            return localVarFp.provinceStore(storeProvinceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified province
         * @param {string} province The province ID
         * @param {UpdateProvinceRequest} updateProvinceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceUpdate(province: string, updateProvinceRequest: UpdateProvinceRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceShow200Response> {
            return localVarFp.provinceUpdate(province, updateProvinceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified province
         * @param {string} province The province ID
         * @param {UpdateProvinceRequest} updateProvinceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceUpdate2(province: string, updateProvinceRequest: UpdateProvinceRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceShow200Response> {
            return localVarFp.provinceUpdate2(province, updateProvinceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProvinceApi - object-oriented interface
 */
export class ProvinceApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified province
     * @param {string} province The province ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceDestroy(province: string, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceDestroy(province, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of provinces
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified province
     * @param {string} province The province ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceShow(province: string, include?: string, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceShow(province, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created province
     * @param {StoreProvinceRequest} storeProvinceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceStore(storeProvinceRequest: StoreProvinceRequest, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceStore(storeProvinceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified province
     * @param {string} province The province ID
     * @param {UpdateProvinceRequest} updateProvinceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceUpdate(province: string, updateProvinceRequest: UpdateProvinceRequest, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceUpdate(province, updateProvinceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified province
     * @param {string} province The province ID
     * @param {UpdateProvinceRequest} updateProvinceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceUpdate2(province: string, updateProvinceRequest: UpdateProvinceRequest, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceUpdate2(province, updateProvinceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProvinceTranslationApi - axios parameter creator
 */
export const ProvinceTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationDestroy: async (provinceTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provinceTranslation' is not null or undefined
            assertParamExists('provinceTranslationDestroy', 'provinceTranslation', provinceTranslation)
            const localVarPath = `/province-translation/{provinceTranslation}`
                .replace(`{${"provinceTranslation"}}`, encodeURIComponent(String(provinceTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/province-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationShow: async (provinceTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provinceTranslation' is not null or undefined
            assertParamExists('provinceTranslationShow', 'provinceTranslation', provinceTranslation)
            const localVarPath = `/province-translation/{provinceTranslation}`
                .replace(`{${"provinceTranslation"}}`, encodeURIComponent(String(provinceTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreProvinceTranslationRequest} storeProvinceTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationStore: async (storeProvinceTranslationRequest: StoreProvinceTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeProvinceTranslationRequest' is not null or undefined
            assertParamExists('provinceTranslationStore', 'storeProvinceTranslationRequest', storeProvinceTranslationRequest)
            const localVarPath = `/province-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeProvinceTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} provinceTranslation The province translation ID
         * @param {UpdateProvinceTranslationRequest} [updateProvinceTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationUpdate: async (provinceTranslation: string, updateProvinceTranslationRequest?: UpdateProvinceTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provinceTranslation' is not null or undefined
            assertParamExists('provinceTranslationUpdate', 'provinceTranslation', provinceTranslation)
            const localVarPath = `/province-translation/{provinceTranslation}`
                .replace(`{${"provinceTranslation"}}`, encodeURIComponent(String(provinceTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProvinceTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} provinceTranslation The province translation ID
         * @param {UpdateProvinceTranslationRequest} [updateProvinceTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationUpdate2: async (provinceTranslation: string, updateProvinceTranslationRequest?: UpdateProvinceTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provinceTranslation' is not null or undefined
            assertParamExists('provinceTranslationUpdate2', 'provinceTranslation', provinceTranslation)
            const localVarPath = `/province-translation/{provinceTranslation}`
                .replace(`{${"provinceTranslation"}}`, encodeURIComponent(String(provinceTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProvinceTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvinceTranslationApi - functional programming interface
 */
export const ProvinceTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProvinceTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationDestroy(provinceTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationDestroy(provinceTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationShow(provinceTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationShow(provinceTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreProvinceTranslationRequest} storeProvinceTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationStore(storeProvinceTranslationRequest: StoreProvinceTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationStore(storeProvinceTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} provinceTranslation The province translation ID
         * @param {UpdateProvinceTranslationRequest} [updateProvinceTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationUpdate(provinceTranslation: string, updateProvinceTranslationRequest?: UpdateProvinceTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationUpdate(provinceTranslation, updateProvinceTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} provinceTranslation The province translation ID
         * @param {UpdateProvinceTranslationRequest} [updateProvinceTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationUpdate2(provinceTranslation: string, updateProvinceTranslationRequest?: UpdateProvinceTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationUpdate2(provinceTranslation, updateProvinceTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProvinceTranslationApi - factory interface
 */
export const ProvinceTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProvinceTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationDestroy(provinceTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.provinceTranslationDestroy(provinceTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<ProvinceTranslationIndex200Response> {
            return localVarFp.provinceTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationShow(provinceTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceTranslationShow200Response> {
            return localVarFp.provinceTranslationShow(provinceTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreProvinceTranslationRequest} storeProvinceTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationStore(storeProvinceTranslationRequest: StoreProvinceTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceTranslationShow200Response> {
            return localVarFp.provinceTranslationStore(storeProvinceTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} provinceTranslation The province translation ID
         * @param {UpdateProvinceTranslationRequest} [updateProvinceTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationUpdate(provinceTranslation: string, updateProvinceTranslationRequest?: UpdateProvinceTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceTranslationShow200Response> {
            return localVarFp.provinceTranslationUpdate(provinceTranslation, updateProvinceTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} provinceTranslation The province translation ID
         * @param {UpdateProvinceTranslationRequest} [updateProvinceTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationUpdate2(provinceTranslation: string, updateProvinceTranslationRequest?: UpdateProvinceTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceTranslationShow200Response> {
            return localVarFp.provinceTranslationUpdate2(provinceTranslation, updateProvinceTranslationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProvinceTranslationApi - object-oriented interface
 */
export class ProvinceTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} provinceTranslation The province translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceTranslationDestroy(provinceTranslation: string, options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationDestroy(provinceTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceTranslationIndex(options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} provinceTranslation The province translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceTranslationShow(provinceTranslation: string, options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationShow(provinceTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreProvinceTranslationRequest} storeProvinceTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceTranslationStore(storeProvinceTranslationRequest: StoreProvinceTranslationRequest, options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationStore(storeProvinceTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} provinceTranslation The province translation ID
     * @param {UpdateProvinceTranslationRequest} [updateProvinceTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceTranslationUpdate(provinceTranslation: string, updateProvinceTranslationRequest?: UpdateProvinceTranslationRequest, options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationUpdate(provinceTranslation, updateProvinceTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} provinceTranslation The province translation ID
     * @param {UpdateProvinceTranslationRequest} [updateProvinceTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceTranslationUpdate2(provinceTranslation: string, updateProvinceTranslationRequest?: UpdateProvinceTranslationRequest, options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationUpdate2(provinceTranslation, updateProvinceTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagApi - axios parameter creator
 */
export const TagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDestroy: async (tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('tagDestroy', 'tag', tag)
            const localVarPath = `/tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tags for a specific item
         * @param {string} item The item ID
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagForItem: async (item: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('tagForItem', 'item', item)
            const localVarPath = `/tag/for-item/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagIndex: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagShow: async (tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('tagShow', 'tag', tag)
            const localVarPath = `/tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreTagRequest} storeTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagStore: async (storeTagRequest: StoreTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeTagRequest' is not null or undefined
            assertParamExists('tagStore', 'storeTagRequest', storeTagRequest)
            const localVarPath = `/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} tag The tag ID
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagUpdate: async (tag: string, updateTagRequest: UpdateTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('tagUpdate', 'tag', tag)
            // verify required parameter 'updateTagRequest' is not null or undefined
            assertParamExists('tagUpdate', 'updateTagRequest', updateTagRequest)
            const localVarPath = `/tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} tag The tag ID
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagUpdate2: async (tag: string, updateTagRequest: UpdateTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('tagUpdate2', 'tag', tag)
            // verify required parameter 'updateTagRequest' is not null or undefined
            assertParamExists('tagUpdate2', 'updateTagRequest', updateTagRequest)
            const localVarPath = `/tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagApi - functional programming interface
 */
export const TagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagDestroy(tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagDestroy(tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get tags for a specific item
         * @param {string} item The item ID
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagForItem(item: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagForItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagForItem(item, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagForItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagIndex(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagForItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagIndex(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagShow(tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagShow(tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreTagRequest} storeTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagStore(storeTagRequest: StoreTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagStore(storeTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} tag The tag ID
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagUpdate(tag: string, updateTagRequest: UpdateTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagUpdate(tag, updateTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} tag The tag ID
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagUpdate2(tag: string, updateTagRequest: UpdateTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagUpdate2(tag, updateTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagApi - factory interface
 */
export const TagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDestroy(tag: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tagDestroy(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tags for a specific item
         * @param {string} item The item ID
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagForItem(item: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<TagForItem200Response> {
            return localVarFp.tagForItem(item, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagIndex(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<TagForItem200Response> {
            return localVarFp.tagIndex(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagShow(tag: string, options?: RawAxiosRequestConfig): AxiosPromise<TagShow200Response> {
            return localVarFp.tagShow(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreTagRequest} storeTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagStore(storeTagRequest: StoreTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<TagShow200Response> {
            return localVarFp.tagStore(storeTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} tag The tag ID
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagUpdate(tag: string, updateTagRequest: UpdateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<TagShow200Response> {
            return localVarFp.tagUpdate(tag, updateTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} tag The tag ID
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagUpdate2(tag: string, updateTagRequest: UpdateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<TagShow200Response> {
            return localVarFp.tagUpdate2(tag, updateTagRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagApi - object-oriented interface
 */
export class TagApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} tag The tag ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagDestroy(tag: string, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagDestroy(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tags for a specific item
     * @param {string} item The item ID
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagForItem(item: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagForItem(item, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagIndex(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagIndex(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} tag The tag ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagShow(tag: string, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagShow(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreTagRequest} storeTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagStore(storeTagRequest: StoreTagRequest, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagStore(storeTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} tag The tag ID
     * @param {UpdateTagRequest} updateTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagUpdate(tag: string, updateTagRequest: UpdateTagRequest, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagUpdate(tag, updateTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} tag The tag ID
     * @param {UpdateTagRequest} updateTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagUpdate2(tag: string, updateTagRequest: UpdateTagRequest, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagUpdate2(tag, updateTagRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ThemeApi - axios parameter creator
 */
export const ThemeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified theme from storage
         * @param {string} theme The theme ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeDestroy: async (theme: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'theme' is not null or undefined
            assertParamExists('themeDestroy', 'theme', theme)
            const localVarPath = `/theme/{theme}`
                .replace(`{${"theme"}}`, encodeURIComponent(String(theme)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/theme`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} theme The theme ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeShow: async (theme: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'theme' is not null or undefined
            assertParamExists('themeShow', 'theme', theme)
            const localVarPath = `/theme/{theme}`
                .replace(`{${"theme"}}`, encodeURIComponent(String(theme)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created theme in storage
         * @param {StoreThemeRequest} storeThemeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeStore: async (storeThemeRequest: StoreThemeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeThemeRequest' is not null or undefined
            assertParamExists('themeStore', 'storeThemeRequest', storeThemeRequest)
            const localVarPath = `/theme`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeThemeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified theme in storage
         * @param {string} theme The theme ID
         * @param {UpdateThemeRequest} [updateThemeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeUpdate: async (theme: string, updateThemeRequest?: UpdateThemeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'theme' is not null or undefined
            assertParamExists('themeUpdate', 'theme', theme)
            const localVarPath = `/theme/{theme}`
                .replace(`{${"theme"}}`, encodeURIComponent(String(theme)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateThemeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified theme in storage
         * @param {string} theme The theme ID
         * @param {UpdateThemeRequest} [updateThemeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeUpdate2: async (theme: string, updateThemeRequest?: UpdateThemeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'theme' is not null or undefined
            assertParamExists('themeUpdate2', 'theme', theme)
            const localVarPath = `/theme/{theme}`
                .replace(`{${"theme"}}`, encodeURIComponent(String(theme)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateThemeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThemeApi - functional programming interface
 */
export const ThemeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThemeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme from storage
         * @param {string} theme The theme ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeDestroy(theme: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeDestroy(theme, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeApi.themeDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeApi.themeIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} theme The theme ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeShow(theme: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeShow(theme, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeApi.themeShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created theme in storage
         * @param {StoreThemeRequest} storeThemeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeStore(storeThemeRequest: StoreThemeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeStore(storeThemeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeApi.themeStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified theme in storage
         * @param {string} theme The theme ID
         * @param {UpdateThemeRequest} [updateThemeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeUpdate(theme: string, updateThemeRequest?: UpdateThemeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeUpdate(theme, updateThemeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeApi.themeUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified theme in storage
         * @param {string} theme The theme ID
         * @param {UpdateThemeRequest} [updateThemeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeUpdate2(theme: string, updateThemeRequest?: UpdateThemeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeUpdate2(theme, updateThemeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeApi.themeUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ThemeApi - factory interface
 */
export const ThemeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThemeApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme from storage
         * @param {string} theme The theme ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeDestroy(theme: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.themeDestroy(theme, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ThemeIndex200Response> {
            return localVarFp.themeIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} theme The theme ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeShow(theme: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ThemeShow200Response> {
            return localVarFp.themeShow(theme, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created theme in storage
         * @param {StoreThemeRequest} storeThemeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeStore(storeThemeRequest: StoreThemeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeShow200Response> {
            return localVarFp.themeStore(storeThemeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified theme in storage
         * @param {string} theme The theme ID
         * @param {UpdateThemeRequest} [updateThemeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeUpdate(theme: string, updateThemeRequest?: UpdateThemeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeShow200Response> {
            return localVarFp.themeUpdate(theme, updateThemeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified theme in storage
         * @param {string} theme The theme ID
         * @param {UpdateThemeRequest} [updateThemeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeUpdate2(theme: string, updateThemeRequest?: UpdateThemeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeShow200Response> {
            return localVarFp.themeUpdate2(theme, updateThemeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThemeApi - object-oriented interface
 */
export class ThemeApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified theme from storage
     * @param {string} theme The theme ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeDestroy(theme: string, options?: RawAxiosRequestConfig) {
        return ThemeApiFp(this.configuration).themeDestroy(theme, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return ThemeApiFp(this.configuration).themeIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} theme The theme ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeShow(theme: string, include?: string, options?: RawAxiosRequestConfig) {
        return ThemeApiFp(this.configuration).themeShow(theme, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created theme in storage
     * @param {StoreThemeRequest} storeThemeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeStore(storeThemeRequest: StoreThemeRequest, options?: RawAxiosRequestConfig) {
        return ThemeApiFp(this.configuration).themeStore(storeThemeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified theme in storage
     * @param {string} theme The theme ID
     * @param {UpdateThemeRequest} [updateThemeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeUpdate(theme: string, updateThemeRequest?: UpdateThemeRequest, options?: RawAxiosRequestConfig) {
        return ThemeApiFp(this.configuration).themeUpdate(theme, updateThemeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified theme in storage
     * @param {string} theme The theme ID
     * @param {UpdateThemeRequest} [updateThemeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeUpdate2(theme: string, updateThemeRequest?: UpdateThemeRequest, options?: RawAxiosRequestConfig) {
        return ThemeApiFp(this.configuration).themeUpdate2(theme, updateThemeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ThemeTranslationApi - axios parameter creator
 */
export const ThemeTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationDestroy: async (themeTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationDestroy', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {string} [themeId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationIndex: async (themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/theme-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (themeId !== undefined) {
                localVarQueryParameter['theme_id'] = themeId;
            }

            if (languageId !== undefined) {
                localVarQueryParameter['language_id'] = languageId;
            }

            if (contextId !== undefined) {
                localVarQueryParameter['context_id'] = contextId;
            }

            if (defaultContext !== undefined) {
                localVarQueryParameter['default_context'] = defaultContext;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationShow: async (themeTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationShow', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {StoreThemeTranslationRequest} storeThemeTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationStore: async (storeThemeTranslationRequest: StoreThemeTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeThemeTranslationRequest' is not null or undefined
            assertParamExists('themeTranslationStore', 'storeThemeTranslationRequest', storeThemeTranslationRequest)
            const localVarPath = `/theme-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeThemeTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate: async (themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationUpdate', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateThemeTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate2: async (themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationUpdate2', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateThemeTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThemeTranslationApi - functional programming interface
 */
export const ThemeTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThemeTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationDestroy(themeTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationApi.themeTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {string} [themeId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationIndex(themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThemeTranslationResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationIndex(themeId, languageId, contextId, defaultContext, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationApi.themeTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationShow(themeTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationApi.themeTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {StoreThemeTranslationRequest} storeThemeTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationStore(storeThemeTranslationRequest: StoreThemeTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationStore(storeThemeTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationApi.themeTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationUpdate(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationUpdate(themeTranslation, updateThemeTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationApi.themeTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationUpdate2(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationUpdate2(themeTranslation, updateThemeTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationApi.themeTranslationUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ThemeTranslationApi - factory interface
 */
export const ThemeTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThemeTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.themeTranslationDestroy(themeTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {string} [themeId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationIndex(themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<ThemeTranslationResource>> {
            return localVarFp.themeTranslationIndex(themeId, languageId, contextId, defaultContext, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationShow200Response> {
            return localVarFp.themeTranslationShow(themeTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {StoreThemeTranslationRequest} storeThemeTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationStore(storeThemeTranslationRequest: StoreThemeTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationShow200Response> {
            return localVarFp.themeTranslationStore(storeThemeTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationShow200Response> {
            return localVarFp.themeTranslationUpdate(themeTranslation, updateThemeTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate2(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationShow200Response> {
            return localVarFp.themeTranslationUpdate2(themeTranslation, updateThemeTranslationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThemeTranslationApi - object-oriented interface
 */
export class ThemeTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig) {
        return ThemeTranslationApiFp(this.configuration).themeTranslationDestroy(themeTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of theme translations
     * @param {string} [themeId] 
     * @param {string} [languageId] 
     * @param {string} [contextId] 
     * @param {boolean} [defaultContext] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationIndex(themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig) {
        return ThemeTranslationApiFp(this.configuration).themeTranslationIndex(themeId, languageId, contextId, defaultContext, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig) {
        return ThemeTranslationApiFp(this.configuration).themeTranslationShow(themeTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created theme translation
     * @param {StoreThemeTranslationRequest} storeThemeTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationStore(storeThemeTranslationRequest: StoreThemeTranslationRequest, options?: RawAxiosRequestConfig) {
        return ThemeTranslationApiFp(this.configuration).themeTranslationStore(storeThemeTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationUpdate(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig) {
        return ThemeTranslationApiFp(this.configuration).themeTranslationUpdate(themeTranslation, updateThemeTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationUpdate2(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig) {
        return ThemeTranslationApiFp(this.configuration).themeTranslationUpdate2(themeTranslation, updateThemeTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ThemeTranslationsApi - axios parameter creator
 */
export const ThemeTranslationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationDestroy: async (themeTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationDestroy', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {string} [themeId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationIndex: async (themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/theme-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (themeId !== undefined) {
                localVarQueryParameter['theme_id'] = themeId;
            }

            if (languageId !== undefined) {
                localVarQueryParameter['language_id'] = languageId;
            }

            if (contextId !== undefined) {
                localVarQueryParameter['context_id'] = contextId;
            }

            if (defaultContext !== undefined) {
                localVarQueryParameter['default_context'] = defaultContext;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationShow: async (themeTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationShow', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {StoreThemeTranslationRequest} storeThemeTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationStore: async (storeThemeTranslationRequest: StoreThemeTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeThemeTranslationRequest' is not null or undefined
            assertParamExists('themeTranslationStore', 'storeThemeTranslationRequest', storeThemeTranslationRequest)
            const localVarPath = `/theme-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeThemeTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate: async (themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationUpdate', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateThemeTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate2: async (themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationUpdate2', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateThemeTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThemeTranslationsApi - functional programming interface
 */
export const ThemeTranslationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThemeTranslationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationDestroy(themeTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationsApi.themeTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {string} [themeId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationIndex(themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThemeTranslationResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationIndex(themeId, languageId, contextId, defaultContext, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationsApi.themeTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationShow(themeTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationsApi.themeTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {StoreThemeTranslationRequest} storeThemeTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationStore(storeThemeTranslationRequest: StoreThemeTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationStore(storeThemeTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationsApi.themeTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationUpdate(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationUpdate(themeTranslation, updateThemeTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationsApi.themeTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationUpdate2(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationUpdate2(themeTranslation, updateThemeTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationsApi.themeTranslationUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ThemeTranslationsApi - factory interface
 */
export const ThemeTranslationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThemeTranslationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.themeTranslationDestroy(themeTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {string} [themeId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationIndex(themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<ThemeTranslationResource>> {
            return localVarFp.themeTranslationIndex(themeId, languageId, contextId, defaultContext, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationShow200Response> {
            return localVarFp.themeTranslationShow(themeTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {StoreThemeTranslationRequest} storeThemeTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationStore(storeThemeTranslationRequest: StoreThemeTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationShow200Response> {
            return localVarFp.themeTranslationStore(storeThemeTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationShow200Response> {
            return localVarFp.themeTranslationUpdate(themeTranslation, updateThemeTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate2(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationShow200Response> {
            return localVarFp.themeTranslationUpdate2(themeTranslation, updateThemeTranslationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThemeTranslationsApi - object-oriented interface
 */
export class ThemeTranslationsApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig) {
        return ThemeTranslationsApiFp(this.configuration).themeTranslationDestroy(themeTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of theme translations
     * @param {string} [themeId] 
     * @param {string} [languageId] 
     * @param {string} [contextId] 
     * @param {boolean} [defaultContext] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationIndex(themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig) {
        return ThemeTranslationsApiFp(this.configuration).themeTranslationIndex(themeId, languageId, contextId, defaultContext, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig) {
        return ThemeTranslationsApiFp(this.configuration).themeTranslationShow(themeTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created theme translation
     * @param {StoreThemeTranslationRequest} storeThemeTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationStore(storeThemeTranslationRequest: StoreThemeTranslationRequest, options?: RawAxiosRequestConfig) {
        return ThemeTranslationsApiFp(this.configuration).themeTranslationStore(storeThemeTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationUpdate(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig) {
        return ThemeTranslationsApiFp(this.configuration).themeTranslationUpdate(themeTranslation, updateThemeTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationUpdate2(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig) {
        return ThemeTranslationsApiFp(this.configuration).themeTranslationUpdate2(themeTranslation, updateThemeTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserPermissionsApi - axios parameter creator
 */
export const UserPermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of permission names that the authenticated user has. This is a read-only endpoint for UI clients to determine what features to show to the user.
         * @summary Get the authenticated user\'s permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPermissions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserPermissionsApi - functional programming interface
 */
export const UserPermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserPermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of permission names that the authenticated user has. This is a read-only endpoint for UI clients to determine what features to show to the user.
         * @summary Get the authenticated user\'s permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPermissions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPermissions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPermissions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserPermissionsApi.userPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserPermissionsApi - factory interface
 */
export const UserPermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserPermissionsApiFp(configuration)
    return {
        /**
         * Returns a list of permission names that the authenticated user has. This is a read-only endpoint for UI clients to determine what features to show to the user.
         * @summary Get the authenticated user\'s permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPermissions(options?: RawAxiosRequestConfig): AxiosPromise<UserPermissions200Response> {
            return localVarFp.userPermissions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserPermissionsApi - object-oriented interface
 */
export class UserPermissionsApi extends BaseAPI {
    /**
     * Returns a list of permission names that the authenticated user has. This is a read-only endpoint for UI clients to determine what features to show to the user.
     * @summary Get the authenticated user\'s permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userPermissions(options?: RawAxiosRequestConfig) {
        return UserPermissionsApiFp(this.configuration).userPermissions(options).then((request) => request(this.axios, this.basePath));
    }
}



