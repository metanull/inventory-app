/* tslint:disable */
/* eslint-disable */
/**
 * Inventory-App
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AcquireTokenMobileAppAuthenticationRequest {
    'email': string;
    'password': string;
    'device_name': string;
    'wipe_tokens'?: boolean;
    'two_factor_code'?: string;
    'recovery_code'?: string;
}
export interface ArtistResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The name of the artist
     */
    'name': string;
    /**
     * The place of birth of the artist
     */
    'place_of_birth': string | null;
    /**
     * The place of death of the artist
     */
    'place_of_death': string | null;
    /**
     * The date of birth of the artist
     */
    'date_of_birth': string | null;
    /**
     * The date of death of the artist
     */
    'date_of_death': string | null;
    /**
     * The period of activity of the artist
     */
    'period_of_activity': string | null;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
    /**
     * Items associated with this artist (ItemResource[])
     */
    'items'?: Array<ItemResource>;
}
export interface AttachFromAvailableCollectionImageRequest {
    'available_image_id': string;
    'alt_text'?: string | null;
    'include'?: string;
}
export interface AttachFromAvailableItemImageRequest {
    'available_image_id': string;
    'alt_text'?: string | null;
    'include'?: string;
}
export interface AttachFromAvailablePartnerImageRequest {
    'available_image_id': string;
    'alt_text'?: string | null;
    'include'?: string;
}
export interface AttachFromAvailablePartnerTranslationImageRequest {
    'available_image_id': string;
    'alt_text'?: string | null;
    'include'?: string;
}
export interface AttachGlossarySynonymRequest {
    'synonym_id': string;
}
export interface AttachItemCollectionRequest {
    'item_id': string;
    'include'?: string;
}
export interface AttachItemsCollectionRequest {
    'include'?: string;
    'item_ids': Array<string>;
}
export interface AttachTagItemRequest {
    'tag_id': string;
    'include'?: string;
}
export interface AttachTagsItemRequest {
    'include'?: string;
    'tag_ids': Array<string>;
}
export interface AuthorResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The name of the author
     */
    'name': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string | null;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface AvailableImageIndex200Response {
    'data': Array<AvailableImageResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface AvailableImageIndex200ResponseLinks {
    'first': string | null;
    'last': string | null;
    'prev': string | null;
    'next': string | null;
}
export interface AvailableImageIndex200ResponseMeta {
    'current_page': number;
    'from': number | null;
    'last_page': number;
    /**
     * Generated paginator links.
     */
    'links': Array<AvailableImageIndex200ResponseMetaLinksInner>;
    /**
     * Base path for paginator generated URLs.
     */
    'path': string | null;
    /**
     * Number of items shown per page.
     */
    'per_page': number;
    /**
     * Number of the last item in the slice.
     */
    'to': number | null;
    /**
     * Total number of items being paginated.
     */
    'total': number;
}
export interface AvailableImageIndex200ResponseMetaLinksInner {
    'url': string | null;
    'label': string;
    'active': boolean;
}
export interface AvailableImageResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The path to the picture file
     */
    'path': string | null;
    /**
     * A user defined comment associated with the file
     */
    'comment': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface AvailableImageShow200Response {
    'data': AvailableImageResource;
}
export interface CollectionByType200Response {
    'data': Array<CollectionResource>;
}
export interface CollectionImageResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The collection this image belongs to
     */
    'collection_id': string;
    /**
     * The path to the image file
     */
    'path': string;
    /**
     * The original filename when uploaded
     */
    'original_name': string;
    /**
     * The MIME type of the image
     */
    'mime_type': string;
    /**
     * The file size in bytes
     */
    'size': number;
    /**
     * Alternative text for accessibility
     */
    'alt_text': string | null;
    /**
     * Display order for sorting images
     */
    'display_order': number;
    /**
     * The collection this image belongs to (CollectionResource)
     */
    'collection'?: CollectionResource;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface CollectionImageTightenOrdering200Response {
    'data': OperationSuccessResource;
}
export interface CollectionImagesIndex200Response {
    'data': Array<CollectionImageResource>;
}
export interface CollectionImagesStore200Response {
    'data': CollectionImageResource;
}
export interface CollectionIndex200Response {
    'data': Array<CollectionResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface CollectionResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The type of collection: \'collection\', \'exhibition\', or \'gallery\'
     */
    'type': string;
    /**
     * The language this collection belongs to (LanguageResource id)
     */
    'language_id': string;
    /**
     * The context this collection belongs to (ContextResource id)
     */
    'context_id': string;
    /**
     * The parent collection ID (for hierarchical organization)
     */
    'parent_id': string | null;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
    /**
     * The language relationship (LanguageResource)
     */
    'language'?: LanguageResource;
    /**
     * The context relationship (ContextResource)
     */
    'context'?: ContextResource;
    /**
     * The parent collection (CollectionResource)
     */
    'parent'?: CollectionResource;
    /**
     * Child collections (CollectionResource[])
     */
    'children'?: Array<CollectionResource>;
    /**
     * Translations for this collection (CollectionTranslationResource[])
     */
    'translations'?: Array<CollectionTranslationResource>;
    /**
     * Partners associated with this collection (PartnerResource[])
     */
    'partners'?: Array<PartnerResource>;
    /**
     * Items associated with this collection - primary relationship (ItemResource[])
     */
    'items'?: Array<ItemResource>;
    /**
     * Items attached to this collection via many-to-many relationship (ItemResource[])
     */
    'attachedItems'?: Array<ItemResource>;
    /**
     * The number of items in this collection (computed)
     */
    'items_count'?: number;
    'attached_items_count'?: number;
    'partners_count'?: number;
    'translations_count'?: number;
    'children_count'?: number;
}
export interface CollectionShow200Response {
    'data': CollectionResource;
}
export interface CollectionTranslationIndex200Response {
    'data': Array<CollectionTranslationResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface CollectionTranslationResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The collection this translation belongs to (CollectionResource id)
     */
    'collection_id': string;
    /**
     * The language of this translation (LanguageResource id)
     */
    'language_id': string;
    /**
     * The context of this translation (ContextResource id)
     */
    'context_id': string;
    /**
     * The title of the collection translation
     */
    'title': string;
    /**
     * The description of the collection translation
     */
    'description': string;
    /**
     * The URL for the collection translation
     */
    'url': string | null;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * Extra data for translation (object, may be null)
     */
    'extra': object | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
    /**
     * The collection relationship (CollectionResource)
     */
    'collection'?: CollectionResource;
    /**
     * The language relationship (LanguageResource)
     */
    'language'?: LanguageResource;
    /**
     * The context relationship (ContextResource)
     */
    'context'?: ContextResource;
}
export interface CollectionTranslationShow200Response {
    'data': CollectionTranslationResource;
}
export interface ContextClearDefault200Response {
    'data': MessageResource;
}
export interface ContextGetDefault200Response {
    'data': ContextResource;
}
export interface ContextGetDefault404Response {
    'message': ContextGetDefault404ResponseMessage;
}
export interface ContextGetDefault404ResponseMessage {
}
export interface ContextIndex200Response {
    'data': Array<ContextResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface ContextResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * Indicates if this context is the default one. There is one single default context for the entire database.
     */
    'is_default': boolean;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface ConversionResource {
    'success': MarkdownPreview422ResponseSuccess;
    'message': string;
    'data': string;
    'error': string;
    'errors': string;
}
export interface CountryIndex200Response {
    'data': Array<CountryResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface CountryResource {
    /**
     * The unique identifier (ISO 3166-1 alpha-3 code)
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface CountryShow200Response {
    'data': CountryResource;
}
export interface CountryTranslationIndex200Response {
    'data': Array<CountryTranslationResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface CountryTranslationResource {
    'id': string;
    'country_id': string;
    'language_id': string;
    'name': string;
    /**
     * Relationships
     */
    'country'?: CountryResource;
    'language'?: LanguageResource;
    /**
     * Metadata
     */
    'backward_compatibility': string | null;
    'extra': object | null;
    /**
     * Timestamps
     */
    'created_at': string | null;
    'updated_at': string | null;
}
export interface CountryTranslationShow200Response {
    'data': CountryTranslationResource;
}
export interface GlossaryIndex200Response {
    'data': Array<GlossaryResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface GlossaryResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
    /**
     * Relationships (only included if loaded)
     */
    'translations'?: Array<GlossaryTranslationResource>;
    'spellings'?: Array<GlossarySpellingResource>;
    'synonyms'?: Array<GlossaryResource>;
}
export interface GlossaryShow200Response {
    'data': GlossaryResource;
}
export interface GlossarySpellingIndex200Response {
    'data': Array<GlossarySpellingResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface GlossarySpellingResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The glossary this spelling belongs to
     */
    'glossary_id': string;
    /**
     * The language of this spelling
     */
    'language_id': string;
    /**
     * The spelling variation
     */
    'spelling': string;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
    /**
     * Relationships (only included if loaded)
     */
    'glossary'?: GlossaryResource;
    'language'?: LanguageResource;
    'item_translations'?: Array<ItemTranslationResource>;
}
export interface GlossarySpellingShow200Response {
    'data': GlossarySpellingResource;
}
export interface GlossaryTranslationIndex200Response {
    'data': Array<GlossaryTranslationResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface GlossaryTranslationResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The glossary this translation belongs to
     */
    'glossary_id': string;
    /**
     * The language of this translation
     */
    'language_id': string;
    /**
     * The definition/translation text
     */
    'definition': string;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
    /**
     * Relationships (only included if loaded)
     */
    'glossary'?: GlossaryResource;
    'language'?: LanguageResource;
}
export interface GlossaryTranslationShow200Response {
    'data': GlossaryTranslationResource;
}
export interface ImageUploadIndex200Response {
    'data': Array<ImageUploadResource>;
}
export interface ImageUploadResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The path to the picture file
     */
    'path': string | null;
    /**
     * The original name of the uploaded file
     */
    'name': string | null;
    /**
     * The file extension of the uploaded file
     */
    'extension': string | null;
    /**
     * The MIME type of the uploaded file
     */
    'mime_type': string | null;
    /**
     * The size of the uploaded file in bytes
     */
    'size': number | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface ImageUploadShow200Response {
    'data': ImageUploadResource;
}
export interface ImageUploadStatus200Response {
    'data': ImageUploadStatusResource;
}
export interface ImageUploadStatus404Response {
    'status': string;
    'available_image': string;
}
export interface ImageUploadStatusResource {
    'status': string;
    'available_image': string;
}
export interface InlineObject {
    /**
     * Error overview.
     */
    'message': string;
}
export interface InlineObject1 {
    /**
     * Errors overview.
     */
    'message': string;
    /**
     * A detailed description of each field that failed validation.
     */
    'errors': { [key: string]: Array<string>; };
}
export interface ItemForTag200Response {
    'data': Array<ItemResource>;
}
export interface ItemImageResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The item this image belongs to
     */
    'item_id': string;
    /**
     * The path to the image file
     */
    'path': string;
    /**
     * The original filename when uploaded
     */
    'original_name': string;
    /**
     * The MIME type of the image
     */
    'mime_type': string;
    /**
     * The file size in bytes
     */
    'size': number;
    /**
     * Alternative text for accessibility
     */
    'alt_text': string | null;
    /**
     * Display order for sorting images
     */
    'display_order': number;
    /**
     * The item this image belongs to (ItemResource)
     */
    'item'?: ItemResource;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface ItemImagesIndex200Response {
    'data': Array<ItemImageResource>;
}
export interface ItemImagesStore200Response {
    'data': ItemImageResource;
}
export interface ItemIndex200Response {
    'data': Array<ItemResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface ItemItemLinkIndex200Response {
    'data': Array<ItemItemLinkResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface ItemItemLinkResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The source item ID (the item initiating the link)
     */
    'source_id': string;
    /**
     * The target item ID (the item receiving the link)
     */
    'target_id': string;
    /**
     * The context ID (the context in which the link exists)
     */
    'context_id': string;
    /**
     * The source item (ItemResource)
     */
    'source'?: ItemResource;
    /**
     * The target item (ItemResource)
     */
    'target'?: ItemResource;
    /**
     * The context (ContextResource)
     */
    'context'?: ContextResource;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface ItemItemLinkShow200Response {
    'data': ItemItemLinkResource;
}
export interface ItemResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * The type of the item: \'object\', \'monument\', \'detail\', or \'picture\'.
     */
    'type': ItemType;
    /**
     * The parent item ID (for hierarchical relationships), nullable
     */
    'parent_id': string | null;
    /**
     * Owner\'s reference number for the item (external reference from owner)
     */
    'owner_reference': string | null;
    /**
     * MWNF reference number for the item (reference from MWNF system)
     */
    'mwnf_reference': string | null;
    /**
     * The parent item (for hierarchical relationships), nullable (ItemResource)
     */
    'parent'?: ItemResource;
    /**
     * The child items (for hierarchical relationships) (ItemResource[])
     */
    'children'?: Array<ItemResource>;
    /**
     * The partner owning the item (PartnerResource)
     */
    'partner'?: PartnerResource;
    /**
     * The project this item belongs to, nullable (ProjectResource)
     */
    'project'?: ProjectResource;
    /**
     * The country this item is associated with, nullable (CountryResource)
     */
    'country'?: CountryResource;
    /**
     * The collection that contains this item (CollectionResource)
     */
    'collection'?: CollectionResource;
    /**
     * Artists associated with this item (ArtistResource[])
     */
    'artists'?: Array<ArtistResource>;
    /**
     * Workshops associated with this item (WorkshopResource[])
     */
    'workshops'?: Array<WorkshopResource>;
    /**
     * Tags associated with this item (TagResource[])
     */
    'tags'?: Array<TagResource>;
    /**
     * Translations for this item (internationalization and contextualization) (ItemTranslationResource[])
     */
    'translations'?: Array<ItemTranslationResource>;
    /**
     * Item images attached to this item with display ordering (ItemImageResource[])
     */
    'itemImages'?: Array<ItemImageResource>;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}


export interface ItemShow200Response {
    'data': ItemResource;
}
export interface ItemTranslationIndex200Response {
    'data': Array<ItemTranslationResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface ItemTranslationResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The item this translation belongs to (ItemResource id)
     */
    'item_id': string;
    /**
     * The language of this translation (LanguageResource id)
     */
    'language_id': string;
    /**
     * The context of this translation (ContextResource id)
     */
    'context_id': string;
    /**
     * The name of the item translation
     */
    'name': string;
    /**
     * The alternate name of the item translation
     */
    'alternate_name': string | null;
    /**
     * The description of the item translation
     */
    'description': string | null;
    /**
     * The type of the item translation
     */
    'type': string | null;
    /**
     * The holder of the item
     */
    'holder': string | null;
    /**
     * The owner of the item
     */
    'owner': string | null;
    /**
     * The initial owner of the item
     */
    'initial_owner': string | null;
    /**
     * The dates associated with the item
     */
    'dates': string | null;
    /**
     * The location associated with the item
     */
    'location': string | null;
    /**
     * The dimensions of the item
     */
    'dimensions': string | null;
    /**
     * The place of production of the item
     */
    'place_of_production': string | null;
    /**
     * The method for datation of the item
     */
    'method_for_datation': string | null;
    /**
     * The method for provenance of the item
     */
    'method_for_provenance': string | null;
    /**
     * The obtention of the item
     */
    'obtention': string | null;
    /**
     * The bibliography for the item
     */
    'bibliography': string | null;
    /**
     * The author of the item (AuthorResource id)
     */
    'author_id': string | null;
    /**
     * The copy-editor of the item (AuthorResource id)
     */
    'text_copy_editor_id': string | null;
    /**
     * The translator of the item translation (AuthorResource id)
     */
    'translator_id': string | null;
    /**
     * The copy-editor of the item translation (AuthorResource id)
     */
    'translation_copy_editor_id': string | null;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * Extra data for translation (object, may be null)
     */
    'extra': object | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
    /**
     * The item relationship (ItemResource)
     */
    'item'?: ItemResource;
    /**
     * The language relationship (LanguageResource)
     */
    'language'?: LanguageResource;
    /**
     * The context relationship (ContextResource)
     */
    'context'?: ContextResource;
    /**
     * The author relationship (AuthorResource)
     */
    'author'?: AuthorResource;
    /**
     * The copy-editor relationship (AuthorResource)
     */
    'text_copy_editor'?: AuthorResource;
    /**
     * The translator relationship (AuthorResource)
     */
    'translator'?: AuthorResource;
    /**
     * The translation copy-editor relationship (AuthorResource)
     */
    'translation_copy_editor'?: AuthorResource;
}
export interface ItemTranslationShow200Response {
    'data': ItemTranslationResource;
}

export const ItemType = {
    Object: 'object',
    Monument: 'monument',
    Detail: 'detail',
    Picture: 'picture'
} as const;

export type ItemType = typeof ItemType[keyof typeof ItemType];


export interface LanguageGetDefault200Response {
    'data': LanguageResource;
}
export interface LanguageIndex200Response {
    'data': Array<LanguageResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface LanguageResource {
    /**
     * The unique identifier (ISO 639-1 code)
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * Indicates if this language is the default one. There is one single default language for the entire database.
     */
    'is_default': boolean;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface LanguageTranslationIndex200Response {
    'data': Array<LanguageTranslationResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface LanguageTranslationResource {
    'id': string;
    'language_id': string;
    'display_language_id': string;
    'name': string;
    /**
     * Relationships
     */
    'language'?: LanguageResource;
    'display_language'?: LanguageResource;
    /**
     * Metadata
     */
    'backward_compatibility': string | null;
    'extra': object | null;
    /**
     * Timestamps
     */
    'created_at': string | null;
    'updated_at': string | null;
}
export interface LanguageTranslationShow200Response {
    'data': LanguageTranslationResource;
}
export interface LocationIndex200Response {
    'data': Array<LocationResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface LocationResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The country this location belongs to (CountryResource id)
     */
    'country_id': string;
    /**
     * Translations for this location (LocationTranslationResource[])
     */
    'translations'?: Array<LocationTranslationResource>;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface LocationShow200Response {
    'data': LocationResource;
}
export interface LocationTranslationIndex200Response {
    'data': Array<LocationTranslationResource>;
}
export interface LocationTranslationResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The location this translation belongs to (LocationResource id)
     */
    'location_id': string;
    /**
     * The language of this translation (LanguageResource id)
     */
    'language_id': string;
    /**
     * The name of the location translation
     */
    'name': string;
    /**
     * The description of the location translation
     */
    'description': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface LocationTranslationShow200Response {
    'data': LocationTranslationResource;
}
export interface MarkdownFromHtmlRequest {
    'html': string;
}
export interface MarkdownIsMarkdownRequest {
    'content': string;
}
export interface MarkdownPreview422Response {
    'success': MarkdownPreview422ResponseSuccess;
    'message': string;
    'data': string;
    'error': string;
    'errors': string;
}
export interface MarkdownPreview422ResponseSuccess {
}
export interface MarkdownToHtmlRequest {
    'markdown': string;
}
export interface MessageResource {
    'message': ContextGetDefault404ResponseMessage;
}
export interface OperationSuccessResource {
    'success': MarkdownPreview422ResponseSuccess;
    'message': OperationSuccessResourceMessage;
}
export interface OperationSuccessResourceMessage {
}
export interface PartnerImageIndex200Response {
    'data': Array<PartnerImageResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface PartnerImageResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * Foreign key
     */
    'partner_id': string;
    /**
     * Image information
     */
    'path': string;
    'original_name': string;
    'mime_type': string;
    'size': number;
    'alt_text': string | null;
    'display_order': number;
    /**
     * Relationships
     */
    'partner'?: PartnerResource;
    /**
     * Timestamps
     */
    'created_at': string | null;
    'updated_at': string | null;
}
export interface PartnerImageShow200Response {
    'data': PartnerImageResource;
}
export interface PartnerIndex200Response {
    'data': Array<PartnerResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface PartnerResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * The type of the partner, either \'museum\', \'institution\' or \'individual\'.
     */
    'type': string;
    /**
     * The country this partner is associated with, nullable (CountryResource)
     */
    'country'?: CountryResource;
    /**
     * GPS Location
     */
    'latitude': string | null;
    'longitude': string | null;
    'map_zoom': number;
    /**
     * Relationships
     */
    'project'?: ProjectResource;
    'monument_item'?: ItemResource;
    'translations'?: Array<PartnerTranslationResource>;
    'images'?: Array<PartnerImageResource>;
    'collections'?: Array<CollectionResource>;
    /**
     * Visibility
     */
    'visible': boolean;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface PartnerShow200Response {
    'data': PartnerResource;
}
export interface PartnerTranslationImageIndex200Response {
    'data': Array<PartnerTranslationImageResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface PartnerTranslationImageResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * Foreign key
     */
    'partner_translation_id': string;
    /**
     * Image information
     */
    'path': string;
    'original_name': string;
    'mime_type': string;
    'size': number;
    'alt_text': string | null;
    'display_order': number;
    /**
     * Relationships
     */
    'partner_translation'?: PartnerTranslationResource;
    /**
     * Timestamps
     */
    'created_at': string | null;
    'updated_at': string | null;
}
export interface PartnerTranslationImageShow200Response {
    'data': PartnerTranslationImageResource;
}
export interface PartnerTranslationIndex200Response {
    'data': Array<PartnerTranslationResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface PartnerTranslationResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * Foreign keys
     */
    'partner_id': string;
    'language_id': string;
    'context_id': string;
    /**
     * Core partner info
     */
    'name': string;
    'description': string | null;
    /**
     * Address fields (embedded)
     */
    'city_display': string | null;
    'address_line_1': string | null;
    'address_line_2': string | null;
    'postal_code': string | null;
    'address_notes': string | null;
    /**
     * Contact fields (semi-structured)
     */
    'contact_name': string | null;
    'contact_email_general': string | null;
    'contact_email_press': string | null;
    'contact_phone': string | null;
    'contact_website': string | null;
    'contact_notes': string | null;
    'contact_emails': Array<any> | null;
    'contact_phones': Array<any> | null;
    /**
     * Relationships
     */
    'partner'?: PartnerResource;
    'language'?: LanguageResource;
    'context'?: ContextResource;
    'partner_translation_images'?: Array<PartnerTranslationImageResource>;
    /**
     * Metadata
     */
    'backward_compatibility': string | null;
    'extra': object | null;
    /**
     * Timestamps
     */
    'created_at': string | null;
    'updated_at': string | null;
}
export interface PartnerTranslationShow200Response {
    'data': PartnerTranslationResource;
}
export interface ProjectEnabled200Response {
    'data': Array<ProjectResource>;
}
export interface ProjectIndex200Response {
    'data': Array<ProjectResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface ProjectResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * Launch date of the project, nullable
     */
    'launch_date': string | null;
    /**
     * Indicates if the project has been launched already
     */
    'is_launched': boolean;
    /**
     * Indicates if the project is enabled (active)
     */
    'is_enabled': boolean;
    /**
     * The default context used within the project (ContextResource)
     */
    'context'?: ContextResource;
    /**
     * The default language used within the project (LanguageResource)
     */
    'language'?: LanguageResource;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface ProjectShow200Response {
    'data': ProjectResource;
}
export interface ProvinceIndex200Response {
    'data': Array<ProvinceResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface ProvinceResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The country this province belongs to (CountryResource id)
     */
    'country_id': string;
    /**
     * Translations for this province (ProvinceTranslationResource[])
     */
    'translations'?: Array<ProvinceTranslationResource>;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface ProvinceShow200Response {
    'data': ProvinceResource;
}
export interface ProvinceTranslationIndex200Response {
    'data': Array<ProvinceTranslationResource>;
}
export interface ProvinceTranslationResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The province this translation belongs to (ProvinceResource id)
     */
    'province_id': string;
    /**
     * The language of this translation (LanguageResource id)
     */
    'language_id': string;
    /**
     * The name of the province translation
     */
    'name': string;
    /**
     * The description of the province translation
     */
    'description': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface ProvinceTranslationShow200Response {
    'data': ProvinceTranslationResource;
}
export interface SetDefaultContextRequest {
    'is_default': boolean;
}
export interface SetDefaultLanguageRequest {
    'is_default': boolean;
}
export interface SetEnabledProjectRequest {
    'is_enabled': boolean;
}
export interface SetLaunchedProjectRequest {
    'is_launched': boolean;
}
export interface StoreCollectionImageRequest {
    'path': string;
    'original_name': string;
    'mime_type': string;
    'size': number;
    'alt_text'?: string | null;
    'display_order'?: number;
}
export interface StoreCollectionRequest {
    'internal_name': string;
    'type': StoreCollectionRequestTypeEnum;
    'language_id': string;
    'context_id': string;
    'parent_id'?: string | null;
    'backward_compatibility'?: string | null;
}

export const StoreCollectionRequestTypeEnum = {
    Collection: 'collection',
    Exhibition: 'exhibition',
    Gallery: 'gallery',
    Theme: 'theme',
    ExhibitionTrail: 'exhibition trail',
    Itinerary: 'itinerary',
    Location: 'location'
} as const;

export type StoreCollectionRequestTypeEnum = typeof StoreCollectionRequestTypeEnum[keyof typeof StoreCollectionRequestTypeEnum];

export interface StoreCollectionTranslationRequest {
    'id'?: string;
    'collection_id': string;
    'language_id': string;
    'context_id': string;
    'title': string;
    'description': string;
    'url'?: string | null;
    'backward_compatibility'?: string | null;
    'extra'?: string | null;
}
export interface StoreContextRequest {
    'id'?: string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
    'is_default'?: boolean;
}
export interface StoreCountryRequest {
    'id': string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
}
export interface StoreCountryTranslationRequest {
    'id'?: string;
    'country_id': string;
    'language_id': string;
    'name': string;
    'backward_compatibility'?: string | null;
    'extra'?: Array<string> | null;
}
export interface StoreGlossaryRequest {
    'id'?: string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
}
export interface StoreGlossarySpellingRequest {
    'id'?: string;
    'glossary_id': string;
    'language_id': string;
    'spelling': string;
}
export interface StoreGlossaryTranslationRequest {
    'id'?: string;
    'glossary_id': string;
    'language_id': string;
    'definition': string;
}
export interface StoreItemImageRequest {
    'path': string;
    'original_name': string;
    'mime_type': string;
    'size': number;
    'alt_text'?: string | null;
    'display_order'?: number;
}
export interface StoreItemItemLinkRequest {
    'id'?: string;
    'source_id': string;
    'target_id': string;
    'context_id': string;
    'created_at'?: string;
    'updated_at'?: string;
}
export interface StoreItemRequest {
    'id'?: string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
    'type': StoreItemRequestTypeEnum;
    'parent_id'?: string | null;
    'country_id'?: string | null;
    'partner_id'?: string | null;
    'project_id'?: string | null;
    'collection_id'?: string | null;
    'owner_reference'?: string | null;
    'mwnf_reference'?: string | null;
}

export const StoreItemRequestTypeEnum = {
    Object: 'object',
    Monument: 'monument',
    Detail: 'detail',
    Picture: 'picture'
} as const;

export type StoreItemRequestTypeEnum = typeof StoreItemRequestTypeEnum[keyof typeof StoreItemRequestTypeEnum];

export interface StoreItemTranslationRequest {
    'id'?: string;
    'item_id': string;
    'language_id': string;
    'context_id': string;
    'name': string;
    'alternate_name'?: string | null;
    'description': string;
    'type'?: string | null;
    'holder'?: string | null;
    'owner'?: string | null;
    'initial_owner'?: string | null;
    'dates'?: string | null;
    'location'?: string | null;
    'dimensions'?: string | null;
    'place_of_production'?: string | null;
    'method_for_datation'?: string | null;
    'method_for_provenance'?: string | null;
    'obtention'?: string | null;
    'bibliography'?: string | null;
    'author_id'?: string | null;
    'text_copy_editor_id'?: string | null;
    'translator_id'?: string | null;
    'translation_copy_editor_id'?: string | null;
    'backward_compatibility'?: string | null;
    'extra'?: string | null;
}
export interface StoreLanguageRequest {
    'id': string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
    'is_default'?: boolean;
}
export interface StoreLanguageTranslationRequest {
    'id'?: string;
    'language_id': string;
    'display_language_id': string;
    'name': string;
    'backward_compatibility'?: string | null;
    'extra'?: Array<string> | null;
}
export interface StoreLocationRequest {
    'internal_name': string;
    'country_id': number;
    'backward_compatibility'?: string | null;
    'translations': Array<StoreLocationRequestTranslationsInner>;
}
export interface StoreLocationRequestTranslationsInner {
    'language_id': number;
    'name': string;
}
export interface StoreLocationTranslationRequest {
    'location_id': string;
    'language_id': string;
    'name': string;
    'description'?: string | null;
}
export interface StorePartnerImageRequest {
    'id'?: string;
    'partner_id': string;
    'path': string;
    'original_name': string;
    'mime_type': string;
    'size': number;
    'alt_text'?: string | null;
    'display_order': number;
}
export interface StorePartnerRequest {
    'id'?: string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
    'type': StorePartnerRequestTypeEnum;
    'country_id'?: string | null;
    /**
     * GPS Location
     */
    'latitude'?: number | null;
    'longitude'?: number | null;
    'map_zoom'?: number | null;
    /**
     * Relationships
     */
    'project_id'?: string | null;
    'monument_item_id'?: string | null;
    /**
     * Visibility
     */
    'visible'?: boolean;
}

export const StorePartnerRequestTypeEnum = {
    Museum: 'museum',
    Institution: 'institution',
    Individual: 'individual'
} as const;

export type StorePartnerRequestTypeEnum = typeof StorePartnerRequestTypeEnum[keyof typeof StorePartnerRequestTypeEnum];

export interface StorePartnerTranslationImageRequest {
    'id'?: string;
    'partner_translation_id': string;
    'path': string;
    'original_name': string;
    'mime_type': string;
    'size': number;
    'alt_text'?: string | null;
    'display_order': number;
}
export interface StorePartnerTranslationRequest {
    'id'?: string;
    'partner_id': string;
    'language_id': string;
    'context_id': string;
    'name': string;
    'description'?: string | null;
    /**
     * Address fields
     */
    'city_display'?: string | null;
    'address_line_1'?: string | null;
    'address_line_2'?: string | null;
    'postal_code'?: string | null;
    'address_notes'?: string | null;
    /**
     * Contact fields
     */
    'contact_name'?: string | null;
    'contact_email_general'?: string | null;
    'contact_email_press'?: string | null;
    'contact_phone'?: string | null;
    'contact_website'?: string | null;
    'contact_notes'?: string | null;
    /**
     * Metadata
     */
    'backward_compatibility'?: string | null;
    'extra'?: Array<string> | null;
    'contact_emails'?: Array<string> | null;
    'contact_phones'?: Array<string> | null;
}
export interface StoreProjectRequest {
    'id'?: string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
    'launch_date'?: string | null;
    'is_launched'?: boolean;
    'is_enabled'?: boolean;
    'context_id'?: string | null;
    'language_id'?: string | null;
}
export interface StoreProvinceRequest {
    'internal_name': string;
    'country_id': number;
    'backward_compatibility'?: string | null;
    'translations': Array<StoreLocationRequestTranslationsInner>;
}
export interface StoreProvinceTranslationRequest {
    'province_id': string;
    'language_id': string;
    'name': string;
    'description'?: string | null;
}
export interface StoreTagRequest {
    'id'?: string;
    'internal_name': string;
    'category'?: StoreTagRequestCategoryEnum | null;
    'language_id'?: string | null;
    'backward_compatibility'?: string | null;
    'description': string;
}

export const StoreTagRequestCategoryEnum = {
    Keyword: 'keyword',
    Material: 'material',
    Artist: 'artist',
    Dynasty: 'dynasty'
} as const;

export type StoreTagRequestCategoryEnum = typeof StoreTagRequestCategoryEnum[keyof typeof StoreTagRequestCategoryEnum];

export interface StoreThemeRequest {
    'exhibition_id': string;
    'parent_id'?: string | null;
    'internal_name': string;
    'backward_compatibility'?: string | null;
}
export interface StoreThemeTranslationRequest {
    'theme_id': string;
    'language_id': string;
    'context_id': string;
    'title': string;
    'description': string;
    'introduction': string;
    'backward_compatibility'?: string | null;
    'extra'?: string | null;
}
export interface TagForItem200Response {
    'data': Array<TagResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface TagResource {
    /**
     * The unique identifier of the tag (GUID)
     */
    'id': string;
    /**
     * The name of the tag, it shall only be used internally
     */
    'internal_name': string;
    /**
     * The category of the tag (keyword, material, artist, dynasty), nullable
     */
    'category': string | null;
    /**
     * The language of the tag (ISO 639-3 code), nullable
     */
    'language_id': string | null;
    /**
     * The legacy Id when this tag corresponds to a legacy tag from the previous database, nullable
     */
    'backward_compatibility': string | null;
    /**
     * The description of the tag
     */
    'description': string;
    /**
     * Date of creation
     */
    'created_at': string | null;
    /**
     * Date of last modification
     */
    'updated_at': string | null;
}
export interface TagShow200Response {
    'data': TagResource;
}
export interface ThemeIndex200Response {
    'data': Array<ThemeResource>;
    'links': AvailableImageIndex200ResponseLinks;
    'meta': AvailableImageIndex200ResponseMeta;
}
export interface ThemeResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The exhibition this theme belongs to (ExhibitionResource id)
     */
    'exhibition_id': string;
    /**
     * The parent theme of this theme (ThemeResource id)
     */
    'parent_id': string | null;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * Translations for this theme (ThemeTranslationResource[])
     */
    'translations'?: Array<ThemeTranslationResource>;
    /**
     * Subthemes of this theme (ThemeResource[])
     */
    'subthemes'?: Array<ThemeResource>;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface ThemeShow200Response {
    'data': ThemeResource;
}
export interface ThemeTranslationResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The theme this translation belongs to (ThemeResource id)
     */
    'theme_id': string;
    /**
     * The language of this translation (LanguageResource id)
     */
    'language_id': string;
    /**
     * The context of this translation (ContextResource id)
     */
    'context_id': string;
    /**
     * The title of the theme translation
     */
    'title': string;
    /**
     * The description of the theme translation
     */
    'description': string;
    /**
     * The introduction of the theme translation
     */
    'introduction': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * Extra data for translation (object, may be null)
     */
    'extra': object | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
}
export interface ThemeTranslationShow200Response {
    'data': ThemeTranslationResource;
}
export interface TokenAcquire201Response {
    'token': string | null;
    'user': TokenAcquire201ResponseUser;
}
export interface TokenAcquire201ResponseUser {
}
export interface TokenAcquire202Response {
    'requires_two_factor': MarkdownPreview422ResponseSuccess;
    'available_methods': TokenAcquire202ResponseAvailableMethods;
    'primary_method': string | null;
    'message': TokenAcquire202ResponseMessage;
}
export interface TokenAcquire202ResponseAvailableMethods {
}
export interface TokenAcquire202ResponseMessage {
}
export interface TokenTwoFactorStatus200Response {
    'data': TwoFactorStatusResource;
}
export interface TokenVerifyTwoFactor201Response {
    'token': string | null;
    'user': TokenAcquire202ResponseAvailableMethods;
}
export interface TwoFactorStatusMobileAppAuthenticationRequest {
    'email': string;
    'password': string;
}
export interface TwoFactorStatusResource {
    'two_factor_enabled': MarkdownPreview422ResponseSuccess;
    'available_methods': TokenAcquire202ResponseAvailableMethods;
    'primary_method': string | null;
    'requires_two_factor': MarkdownPreview422ResponseSuccess;
}
export interface UpdateAvailableImageRequest {
    'id'?: string;
    'path'?: string;
    'comment'?: string | null;
}
export interface UpdateCollectionImageRequest {
    /**
     * Path and collection_id are immutable - not allowed in updates
     */
    'original_name'?: string;
    'mime_type'?: string;
    'size'?: number;
    'alt_text'?: string | null;
    'display_order'?: number;
    'include'?: string;
}
export interface UpdateCollectionRequest {
    'internal_name'?: string;
    'type'?: UpdateCollectionRequestTypeEnum;
    'language_id'?: string;
    'context_id'?: string;
    'parent_id'?: string | null;
    'backward_compatibility'?: string | null;
}

export const UpdateCollectionRequestTypeEnum = {
    Collection: 'collection',
    Exhibition: 'exhibition',
    Gallery: 'gallery',
    Theme: 'theme',
    ExhibitionTrail: 'exhibition trail',
    Itinerary: 'itinerary',
    Location: 'location'
} as const;

export type UpdateCollectionRequestTypeEnum = typeof UpdateCollectionRequestTypeEnum[keyof typeof UpdateCollectionRequestTypeEnum];

export interface UpdateCollectionTranslationRequest {
    'id'?: string;
    'collection_id'?: string;
    'language_id'?: string;
    'context_id'?: string;
    'title'?: string;
    'description'?: string;
    'url'?: string | null;
    'backward_compatibility'?: string | null;
    'extra'?: string | null;
}
export interface UpdateContextRequest {
    'id'?: string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
    'is_default'?: boolean;
}
export interface UpdateCountryRequest {
    'id'?: string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
}
export interface UpdateCountryTranslationRequest {
    'id'?: string;
    'country_id'?: string;
    'language_id'?: string;
    'name'?: string;
    'backward_compatibility'?: string | null;
    'extra'?: Array<string> | null;
}
export interface UpdateGlossaryRequest {
    'id'?: string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
}
export interface UpdateGlossarySpellingRequest {
    'id'?: string;
    'glossary_id'?: string;
    'language_id'?: string;
    'spelling'?: string;
}
export interface UpdateGlossaryTranslationRequest {
    'id'?: string;
    'glossary_id'?: string;
    'language_id'?: string;
    'definition'?: string;
}
export interface UpdateItemImageRequest {
    /**
     * Path and item_id are immutable - not allowed in updates
     */
    'original_name'?: string;
    'mime_type'?: string;
    'size'?: number;
    'alt_text'?: string | null;
    'display_order'?: number;
    'include'?: string;
}
export interface UpdateItemItemLinkRequest {
    'id'?: string;
    'source_id': string;
    'target_id': string;
    'context_id': string;
    'created_at'?: string;
    'updated_at'?: string;
}
export interface UpdateItemRequest {
    'id'?: string;
    'internal_name'?: string;
    'backward_compatibility'?: string | null;
    'type'?: UpdateItemRequestTypeEnum;
    'parent_id'?: string | null;
    'country_id'?: string | null;
    'partner_id'?: string | null;
    'project_id'?: string | null;
    'collection_id'?: string | null;
    'owner_reference'?: string | null;
    'mwnf_reference'?: string | null;
}

export const UpdateItemRequestTypeEnum = {
    Object: 'object',
    Monument: 'monument',
    Detail: 'detail',
    Picture: 'picture'
} as const;

export type UpdateItemRequestTypeEnum = typeof UpdateItemRequestTypeEnum[keyof typeof UpdateItemRequestTypeEnum];

export interface UpdateItemTranslationRequest {
    'id'?: string;
    'item_id'?: string;
    'language_id'?: string;
    'context_id'?: string;
    'name'?: string;
    'alternate_name'?: string | null;
    'description'?: string;
    'type'?: string | null;
    'holder'?: string | null;
    'owner'?: string | null;
    'initial_owner'?: string | null;
    'dates'?: string | null;
    'location'?: string | null;
    'dimensions'?: string | null;
    'place_of_production'?: string | null;
    'method_for_datation'?: string | null;
    'method_for_provenance'?: string | null;
    'obtention'?: string | null;
    'bibliography'?: string | null;
    'author_id'?: string | null;
    'text_copy_editor_id'?: string | null;
    'translator_id'?: string | null;
    'translation_copy_editor_id'?: string | null;
    'backward_compatibility'?: string | null;
    'extra'?: string | null;
}
export interface UpdateLanguageRequest {
    'id'?: string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
    'is_default'?: boolean;
}
export interface UpdateLanguageTranslationRequest {
    'id'?: string;
    'language_id'?: string;
    'display_language_id'?: string;
    'name'?: string;
    'backward_compatibility'?: string | null;
    'extra'?: Array<string> | null;
}
export interface UpdateLocationRequest {
    'internal_name': string;
    'country_id': number;
    'backward_compatibility'?: string | null;
    'translations'?: Array<UpdateLocationRequestTranslationsInner>;
}
export interface UpdateLocationRequestTranslationsInner {
    'language_id'?: number;
    'name'?: string;
}
export interface UpdateLocationTranslationRequest {
    'location_id'?: string;
    'language_id'?: string;
    'name'?: string;
    'description'?: string | null;
}
export interface UpdatePartnerImageRequest {
    'id'?: string;
    'partner_id': string;
    'path': string;
    'original_name': string;
    'mime_type': string;
    'size': number;
    'alt_text'?: string | null;
    'display_order': number;
}
export interface UpdatePartnerRequest {
    'id'?: string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
    'type': UpdatePartnerRequestTypeEnum;
    'country_id'?: string | null;
    /**
     * GPS Location
     */
    'latitude'?: number | null;
    'longitude'?: number | null;
    'map_zoom'?: number | null;
    /**
     * Relationships
     */
    'project_id'?: string | null;
    'monument_item_id'?: string | null;
    /**
     * Visibility
     */
    'visible'?: boolean;
}

export const UpdatePartnerRequestTypeEnum = {
    Museum: 'museum',
    Institution: 'institution',
    Individual: 'individual'
} as const;

export type UpdatePartnerRequestTypeEnum = typeof UpdatePartnerRequestTypeEnum[keyof typeof UpdatePartnerRequestTypeEnum];

export interface UpdatePartnerTranslationImageRequest {
    'id'?: string;
    'partner_translation_id': string;
    'path': string;
    'original_name': string;
    'mime_type': string;
    'size': number;
    'alt_text'?: string | null;
    'display_order': number;
}
export interface UpdatePartnerTranslationRequest {
    'id'?: string;
    'partner_id': string;
    'language_id': string;
    'context_id': string;
    'name': string;
    'description'?: string | null;
    /**
     * Address fields
     */
    'city_display'?: string | null;
    'address_line_1'?: string | null;
    'address_line_2'?: string | null;
    'postal_code'?: string | null;
    'address_notes'?: string | null;
    /**
     * Contact fields
     */
    'contact_name'?: string | null;
    'contact_email_general'?: string | null;
    'contact_email_press'?: string | null;
    'contact_phone'?: string | null;
    'contact_website'?: string | null;
    'contact_notes'?: string | null;
    /**
     * Metadata
     */
    'backward_compatibility'?: string | null;
    'extra'?: Array<string> | null;
    'contact_emails'?: Array<string> | null;
    'contact_phones'?: Array<string> | null;
}
export interface UpdateProjectRequest {
    'id'?: string;
    'internal_name': string;
    'backward_compatibility'?: string | null;
    'launch_date'?: string | null;
    'is_launched'?: boolean;
    'is_enabled'?: boolean;
    'context_id'?: string | null;
    'language_id'?: string | null;
}
export interface UpdateProvinceRequest {
    'internal_name': string;
    'country_id': number;
    'backward_compatibility'?: string | null;
    'translations'?: Array<UpdateLocationRequestTranslationsInner>;
}
export interface UpdateProvinceTranslationRequest {
    'province_id'?: string;
    'language_id'?: string;
    'name'?: string;
    'description'?: string | null;
}
export interface UpdateTagRequest {
    'id'?: string;
    'internal_name': string;
    'category'?: UpdateTagRequestCategoryEnum | null;
    'language_id'?: string | null;
    'backward_compatibility'?: string | null;
    'description': string;
}

export const UpdateTagRequestCategoryEnum = {
    Keyword: 'keyword',
    Material: 'material',
    Artist: 'artist',
    Dynasty: 'dynasty'
} as const;

export type UpdateTagRequestCategoryEnum = typeof UpdateTagRequestCategoryEnum[keyof typeof UpdateTagRequestCategoryEnum];

export interface UpdateTagsItemRequest {
    'attach'?: Array<string>;
    'detach'?: Array<string>;
}
export interface UpdateThemeRequest {
    'internal_name'?: string;
    'backward_compatibility'?: string | null;
}
export interface UpdateThemeTranslationRequest {
    'theme_id'?: string;
    'language_id'?: string;
    'context_id'?: string;
    'title'?: string;
    'description'?: string;
    'introduction'?: string;
    'backward_compatibility'?: string | null;
    'extra'?: string | null;
}
export interface User {
    'id': number;
    'name': string;
    'email': string;
    'email_verified_at': string | null;
    'two_factor_confirmed_at': string | null;
    'current_team_id': number | null;
    'profile_photo_path': string | null;
    'created_at': string | null;
    'updated_at': string | null;
    'profile_photo_url': string;
}
export interface UserPermissions200Response {
    'data': UserPermissionsResource;
}
export interface UserPermissionsResource {
    'permissions': TokenAcquire202ResponseAvailableMethods;
}
export interface VerifyTwoFactorMobileAppAuthenticationRequest {
    'email': string;
    'password': string;
    'device_name': string;
    'code': string;
    'method'?: VerifyTwoFactorMobileAppAuthenticationRequestMethodEnum;
    'wipe_tokens'?: boolean;
}

export const VerifyTwoFactorMobileAppAuthenticationRequestMethodEnum = {
    Totp: 'totp',
    Email: 'email'
} as const;

export type VerifyTwoFactorMobileAppAuthenticationRequestMethodEnum = typeof VerifyTwoFactorMobileAppAuthenticationRequestMethodEnum[keyof typeof VerifyTwoFactorMobileAppAuthenticationRequestMethodEnum];

export interface WithAllTagsItemRequest {
    'include'?: string;
    'tags': Array<string>;
}
export interface WithAnyTagsItemRequest {
    'include'?: string;
    'tags': Array<string>;
}
export interface WorkshopResource {
    /**
     * The unique identifier (GUID)
     */
    'id': string;
    /**
     * The name of the workshop
     */
    'name': string;
    /**
     * A name for this resource, for internal use only.
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     */
    'backward_compatibility': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     */
    'updated_at': string | null;
    /**
     * Items associated with this workshop (ItemResource[])
     */
    'items'?: Array<ItemResource>;
}

/**
 * AvailableImageApi - axios parameter creator
 */
export const AvailableImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageDestroy: async (availableImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageDestroy', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download the file to the caller
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageDownload: async (availableImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageDownload', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}/download`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/available-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageShow: async (availableImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageShow', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} availableImage The available image ID
         * @param {UpdateAvailableImageRequest} [updateAvailableImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageUpdate: async (availableImage: string, updateAvailableImageRequest?: UpdateAvailableImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageUpdate', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAvailableImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} availableImage The available image ID
         * @param {UpdateAvailableImageRequest} [updateAvailableImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageUpdate3: async (availableImage: string, updateAvailableImageRequest?: UpdateAvailableImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageUpdate3', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAvailableImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageView: async (availableImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageView', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}/view`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AvailableImageApi - functional programming interface
 */
export const AvailableImageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AvailableImageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageDestroy(availableImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageDestroy(availableImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download the file to the caller
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageDownload(availableImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageDownload(availableImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageDownload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableImageIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageShow(availableImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageShow(availableImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} availableImage The available image ID
         * @param {UpdateAvailableImageRequest} [updateAvailableImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageUpdate(availableImage: string, updateAvailableImageRequest?: UpdateAvailableImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageUpdate(availableImage, updateAvailableImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} availableImage The available image ID
         * @param {UpdateAvailableImageRequest} [updateAvailableImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageUpdate3(availableImage: string, updateAvailableImageRequest?: UpdateAvailableImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageUpdate3(availableImage, updateAvailableImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageUpdate3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageView(availableImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageView(availableImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AvailableImageApi - factory interface
 */
export const AvailableImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AvailableImageApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageDestroy(availableImage: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.availableImageDestroy(availableImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download the file to the caller
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageDownload(availableImage: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.availableImageDownload(availableImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<AvailableImageIndex200Response> {
            return localVarFp.availableImageIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageShow(availableImage: string, options?: RawAxiosRequestConfig): AxiosPromise<AvailableImageShow200Response> {
            return localVarFp.availableImageShow(availableImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} availableImage The available image ID
         * @param {UpdateAvailableImageRequest} [updateAvailableImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageUpdate(availableImage: string, updateAvailableImageRequest?: UpdateAvailableImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<AvailableImageShow200Response> {
            return localVarFp.availableImageUpdate(availableImage, updateAvailableImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} availableImage The available image ID
         * @param {UpdateAvailableImageRequest} [updateAvailableImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageUpdate3(availableImage: string, updateAvailableImageRequest?: UpdateAvailableImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<AvailableImageShow200Response> {
            return localVarFp.availableImageUpdate3(availableImage, updateAvailableImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageView(availableImage: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.availableImageView(availableImage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AvailableImageApi - object-oriented interface
 */
export class AvailableImageApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} availableImage The available image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public availableImageDestroy(availableImage: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageDestroy(availableImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download the file to the caller
     * @param {string} availableImage The available image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public availableImageDownload(availableImage: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageDownload(availableImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public availableImageIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} availableImage The available image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public availableImageShow(availableImage: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageShow(availableImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} availableImage The available image ID
     * @param {UpdateAvailableImageRequest} [updateAvailableImageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public availableImageUpdate(availableImage: string, updateAvailableImageRequest?: UpdateAvailableImageRequest, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageUpdate(availableImage, updateAvailableImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} availableImage The available image ID
     * @param {UpdateAvailableImageRequest} [updateAvailableImageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public availableImageUpdate3(availableImage: string, updateAvailableImageRequest?: UpdateAvailableImageRequest, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageUpdate3(availableImage, updateAvailableImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
     * @param {string} availableImage The available image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public availableImageView(availableImage: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageView(availableImage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CollectionApi - axios parameter creator
 */
export const CollectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Attach an item to a collection via many-to-many relationship
         * @param {string} collection The collection ID
         * @param {AttachItemCollectionRequest} attachItemCollectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionAttachItem: async (collection: string, attachItemCollectionRequest: AttachItemCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionAttachItem', 'collection', collection)
            // verify required parameter 'attachItemCollectionRequest' is not null or undefined
            assertParamExists('collectionAttachItem', 'attachItemCollectionRequest', attachItemCollectionRequest)
            const localVarPath = `/collection/{collection}/attach-item`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachItemCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Attach multiple items to a collection
         * @param {string} collection The collection ID
         * @param {AttachItemsCollectionRequest} attachItemsCollectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionAttachItems: async (collection: string, attachItemsCollectionRequest: AttachItemsCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionAttachItems', 'collection', collection)
            // verify required parameter 'attachItemsCollectionRequest' is not null or undefined
            assertParamExists('collectionAttachItems', 'attachItemsCollectionRequest', attachItemsCollectionRequest)
            const localVarPath = `/collection/{collection}/attach-items`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachItemsCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get collections by type
         * @param {string} type 
         * @param {CollectionByTypeTypeEnum} type2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionByType: async (type: string, type2: CollectionByTypeTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('collectionByType', 'type', type)
            // verify required parameter 'type2' is not null or undefined
            assertParamExists('collectionByType', 'type2', type2)
            const localVarPath = `/collection/type/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type2 !== undefined) {
                localVarQueryParameter['type'] = type2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified collection from storage
         * @param {string} collection The collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionDestroy: async (collection: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionDestroy', 'collection', collection)
            const localVarPath = `/collection/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach an item from a collection
         * @param {string} collection The collection ID
         * @param {string} itemId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionDetachItem: async (collection: string, itemId: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionDetachItem', 'collection', collection)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('collectionDetachItem', 'itemId', itemId)
            const localVarPath = `/collection/{collection}/detach-item`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (itemId !== undefined) {
                localVarQueryParameter['item_id'] = itemId;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach multiple items from a collection
         * @param {string} collection The collection ID
         * @param {Array<string>} itemIds 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionDetachItems: async (collection: string, itemIds: Array<string>, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionDetachItems', 'collection', collection)
            // verify required parameter 'itemIds' is not null or undefined
            assertParamExists('collectionDetachItems', 'itemIds', itemIds)
            const localVarPath = `/collection/{collection}/detach-items`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (itemIds) {
                localVarQueryParameter['item_ids[]'] = itemIds;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the collections
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified collection
         * @param {string} collection The collection ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionShow: async (collection: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionShow', 'collection', collection)
            const localVarPath = `/collection/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created collection in storage
         * @param {StoreCollectionRequest} storeCollectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionStore: async (storeCollectionRequest: StoreCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeCollectionRequest' is not null or undefined
            assertParamExists('collectionStore', 'storeCollectionRequest', storeCollectionRequest)
            const localVarPath = `/collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified collection in storage
         * @param {string} collection The collection ID
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionUpdate: async (collection: string, updateCollectionRequest?: UpdateCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionUpdate', 'collection', collection)
            const localVarPath = `/collection/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified collection in storage
         * @param {string} collection The collection ID
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionUpdate2: async (collection: string, updateCollectionRequest?: UpdateCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionUpdate2', 'collection', collection)
            const localVarPath = `/collection/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionApi - functional programming interface
 */
export const CollectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Attach an item to a collection via many-to-many relationship
         * @param {string} collection The collection ID
         * @param {AttachItemCollectionRequest} attachItemCollectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionAttachItem(collection: string, attachItemCollectionRequest: AttachItemCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionAttachItem(collection, attachItemCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionAttachItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Attach multiple items to a collection
         * @param {string} collection The collection ID
         * @param {AttachItemsCollectionRequest} attachItemsCollectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionAttachItems(collection: string, attachItemsCollectionRequest: AttachItemsCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionAttachItems(collection, attachItemsCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionAttachItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get collections by type
         * @param {string} type 
         * @param {CollectionByTypeTypeEnum} type2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionByType(type: string, type2: CollectionByTypeTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionByType200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionByType(type, type2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionByType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified collection from storage
         * @param {string} collection The collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionDestroy(collection: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionDestroy(collection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Detach an item from a collection
         * @param {string} collection The collection ID
         * @param {string} itemId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionDetachItem(collection: string, itemId: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionDetachItem(collection, itemId, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionDetachItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Detach multiple items from a collection
         * @param {string} collection The collection ID
         * @param {Array<string>} itemIds 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionDetachItems(collection: string, itemIds: Array<string>, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionDetachItems(collection, itemIds, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionDetachItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the collections
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified collection
         * @param {string} collection The collection ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionShow(collection: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionShow(collection, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created collection in storage
         * @param {StoreCollectionRequest} storeCollectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionStore(storeCollectionRequest: StoreCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionStore(storeCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified collection in storage
         * @param {string} collection The collection ID
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionUpdate(collection: string, updateCollectionRequest?: UpdateCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionUpdate(collection, updateCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified collection in storage
         * @param {string} collection The collection ID
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionUpdate2(collection: string, updateCollectionRequest?: UpdateCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionUpdate2(collection, updateCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CollectionApi - factory interface
 */
export const CollectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionApiFp(configuration)
    return {
        /**
         * 
         * @summary Attach an item to a collection via many-to-many relationship
         * @param {string} collection The collection ID
         * @param {AttachItemCollectionRequest} attachItemCollectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionAttachItem(collection: string, attachItemCollectionRequest: AttachItemCollectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionShow200Response> {
            return localVarFp.collectionAttachItem(collection, attachItemCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Attach multiple items to a collection
         * @param {string} collection The collection ID
         * @param {AttachItemsCollectionRequest} attachItemsCollectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionAttachItems(collection: string, attachItemsCollectionRequest: AttachItemsCollectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionShow200Response> {
            return localVarFp.collectionAttachItems(collection, attachItemsCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get collections by type
         * @param {string} type 
         * @param {CollectionByTypeTypeEnum} type2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionByType(type: string, type2: CollectionByTypeTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<CollectionByType200Response> {
            return localVarFp.collectionByType(type, type2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified collection from storage
         * @param {string} collection The collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionDestroy(collection: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.collectionDestroy(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detach an item from a collection
         * @param {string} collection The collection ID
         * @param {string} itemId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionDetachItem(collection: string, itemId: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionShow200Response> {
            return localVarFp.collectionDetachItem(collection, itemId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detach multiple items from a collection
         * @param {string} collection The collection ID
         * @param {Array<string>} itemIds 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionDetachItems(collection: string, itemIds: Array<string>, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionShow200Response> {
            return localVarFp.collectionDetachItems(collection, itemIds, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the collections
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionIndex200Response> {
            return localVarFp.collectionIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified collection
         * @param {string} collection The collection ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionShow(collection: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionShow200Response> {
            return localVarFp.collectionShow(collection, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created collection in storage
         * @param {StoreCollectionRequest} storeCollectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionStore(storeCollectionRequest: StoreCollectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionShow200Response> {
            return localVarFp.collectionStore(storeCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified collection in storage
         * @param {string} collection The collection ID
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionUpdate(collection: string, updateCollectionRequest?: UpdateCollectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionShow200Response> {
            return localVarFp.collectionUpdate(collection, updateCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified collection in storage
         * @param {string} collection The collection ID
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionUpdate2(collection: string, updateCollectionRequest?: UpdateCollectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionShow200Response> {
            return localVarFp.collectionUpdate2(collection, updateCollectionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionApi - object-oriented interface
 */
export class CollectionApi extends BaseAPI {
    /**
     * 
     * @summary Attach an item to a collection via many-to-many relationship
     * @param {string} collection The collection ID
     * @param {AttachItemCollectionRequest} attachItemCollectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionAttachItem(collection: string, attachItemCollectionRequest: AttachItemCollectionRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionAttachItem(collection, attachItemCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Attach multiple items to a collection
     * @param {string} collection The collection ID
     * @param {AttachItemsCollectionRequest} attachItemsCollectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionAttachItems(collection: string, attachItemsCollectionRequest: AttachItemsCollectionRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionAttachItems(collection, attachItemsCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get collections by type
     * @param {string} type 
     * @param {CollectionByTypeTypeEnum} type2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionByType(type: string, type2: CollectionByTypeTypeEnum, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionByType(type, type2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified collection from storage
     * @param {string} collection The collection ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionDestroy(collection: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionDestroy(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detach an item from a collection
     * @param {string} collection The collection ID
     * @param {string} itemId 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionDetachItem(collection: string, itemId: string, include?: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionDetachItem(collection, itemId, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detach multiple items from a collection
     * @param {string} collection The collection ID
     * @param {Array<string>} itemIds 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionDetachItems(collection: string, itemIds: Array<string>, include?: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionDetachItems(collection, itemIds, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the collections
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified collection
     * @param {string} collection The collection ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionShow(collection: string, include?: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionShow(collection, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created collection in storage
     * @param {StoreCollectionRequest} storeCollectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionStore(storeCollectionRequest: StoreCollectionRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionStore(storeCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified collection in storage
     * @param {string} collection The collection ID
     * @param {UpdateCollectionRequest} [updateCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionUpdate(collection: string, updateCollectionRequest?: UpdateCollectionRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionUpdate(collection, updateCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified collection in storage
     * @param {string} collection The collection ID
     * @param {UpdateCollectionRequest} [updateCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionUpdate2(collection: string, updateCollectionRequest?: UpdateCollectionRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionUpdate2(collection, updateCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const CollectionByTypeTypeEnum = {
    Collection: 'collection',
    Exhibition: 'exhibition',
    Gallery: 'gallery',
    Theme: 'theme',
    ExhibitionTrail: 'exhibition trail',
    Itinerary: 'itinerary',
    Location: 'location'
} as const;
export type CollectionByTypeTypeEnum = typeof CollectionByTypeTypeEnum[keyof typeof CollectionByTypeTypeEnum];


/**
 * CollectionImageApi - axios parameter creator
 */
export const CollectionImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Attach an available image to a collection
         * @param {string} collection The collection ID
         * @param {AttachFromAvailableCollectionImageRequest} attachFromAvailableCollectionImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionAttachImage: async (collection: string, attachFromAvailableCollectionImageRequest: AttachFromAvailableCollectionImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionAttachImage', 'collection', collection)
            // verify required parameter 'attachFromAvailableCollectionImageRequest' is not null or undefined
            assertParamExists('collectionAttachImage', 'attachFromAvailableCollectionImageRequest', attachFromAvailableCollectionImageRequest)
            const localVarPath = `/collection/{collection}/attach-image`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachFromAvailableCollectionImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified collection image
         * @param {string} collectionImage The collection image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImageDestroy: async (collectionImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionImage' is not null or undefined
            assertParamExists('collectionImageDestroy', 'collectionImage', collectionImage)
            const localVarPath = `/collection-image/{collectionImage}`
                .replace(`{${"collectionImage"}}`, encodeURIComponent(String(collectionImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach a collection image and convert it back to available image
         * @param {string} collectionImage The collection image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImageDetach: async (collectionImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionImage' is not null or undefined
            assertParamExists('collectionImageDetach', 'collectionImage', collectionImage)
            const localVarPath = `/collection-image/{collectionImage}/detach`
                .replace(`{${"collectionImage"}}`, encodeURIComponent(String(collectionImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} collectionImage The collection image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImageDownload: async (collectionImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionImage' is not null or undefined
            assertParamExists('collectionImageDownload', 'collectionImage', collectionImage)
            const localVarPath = `/collection-image/{collectionImage}/download`
                .replace(`{${"collectionImage"}}`, encodeURIComponent(String(collectionImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move collection image down in display order
         * @param {string} collectionImage The collection image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImageMoveDown: async (collectionImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionImage' is not null or undefined
            assertParamExists('collectionImageMoveDown', 'collectionImage', collectionImage)
            const localVarPath = `/collection-image/{collectionImage}/move-down`
                .replace(`{${"collectionImage"}}`, encodeURIComponent(String(collectionImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move collection image up in display order
         * @param {string} collectionImage The collection image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImageMoveUp: async (collectionImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionImage' is not null or undefined
            assertParamExists('collectionImageMoveUp', 'collectionImage', collectionImage)
            const localVarPath = `/collection-image/{collectionImage}/move-up`
                .replace(`{${"collectionImage"}}`, encodeURIComponent(String(collectionImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified collection image
         * @param {string} collectionImage The collection image ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImageShow: async (collectionImage: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionImage' is not null or undefined
            assertParamExists('collectionImageShow', 'collectionImage', collectionImage)
            const localVarPath = `/collection-image/{collectionImage}`
                .replace(`{${"collectionImage"}}`, encodeURIComponent(String(collectionImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tighten ordering for all images of the collection
         * @param {string} collectionImage The collection image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImageTightenOrdering: async (collectionImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionImage' is not null or undefined
            assertParamExists('collectionImageTightenOrdering', 'collectionImage', collectionImage)
            const localVarPath = `/collection-image/{collectionImage}/tighten-ordering`
                .replace(`{${"collectionImage"}}`, encodeURIComponent(String(collectionImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified collection image
         * @param {string} collectionImage The collection image ID
         * @param {UpdateCollectionImageRequest} [updateCollectionImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImageUpdate: async (collectionImage: string, updateCollectionImageRequest?: UpdateCollectionImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionImage' is not null or undefined
            assertParamExists('collectionImageUpdate', 'collectionImage', collectionImage)
            const localVarPath = `/collection-image/{collectionImage}`
                .replace(`{${"collectionImage"}}`, encodeURIComponent(String(collectionImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCollectionImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified collection image
         * @param {string} collectionImage The collection image ID
         * @param {UpdateCollectionImageRequest} [updateCollectionImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImageUpdate2: async (collectionImage: string, updateCollectionImageRequest?: UpdateCollectionImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionImage' is not null or undefined
            assertParamExists('collectionImageUpdate2', 'collectionImage', collectionImage)
            const localVarPath = `/collection-image/{collectionImage}`
                .replace(`{${"collectionImage"}}`, encodeURIComponent(String(collectionImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCollectionImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} collectionImage The collection image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImageView: async (collectionImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionImage' is not null or undefined
            assertParamExists('collectionImageView', 'collectionImage', collectionImage)
            const localVarPath = `/collection-image/{collectionImage}/view`
                .replace(`{${"collectionImage"}}`, encodeURIComponent(String(collectionImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of collection images for a specific collection
         * @param {string} collection The collection ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImagesIndex: async (collection: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionImagesIndex', 'collection', collection)
            const localVarPath = `/collection/{collection}/images`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created collection image
         * @param {string} collection The collection ID
         * @param {StoreCollectionImageRequest} storeCollectionImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImagesStore: async (collection: string, storeCollectionImageRequest: StoreCollectionImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionImagesStore', 'collection', collection)
            // verify required parameter 'storeCollectionImageRequest' is not null or undefined
            assertParamExists('collectionImagesStore', 'storeCollectionImageRequest', storeCollectionImageRequest)
            const localVarPath = `/collection/{collection}/images`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeCollectionImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionImageApi - functional programming interface
 */
export const CollectionImageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionImageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Attach an available image to a collection
         * @param {string} collection The collection ID
         * @param {AttachFromAvailableCollectionImageRequest} attachFromAvailableCollectionImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionAttachImage(collection: string, attachFromAvailableCollectionImageRequest: AttachFromAvailableCollectionImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionAttachImage(collection, attachFromAvailableCollectionImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionImageApi.collectionAttachImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified collection image
         * @param {string} collectionImage The collection image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionImageDestroy(collectionImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionImageDestroy(collectionImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionImageApi.collectionImageDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Detach a collection image and convert it back to available image
         * @param {string} collectionImage The collection image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionImageDetach(collectionImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionImageTightenOrdering200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionImageDetach(collectionImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionImageApi.collectionImageDetach']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} collectionImage The collection image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionImageDownload(collectionImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionImageDownload(collectionImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionImageApi.collectionImageDownload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move collection image down in display order
         * @param {string} collectionImage The collection image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionImageMoveDown(collectionImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionImageMoveDown(collectionImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionImageApi.collectionImageMoveDown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move collection image up in display order
         * @param {string} collectionImage The collection image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionImageMoveUp(collectionImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionImageMoveUp(collectionImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionImageApi.collectionImageMoveUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified collection image
         * @param {string} collectionImage The collection image ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionImageShow(collectionImage: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionImageShow(collectionImage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionImageApi.collectionImageShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tighten ordering for all images of the collection
         * @param {string} collectionImage The collection image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionImageTightenOrdering(collectionImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionImageTightenOrdering200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionImageTightenOrdering(collectionImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionImageApi.collectionImageTightenOrdering']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified collection image
         * @param {string} collectionImage The collection image ID
         * @param {UpdateCollectionImageRequest} [updateCollectionImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionImageUpdate(collectionImage: string, updateCollectionImageRequest?: UpdateCollectionImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionImageUpdate(collectionImage, updateCollectionImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionImageApi.collectionImageUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified collection image
         * @param {string} collectionImage The collection image ID
         * @param {UpdateCollectionImageRequest} [updateCollectionImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionImageUpdate2(collectionImage: string, updateCollectionImageRequest?: UpdateCollectionImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionImageUpdate2(collectionImage, updateCollectionImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionImageApi.collectionImageUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} collectionImage The collection image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionImageView(collectionImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionImageView(collectionImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionImageApi.collectionImageView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of collection images for a specific collection
         * @param {string} collection The collection ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionImagesIndex(collection: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionImagesIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionImagesIndex(collection, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionImageApi.collectionImagesIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created collection image
         * @param {string} collection The collection ID
         * @param {StoreCollectionImageRequest} storeCollectionImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionImagesStore(collection: string, storeCollectionImageRequest: StoreCollectionImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionImagesStore(collection, storeCollectionImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionImageApi.collectionImagesStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CollectionImageApi - factory interface
 */
export const CollectionImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionImageApiFp(configuration)
    return {
        /**
         * 
         * @summary Attach an available image to a collection
         * @param {string} collection The collection ID
         * @param {AttachFromAvailableCollectionImageRequest} attachFromAvailableCollectionImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionAttachImage(collection: string, attachFromAvailableCollectionImageRequest: AttachFromAvailableCollectionImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionImagesStore200Response> {
            return localVarFp.collectionAttachImage(collection, attachFromAvailableCollectionImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified collection image
         * @param {string} collectionImage The collection image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImageDestroy(collectionImage: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.collectionImageDestroy(collectionImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detach a collection image and convert it back to available image
         * @param {string} collectionImage The collection image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImageDetach(collectionImage: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionImageTightenOrdering200Response> {
            return localVarFp.collectionImageDetach(collectionImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} collectionImage The collection image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImageDownload(collectionImage: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.collectionImageDownload(collectionImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move collection image down in display order
         * @param {string} collectionImage The collection image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImageMoveDown(collectionImage: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionImagesStore200Response> {
            return localVarFp.collectionImageMoveDown(collectionImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move collection image up in display order
         * @param {string} collectionImage The collection image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImageMoveUp(collectionImage: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionImagesStore200Response> {
            return localVarFp.collectionImageMoveUp(collectionImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified collection image
         * @param {string} collectionImage The collection image ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImageShow(collectionImage: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionImagesStore200Response> {
            return localVarFp.collectionImageShow(collectionImage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Tighten ordering for all images of the collection
         * @param {string} collectionImage The collection image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImageTightenOrdering(collectionImage: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionImageTightenOrdering200Response> {
            return localVarFp.collectionImageTightenOrdering(collectionImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified collection image
         * @param {string} collectionImage The collection image ID
         * @param {UpdateCollectionImageRequest} [updateCollectionImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImageUpdate(collectionImage: string, updateCollectionImageRequest?: UpdateCollectionImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionImagesStore200Response> {
            return localVarFp.collectionImageUpdate(collectionImage, updateCollectionImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified collection image
         * @param {string} collectionImage The collection image ID
         * @param {UpdateCollectionImageRequest} [updateCollectionImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImageUpdate2(collectionImage: string, updateCollectionImageRequest?: UpdateCollectionImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionImagesStore200Response> {
            return localVarFp.collectionImageUpdate2(collectionImage, updateCollectionImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} collectionImage The collection image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImageView(collectionImage: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.collectionImageView(collectionImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of collection images for a specific collection
         * @param {string} collection The collection ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImagesIndex(collection: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionImagesIndex200Response> {
            return localVarFp.collectionImagesIndex(collection, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created collection image
         * @param {string} collection The collection ID
         * @param {StoreCollectionImageRequest} storeCollectionImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionImagesStore(collection: string, storeCollectionImageRequest: StoreCollectionImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionImagesStore200Response> {
            return localVarFp.collectionImagesStore(collection, storeCollectionImageRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionImageApi - object-oriented interface
 */
export class CollectionImageApi extends BaseAPI {
    /**
     * 
     * @summary Attach an available image to a collection
     * @param {string} collection The collection ID
     * @param {AttachFromAvailableCollectionImageRequest} attachFromAvailableCollectionImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionAttachImage(collection: string, attachFromAvailableCollectionImageRequest: AttachFromAvailableCollectionImageRequest, options?: RawAxiosRequestConfig) {
        return CollectionImageApiFp(this.configuration).collectionAttachImage(collection, attachFromAvailableCollectionImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified collection image
     * @param {string} collectionImage The collection image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionImageDestroy(collectionImage: string, options?: RawAxiosRequestConfig) {
        return CollectionImageApiFp(this.configuration).collectionImageDestroy(collectionImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detach a collection image and convert it back to available image
     * @param {string} collectionImage The collection image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionImageDetach(collectionImage: string, options?: RawAxiosRequestConfig) {
        return CollectionImageApiFp(this.configuration).collectionImageDetach(collectionImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the file to the caller
     * @param {string} collectionImage The collection image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionImageDownload(collectionImage: string, options?: RawAxiosRequestConfig) {
        return CollectionImageApiFp(this.configuration).collectionImageDownload(collectionImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move collection image down in display order
     * @param {string} collectionImage The collection image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionImageMoveDown(collectionImage: string, options?: RawAxiosRequestConfig) {
        return CollectionImageApiFp(this.configuration).collectionImageMoveDown(collectionImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move collection image up in display order
     * @param {string} collectionImage The collection image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionImageMoveUp(collectionImage: string, options?: RawAxiosRequestConfig) {
        return CollectionImageApiFp(this.configuration).collectionImageMoveUp(collectionImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified collection image
     * @param {string} collectionImage The collection image ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionImageShow(collectionImage: string, include?: string, options?: RawAxiosRequestConfig) {
        return CollectionImageApiFp(this.configuration).collectionImageShow(collectionImage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Tighten ordering for all images of the collection
     * @param {string} collectionImage The collection image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionImageTightenOrdering(collectionImage: string, options?: RawAxiosRequestConfig) {
        return CollectionImageApiFp(this.configuration).collectionImageTightenOrdering(collectionImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified collection image
     * @param {string} collectionImage The collection image ID
     * @param {UpdateCollectionImageRequest} [updateCollectionImageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionImageUpdate(collectionImage: string, updateCollectionImageRequest?: UpdateCollectionImageRequest, options?: RawAxiosRequestConfig) {
        return CollectionImageApiFp(this.configuration).collectionImageUpdate(collectionImage, updateCollectionImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified collection image
     * @param {string} collectionImage The collection image ID
     * @param {UpdateCollectionImageRequest} [updateCollectionImageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionImageUpdate2(collectionImage: string, updateCollectionImageRequest?: UpdateCollectionImageRequest, options?: RawAxiosRequestConfig) {
        return CollectionImageApiFp(this.configuration).collectionImageUpdate2(collectionImage, updateCollectionImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
     * @param {string} collectionImage The collection image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionImageView(collectionImage: string, options?: RawAxiosRequestConfig) {
        return CollectionImageApiFp(this.configuration).collectionImageView(collectionImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of collection images for a specific collection
     * @param {string} collection The collection ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionImagesIndex(collection: string, include?: string, options?: RawAxiosRequestConfig) {
        return CollectionImageApiFp(this.configuration).collectionImagesIndex(collection, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created collection image
     * @param {string} collection The collection ID
     * @param {StoreCollectionImageRequest} storeCollectionImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionImagesStore(collection: string, storeCollectionImageRequest: StoreCollectionImageRequest, options?: RawAxiosRequestConfig) {
        return CollectionImageApiFp(this.configuration).collectionImagesStore(collection, storeCollectionImageRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CollectionTranslationApi - axios parameter creator
 */
export const CollectionTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationDestroy: async (collectionTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionTranslation' is not null or undefined
            assertParamExists('collectionTranslationDestroy', 'collectionTranslation', collectionTranslation)
            const localVarPath = `/collection-translation/{collectionTranslation}`
                .replace(`{${"collectionTranslation"}}`, encodeURIComponent(String(collectionTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of collection translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [collectionId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationIndex: async (page?: number, perPage?: number, collectionId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collection-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (collectionId !== undefined) {
                localVarQueryParameter['collection_id'] = collectionId;
            }

            if (languageId !== undefined) {
                localVarQueryParameter['language_id'] = languageId;
            }

            if (contextId !== undefined) {
                localVarQueryParameter['context_id'] = contextId;
            }

            if (defaultContext !== undefined) {
                localVarQueryParameter['default_context'] = defaultContext;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationShow: async (collectionTranslation: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionTranslation' is not null or undefined
            assertParamExists('collectionTranslationShow', 'collectionTranslation', collectionTranslation)
            const localVarPath = `/collection-translation/{collectionTranslation}`
                .replace(`{${"collectionTranslation"}}`, encodeURIComponent(String(collectionTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created collection translation
         * @param {StoreCollectionTranslationRequest} storeCollectionTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationStore: async (storeCollectionTranslationRequest: StoreCollectionTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeCollectionTranslationRequest' is not null or undefined
            assertParamExists('collectionTranslationStore', 'storeCollectionTranslationRequest', storeCollectionTranslationRequest)
            const localVarPath = `/collection-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeCollectionTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {UpdateCollectionTranslationRequest} [updateCollectionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationUpdate: async (collectionTranslation: string, updateCollectionTranslationRequest?: UpdateCollectionTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionTranslation' is not null or undefined
            assertParamExists('collectionTranslationUpdate', 'collectionTranslation', collectionTranslation)
            const localVarPath = `/collection-translation/{collectionTranslation}`
                .replace(`{${"collectionTranslation"}}`, encodeURIComponent(String(collectionTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCollectionTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {UpdateCollectionTranslationRequest} [updateCollectionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationUpdate2: async (collectionTranslation: string, updateCollectionTranslationRequest?: UpdateCollectionTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionTranslation' is not null or undefined
            assertParamExists('collectionTranslationUpdate2', 'collectionTranslation', collectionTranslation)
            const localVarPath = `/collection-translation/{collectionTranslation}`
                .replace(`{${"collectionTranslation"}}`, encodeURIComponent(String(collectionTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCollectionTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionTranslationApi - functional programming interface
 */
export const CollectionTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionTranslationDestroy(collectionTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionTranslationDestroy(collectionTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionTranslationApi.collectionTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of collection translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [collectionId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionTranslationIndex(page?: number, perPage?: number, collectionId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionTranslationIndex(page, perPage, collectionId, languageId, contextId, defaultContext, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionTranslationApi.collectionTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionTranslationShow(collectionTranslation: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionTranslationShow(collectionTranslation, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionTranslationApi.collectionTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created collection translation
         * @param {StoreCollectionTranslationRequest} storeCollectionTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionTranslationStore(storeCollectionTranslationRequest: StoreCollectionTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionTranslationStore(storeCollectionTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionTranslationApi.collectionTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {UpdateCollectionTranslationRequest} [updateCollectionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionTranslationUpdate(collectionTranslation: string, updateCollectionTranslationRequest?: UpdateCollectionTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionTranslationUpdate(collectionTranslation, updateCollectionTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionTranslationApi.collectionTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {UpdateCollectionTranslationRequest} [updateCollectionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionTranslationUpdate2(collectionTranslation: string, updateCollectionTranslationRequest?: UpdateCollectionTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionTranslationUpdate2(collectionTranslation, updateCollectionTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionTranslationApi.collectionTranslationUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CollectionTranslationApi - factory interface
 */
export const CollectionTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationDestroy(collectionTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.collectionTranslationDestroy(collectionTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of collection translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [collectionId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationIndex(page?: number, perPage?: number, collectionId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<CollectionTranslationIndex200Response> {
            return localVarFp.collectionTranslationIndex(page, perPage, collectionId, languageId, contextId, defaultContext, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationShow(collectionTranslation: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionTranslationShow200Response> {
            return localVarFp.collectionTranslationShow(collectionTranslation, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created collection translation
         * @param {StoreCollectionTranslationRequest} storeCollectionTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationStore(storeCollectionTranslationRequest: StoreCollectionTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionTranslationShow200Response> {
            return localVarFp.collectionTranslationStore(storeCollectionTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {UpdateCollectionTranslationRequest} [updateCollectionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationUpdate(collectionTranslation: string, updateCollectionTranslationRequest?: UpdateCollectionTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionTranslationShow200Response> {
            return localVarFp.collectionTranslationUpdate(collectionTranslation, updateCollectionTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {UpdateCollectionTranslationRequest} [updateCollectionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationUpdate2(collectionTranslation: string, updateCollectionTranslationRequest?: UpdateCollectionTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionTranslationShow200Response> {
            return localVarFp.collectionTranslationUpdate2(collectionTranslation, updateCollectionTranslationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionTranslationApi - object-oriented interface
 */
export class CollectionTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified collection translation
     * @param {string} collectionTranslation The collection translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionTranslationDestroy(collectionTranslation: string, options?: RawAxiosRequestConfig) {
        return CollectionTranslationApiFp(this.configuration).collectionTranslationDestroy(collectionTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of collection translations
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [collectionId] 
     * @param {string} [languageId] 
     * @param {string} [contextId] 
     * @param {boolean} [defaultContext] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionTranslationIndex(page?: number, perPage?: number, collectionId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig) {
        return CollectionTranslationApiFp(this.configuration).collectionTranslationIndex(page, perPage, collectionId, languageId, contextId, defaultContext, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified collection translation
     * @param {string} collectionTranslation The collection translation ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionTranslationShow(collectionTranslation: string, include?: string, options?: RawAxiosRequestConfig) {
        return CollectionTranslationApiFp(this.configuration).collectionTranslationShow(collectionTranslation, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created collection translation
     * @param {StoreCollectionTranslationRequest} storeCollectionTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionTranslationStore(storeCollectionTranslationRequest: StoreCollectionTranslationRequest, options?: RawAxiosRequestConfig) {
        return CollectionTranslationApiFp(this.configuration).collectionTranslationStore(storeCollectionTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified collection translation
     * @param {string} collectionTranslation The collection translation ID
     * @param {UpdateCollectionTranslationRequest} [updateCollectionTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionTranslationUpdate(collectionTranslation: string, updateCollectionTranslationRequest?: UpdateCollectionTranslationRequest, options?: RawAxiosRequestConfig) {
        return CollectionTranslationApiFp(this.configuration).collectionTranslationUpdate(collectionTranslation, updateCollectionTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified collection translation
     * @param {string} collectionTranslation The collection translation ID
     * @param {UpdateCollectionTranslationRequest} [updateCollectionTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionTranslationUpdate2(collectionTranslation: string, updateCollectionTranslationRequest?: UpdateCollectionTranslationRequest, options?: RawAxiosRequestConfig) {
        return CollectionTranslationApiFp(this.configuration).collectionTranslationUpdate2(collectionTranslation, updateCollectionTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CollectionTranslationsApi - axios parameter creator
 */
export const CollectionTranslationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationDestroy: async (collectionTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionTranslation' is not null or undefined
            assertParamExists('collectionTranslationDestroy', 'collectionTranslation', collectionTranslation)
            const localVarPath = `/collection-translation/{collectionTranslation}`
                .replace(`{${"collectionTranslation"}}`, encodeURIComponent(String(collectionTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of collection translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [collectionId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationIndex: async (page?: number, perPage?: number, collectionId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collection-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (collectionId !== undefined) {
                localVarQueryParameter['collection_id'] = collectionId;
            }

            if (languageId !== undefined) {
                localVarQueryParameter['language_id'] = languageId;
            }

            if (contextId !== undefined) {
                localVarQueryParameter['context_id'] = contextId;
            }

            if (defaultContext !== undefined) {
                localVarQueryParameter['default_context'] = defaultContext;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationShow: async (collectionTranslation: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionTranslation' is not null or undefined
            assertParamExists('collectionTranslationShow', 'collectionTranslation', collectionTranslation)
            const localVarPath = `/collection-translation/{collectionTranslation}`
                .replace(`{${"collectionTranslation"}}`, encodeURIComponent(String(collectionTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created collection translation
         * @param {StoreCollectionTranslationRequest} storeCollectionTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationStore: async (storeCollectionTranslationRequest: StoreCollectionTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeCollectionTranslationRequest' is not null or undefined
            assertParamExists('collectionTranslationStore', 'storeCollectionTranslationRequest', storeCollectionTranslationRequest)
            const localVarPath = `/collection-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeCollectionTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {UpdateCollectionTranslationRequest} [updateCollectionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationUpdate: async (collectionTranslation: string, updateCollectionTranslationRequest?: UpdateCollectionTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionTranslation' is not null or undefined
            assertParamExists('collectionTranslationUpdate', 'collectionTranslation', collectionTranslation)
            const localVarPath = `/collection-translation/{collectionTranslation}`
                .replace(`{${"collectionTranslation"}}`, encodeURIComponent(String(collectionTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCollectionTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {UpdateCollectionTranslationRequest} [updateCollectionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationUpdate2: async (collectionTranslation: string, updateCollectionTranslationRequest?: UpdateCollectionTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionTranslation' is not null or undefined
            assertParamExists('collectionTranslationUpdate2', 'collectionTranslation', collectionTranslation)
            const localVarPath = `/collection-translation/{collectionTranslation}`
                .replace(`{${"collectionTranslation"}}`, encodeURIComponent(String(collectionTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCollectionTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionTranslationsApi - functional programming interface
 */
export const CollectionTranslationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionTranslationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionTranslationDestroy(collectionTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionTranslationDestroy(collectionTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionTranslationsApi.collectionTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of collection translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [collectionId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionTranslationIndex(page?: number, perPage?: number, collectionId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionTranslationIndex(page, perPage, collectionId, languageId, contextId, defaultContext, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionTranslationsApi.collectionTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionTranslationShow(collectionTranslation: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionTranslationShow(collectionTranslation, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionTranslationsApi.collectionTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created collection translation
         * @param {StoreCollectionTranslationRequest} storeCollectionTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionTranslationStore(storeCollectionTranslationRequest: StoreCollectionTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionTranslationStore(storeCollectionTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionTranslationsApi.collectionTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {UpdateCollectionTranslationRequest} [updateCollectionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionTranslationUpdate(collectionTranslation: string, updateCollectionTranslationRequest?: UpdateCollectionTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionTranslationUpdate(collectionTranslation, updateCollectionTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionTranslationsApi.collectionTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {UpdateCollectionTranslationRequest} [updateCollectionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionTranslationUpdate2(collectionTranslation: string, updateCollectionTranslationRequest?: UpdateCollectionTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionTranslationUpdate2(collectionTranslation, updateCollectionTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionTranslationsApi.collectionTranslationUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CollectionTranslationsApi - factory interface
 */
export const CollectionTranslationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionTranslationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationDestroy(collectionTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.collectionTranslationDestroy(collectionTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of collection translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [collectionId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationIndex(page?: number, perPage?: number, collectionId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<CollectionTranslationIndex200Response> {
            return localVarFp.collectionTranslationIndex(page, perPage, collectionId, languageId, contextId, defaultContext, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationShow(collectionTranslation: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionTranslationShow200Response> {
            return localVarFp.collectionTranslationShow(collectionTranslation, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created collection translation
         * @param {StoreCollectionTranslationRequest} storeCollectionTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationStore(storeCollectionTranslationRequest: StoreCollectionTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionTranslationShow200Response> {
            return localVarFp.collectionTranslationStore(storeCollectionTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {UpdateCollectionTranslationRequest} [updateCollectionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationUpdate(collectionTranslation: string, updateCollectionTranslationRequest?: UpdateCollectionTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionTranslationShow200Response> {
            return localVarFp.collectionTranslationUpdate(collectionTranslation, updateCollectionTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified collection translation
         * @param {string} collectionTranslation The collection translation ID
         * @param {UpdateCollectionTranslationRequest} [updateCollectionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionTranslationUpdate2(collectionTranslation: string, updateCollectionTranslationRequest?: UpdateCollectionTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionTranslationShow200Response> {
            return localVarFp.collectionTranslationUpdate2(collectionTranslation, updateCollectionTranslationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionTranslationsApi - object-oriented interface
 */
export class CollectionTranslationsApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified collection translation
     * @param {string} collectionTranslation The collection translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionTranslationDestroy(collectionTranslation: string, options?: RawAxiosRequestConfig) {
        return CollectionTranslationsApiFp(this.configuration).collectionTranslationDestroy(collectionTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of collection translations
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [collectionId] 
     * @param {string} [languageId] 
     * @param {string} [contextId] 
     * @param {boolean} [defaultContext] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionTranslationIndex(page?: number, perPage?: number, collectionId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig) {
        return CollectionTranslationsApiFp(this.configuration).collectionTranslationIndex(page, perPage, collectionId, languageId, contextId, defaultContext, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified collection translation
     * @param {string} collectionTranslation The collection translation ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionTranslationShow(collectionTranslation: string, include?: string, options?: RawAxiosRequestConfig) {
        return CollectionTranslationsApiFp(this.configuration).collectionTranslationShow(collectionTranslation, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created collection translation
     * @param {StoreCollectionTranslationRequest} storeCollectionTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionTranslationStore(storeCollectionTranslationRequest: StoreCollectionTranslationRequest, options?: RawAxiosRequestConfig) {
        return CollectionTranslationsApiFp(this.configuration).collectionTranslationStore(storeCollectionTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified collection translation
     * @param {string} collectionTranslation The collection translation ID
     * @param {UpdateCollectionTranslationRequest} [updateCollectionTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionTranslationUpdate(collectionTranslation: string, updateCollectionTranslationRequest?: UpdateCollectionTranslationRequest, options?: RawAxiosRequestConfig) {
        return CollectionTranslationsApiFp(this.configuration).collectionTranslationUpdate(collectionTranslation, updateCollectionTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified collection translation
     * @param {string} collectionTranslation The collection translation ID
     * @param {UpdateCollectionTranslationRequest} [updateCollectionTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public collectionTranslationUpdate2(collectionTranslation: string, updateCollectionTranslationRequest?: UpdateCollectionTranslationRequest, options?: RawAxiosRequestConfig) {
        return CollectionTranslationsApiFp(this.configuration).collectionTranslationUpdate2(collectionTranslation, updateCollectionTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContextApi - axios parameter creator
 */
export const ContextApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clear the default flag from any context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextClearDefault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/context/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} context The context ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDestroy: async (context: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('contextDestroy', 'context', context)
            const localVarPath = `/context/{context}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the default context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextGetDefault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/context/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set or unset a context as the default one
         * @param {string} context The context ID
         * @param {SetDefaultContextRequest} setDefaultContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextSetDefault: async (context: string, setDefaultContextRequest: SetDefaultContextRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('contextSetDefault', 'context', context)
            // verify required parameter 'setDefaultContextRequest' is not null or undefined
            assertParamExists('contextSetDefault', 'setDefaultContextRequest', setDefaultContextRequest)
            const localVarPath = `/context/{context}/default`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setDefaultContextRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} context The context ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextShow: async (context: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('contextShow', 'context', context)
            const localVarPath = `/context/{context}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreContextRequest} storeContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextStore: async (storeContextRequest: StoreContextRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeContextRequest' is not null or undefined
            assertParamExists('contextStore', 'storeContextRequest', storeContextRequest)
            const localVarPath = `/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeContextRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} context The context ID
         * @param {UpdateContextRequest} updateContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextUpdate: async (context: string, updateContextRequest: UpdateContextRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('contextUpdate', 'context', context)
            // verify required parameter 'updateContextRequest' is not null or undefined
            assertParamExists('contextUpdate', 'updateContextRequest', updateContextRequest)
            const localVarPath = `/context/{context}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateContextRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} context The context ID
         * @param {UpdateContextRequest} updateContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextUpdate2: async (context: string, updateContextRequest: UpdateContextRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('contextUpdate2', 'context', context)
            // verify required parameter 'updateContextRequest' is not null or undefined
            assertParamExists('contextUpdate2', 'updateContextRequest', updateContextRequest)
            const localVarPath = `/context/{context}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateContextRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContextApi - functional programming interface
 */
export const ContextApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContextApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Clear the default flag from any context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextClearDefault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextClearDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextClearDefault(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextClearDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} context The context ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextDestroy(context: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextDestroy(context, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the default context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextGetDefault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextGetDefault(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextGetDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set or unset a context as the default one
         * @param {string} context The context ID
         * @param {SetDefaultContextRequest} setDefaultContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextSetDefault(context: string, setDefaultContextRequest: SetDefaultContextRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextSetDefault(context, setDefaultContextRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextSetDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} context The context ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextShow(context: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextShow(context, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreContextRequest} storeContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextStore(storeContextRequest: StoreContextRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextStore(storeContextRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} context The context ID
         * @param {UpdateContextRequest} updateContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextUpdate(context: string, updateContextRequest: UpdateContextRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextUpdate(context, updateContextRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} context The context ID
         * @param {UpdateContextRequest} updateContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextUpdate2(context: string, updateContextRequest: UpdateContextRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextUpdate2(context, updateContextRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContextApi - factory interface
 */
export const ContextApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContextApiFp(configuration)
    return {
        /**
         * 
         * @summary Clear the default flag from any context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextClearDefault(options?: RawAxiosRequestConfig): AxiosPromise<ContextClearDefault200Response> {
            return localVarFp.contextClearDefault(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} context The context ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDestroy(context: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.contextDestroy(context, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the default context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextGetDefault(options?: RawAxiosRequestConfig): AxiosPromise<ContextGetDefault200Response> {
            return localVarFp.contextGetDefault(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContextIndex200Response> {
            return localVarFp.contextIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set or unset a context as the default one
         * @param {string} context The context ID
         * @param {SetDefaultContextRequest} setDefaultContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextSetDefault(context: string, setDefaultContextRequest: SetDefaultContextRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContextGetDefault200Response> {
            return localVarFp.contextSetDefault(context, setDefaultContextRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} context The context ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextShow(context: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContextGetDefault200Response> {
            return localVarFp.contextShow(context, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreContextRequest} storeContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextStore(storeContextRequest: StoreContextRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContextGetDefault200Response> {
            return localVarFp.contextStore(storeContextRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} context The context ID
         * @param {UpdateContextRequest} updateContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextUpdate(context: string, updateContextRequest: UpdateContextRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContextGetDefault200Response> {
            return localVarFp.contextUpdate(context, updateContextRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} context The context ID
         * @param {UpdateContextRequest} updateContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextUpdate2(context: string, updateContextRequest: UpdateContextRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContextGetDefault200Response> {
            return localVarFp.contextUpdate2(context, updateContextRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContextApi - object-oriented interface
 */
export class ContextApi extends BaseAPI {
    /**
     * 
     * @summary Clear the default flag from any context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contextClearDefault(options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextClearDefault(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} context The context ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contextDestroy(context: string, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextDestroy(context, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the default context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contextGetDefault(options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextGetDefault(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contextIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set or unset a context as the default one
     * @param {string} context The context ID
     * @param {SetDefaultContextRequest} setDefaultContextRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contextSetDefault(context: string, setDefaultContextRequest: SetDefaultContextRequest, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextSetDefault(context, setDefaultContextRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} context The context ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contextShow(context: string, include?: string, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextShow(context, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreContextRequest} storeContextRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contextStore(storeContextRequest: StoreContextRequest, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextStore(storeContextRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} context The context ID
     * @param {UpdateContextRequest} updateContextRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contextUpdate(context: string, updateContextRequest: UpdateContextRequest, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextUpdate(context, updateContextRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} context The context ID
     * @param {UpdateContextRequest} updateContextRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contextUpdate2(context: string, updateContextRequest: UpdateContextRequest, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextUpdate2(context, updateContextRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CountryApi - axios parameter creator
 */
export const CountryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} country The country ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryDestroy: async (country: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('countryDestroy', 'country', country)
            const localVarPath = `/country/{country}`
                .replace(`{${"country"}}`, encodeURIComponent(String(country)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/country`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} country The country ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryShow: async (country: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('countryShow', 'country', country)
            const localVarPath = `/country/{country}`
                .replace(`{${"country"}}`, encodeURIComponent(String(country)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreCountryRequest} storeCountryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryStore: async (storeCountryRequest: StoreCountryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeCountryRequest' is not null or undefined
            assertParamExists('countryStore', 'storeCountryRequest', storeCountryRequest)
            const localVarPath = `/country`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeCountryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} country The country ID
         * @param {UpdateCountryRequest} updateCountryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryUpdate: async (country: string, updateCountryRequest: UpdateCountryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('countryUpdate', 'country', country)
            // verify required parameter 'updateCountryRequest' is not null or undefined
            assertParamExists('countryUpdate', 'updateCountryRequest', updateCountryRequest)
            const localVarPath = `/country/{country}`
                .replace(`{${"country"}}`, encodeURIComponent(String(country)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCountryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} country The country ID
         * @param {UpdateCountryRequest} updateCountryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryUpdate2: async (country: string, updateCountryRequest: UpdateCountryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('countryUpdate2', 'country', country)
            // verify required parameter 'updateCountryRequest' is not null or undefined
            assertParamExists('countryUpdate2', 'updateCountryRequest', updateCountryRequest)
            const localVarPath = `/country/{country}`
                .replace(`{${"country"}}`, encodeURIComponent(String(country)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCountryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountryApi - functional programming interface
 */
export const CountryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CountryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} country The country ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryDestroy(country: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryDestroy(country, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} country The country ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryShow(country: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryShow(country, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreCountryRequest} storeCountryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryStore(storeCountryRequest: StoreCountryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryStore(storeCountryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} country The country ID
         * @param {UpdateCountryRequest} updateCountryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryUpdate(country: string, updateCountryRequest: UpdateCountryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryUpdate(country, updateCountryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} country The country ID
         * @param {UpdateCountryRequest} updateCountryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryUpdate2(country: string, updateCountryRequest: UpdateCountryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryUpdate2(country, updateCountryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CountryApi - factory interface
 */
export const CountryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CountryApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} country The country ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryDestroy(country: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.countryDestroy(country, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<CountryIndex200Response> {
            return localVarFp.countryIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} country The country ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryShow(country: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<CountryShow200Response> {
            return localVarFp.countryShow(country, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreCountryRequest} storeCountryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryStore(storeCountryRequest: StoreCountryRequest, options?: RawAxiosRequestConfig): AxiosPromise<CountryShow200Response> {
            return localVarFp.countryStore(storeCountryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} country The country ID
         * @param {UpdateCountryRequest} updateCountryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryUpdate(country: string, updateCountryRequest: UpdateCountryRequest, options?: RawAxiosRequestConfig): AxiosPromise<CountryShow200Response> {
            return localVarFp.countryUpdate(country, updateCountryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} country The country ID
         * @param {UpdateCountryRequest} updateCountryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryUpdate2(country: string, updateCountryRequest: UpdateCountryRequest, options?: RawAxiosRequestConfig): AxiosPromise<CountryShow200Response> {
            return localVarFp.countryUpdate2(country, updateCountryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CountryApi - object-oriented interface
 */
export class CountryApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} country The country ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public countryDestroy(country: string, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryDestroy(country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public countryIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} country The country ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public countryShow(country: string, include?: string, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryShow(country, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreCountryRequest} storeCountryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public countryStore(storeCountryRequest: StoreCountryRequest, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryStore(storeCountryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} country The country ID
     * @param {UpdateCountryRequest} updateCountryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public countryUpdate(country: string, updateCountryRequest: UpdateCountryRequest, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryUpdate(country, updateCountryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} country The country ID
     * @param {UpdateCountryRequest} updateCountryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public countryUpdate2(country: string, updateCountryRequest: UpdateCountryRequest, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryUpdate2(country, updateCountryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CountryTranslationApi - axios parameter creator
 */
export const CountryTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} countryTranslation The country translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryTranslationDestroy: async (countryTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryTranslation' is not null or undefined
            assertParamExists('countryTranslationDestroy', 'countryTranslation', countryTranslation)
            const localVarPath = `/country-translation/{countryTranslation}`
                .replace(`{${"countryTranslation"}}`, encodeURIComponent(String(countryTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryTranslationIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/country-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} countryTranslation The country translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryTranslationShow: async (countryTranslation: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryTranslation' is not null or undefined
            assertParamExists('countryTranslationShow', 'countryTranslation', countryTranslation)
            const localVarPath = `/country-translation/{countryTranslation}`
                .replace(`{${"countryTranslation"}}`, encodeURIComponent(String(countryTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreCountryTranslationRequest} storeCountryTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryTranslationStore: async (storeCountryTranslationRequest: StoreCountryTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeCountryTranslationRequest' is not null or undefined
            assertParamExists('countryTranslationStore', 'storeCountryTranslationRequest', storeCountryTranslationRequest)
            const localVarPath = `/country-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeCountryTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} countryTranslation The country translation ID
         * @param {UpdateCountryTranslationRequest} [updateCountryTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryTranslationUpdate: async (countryTranslation: string, updateCountryTranslationRequest?: UpdateCountryTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryTranslation' is not null or undefined
            assertParamExists('countryTranslationUpdate', 'countryTranslation', countryTranslation)
            const localVarPath = `/country-translation/{countryTranslation}`
                .replace(`{${"countryTranslation"}}`, encodeURIComponent(String(countryTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCountryTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} countryTranslation The country translation ID
         * @param {UpdateCountryTranslationRequest} [updateCountryTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryTranslationUpdate2: async (countryTranslation: string, updateCountryTranslationRequest?: UpdateCountryTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryTranslation' is not null or undefined
            assertParamExists('countryTranslationUpdate2', 'countryTranslation', countryTranslation)
            const localVarPath = `/country-translation/{countryTranslation}`
                .replace(`{${"countryTranslation"}}`, encodeURIComponent(String(countryTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCountryTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountryTranslationApi - functional programming interface
 */
export const CountryTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CountryTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} countryTranslation The country translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryTranslationDestroy(countryTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryTranslationDestroy(countryTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryTranslationApi.countryTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryTranslationIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryTranslationIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryTranslationApi.countryTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} countryTranslation The country translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryTranslationShow(countryTranslation: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryTranslationShow(countryTranslation, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryTranslationApi.countryTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreCountryTranslationRequest} storeCountryTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryTranslationStore(storeCountryTranslationRequest: StoreCountryTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryTranslationStore(storeCountryTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryTranslationApi.countryTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} countryTranslation The country translation ID
         * @param {UpdateCountryTranslationRequest} [updateCountryTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryTranslationUpdate(countryTranslation: string, updateCountryTranslationRequest?: UpdateCountryTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryTranslationUpdate(countryTranslation, updateCountryTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryTranslationApi.countryTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} countryTranslation The country translation ID
         * @param {UpdateCountryTranslationRequest} [updateCountryTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryTranslationUpdate2(countryTranslation: string, updateCountryTranslationRequest?: UpdateCountryTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryTranslationUpdate2(countryTranslation, updateCountryTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryTranslationApi.countryTranslationUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CountryTranslationApi - factory interface
 */
export const CountryTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CountryTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} countryTranslation The country translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryTranslationDestroy(countryTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.countryTranslationDestroy(countryTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryTranslationIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<CountryTranslationIndex200Response> {
            return localVarFp.countryTranslationIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} countryTranslation The country translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryTranslationShow(countryTranslation: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<CountryTranslationShow200Response> {
            return localVarFp.countryTranslationShow(countryTranslation, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreCountryTranslationRequest} storeCountryTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryTranslationStore(storeCountryTranslationRequest: StoreCountryTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CountryTranslationShow200Response> {
            return localVarFp.countryTranslationStore(storeCountryTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} countryTranslation The country translation ID
         * @param {UpdateCountryTranslationRequest} [updateCountryTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryTranslationUpdate(countryTranslation: string, updateCountryTranslationRequest?: UpdateCountryTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CountryTranslationShow200Response> {
            return localVarFp.countryTranslationUpdate(countryTranslation, updateCountryTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} countryTranslation The country translation ID
         * @param {UpdateCountryTranslationRequest} [updateCountryTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryTranslationUpdate2(countryTranslation: string, updateCountryTranslationRequest?: UpdateCountryTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CountryTranslationShow200Response> {
            return localVarFp.countryTranslationUpdate2(countryTranslation, updateCountryTranslationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CountryTranslationApi - object-oriented interface
 */
export class CountryTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} countryTranslation The country translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public countryTranslationDestroy(countryTranslation: string, options?: RawAxiosRequestConfig) {
        return CountryTranslationApiFp(this.configuration).countryTranslationDestroy(countryTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public countryTranslationIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return CountryTranslationApiFp(this.configuration).countryTranslationIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} countryTranslation The country translation ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public countryTranslationShow(countryTranslation: string, include?: string, options?: RawAxiosRequestConfig) {
        return CountryTranslationApiFp(this.configuration).countryTranslationShow(countryTranslation, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreCountryTranslationRequest} storeCountryTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public countryTranslationStore(storeCountryTranslationRequest: StoreCountryTranslationRequest, options?: RawAxiosRequestConfig) {
        return CountryTranslationApiFp(this.configuration).countryTranslationStore(storeCountryTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} countryTranslation The country translation ID
     * @param {UpdateCountryTranslationRequest} [updateCountryTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public countryTranslationUpdate(countryTranslation: string, updateCountryTranslationRequest?: UpdateCountryTranslationRequest, options?: RawAxiosRequestConfig) {
        return CountryTranslationApiFp(this.configuration).countryTranslationUpdate(countryTranslation, updateCountryTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} countryTranslation The country translation ID
     * @param {UpdateCountryTranslationRequest} [updateCountryTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public countryTranslationUpdate2(countryTranslation: string, updateCountryTranslationRequest?: UpdateCountryTranslationRequest, options?: RawAxiosRequestConfig) {
        return CountryTranslationApiFp(this.configuration).countryTranslationUpdate2(countryTranslation, updateCountryTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentation: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentation(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentation(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.documentation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.userGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentation(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.documentation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.userGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentation(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).documentation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GlossaryApi - axios parameter creator
 */
export const GlossaryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Attach a synonym to the glossary entry
         * @param {string} glossary The glossary ID
         * @param {AttachGlossarySynonymRequest} attachGlossarySynonymRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryAttachSynonym: async (glossary: string, attachGlossarySynonymRequest: AttachGlossarySynonymRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'glossary' is not null or undefined
            assertParamExists('glossaryAttachSynonym', 'glossary', glossary)
            // verify required parameter 'attachGlossarySynonymRequest' is not null or undefined
            assertParamExists('glossaryAttachSynonym', 'attachGlossarySynonymRequest', attachGlossarySynonymRequest)
            const localVarPath = `/glossary/{glossary}/attach-synonym`
                .replace(`{${"glossary"}}`, encodeURIComponent(String(glossary)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachGlossarySynonymRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} glossary The glossary ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryDestroy: async (glossary: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'glossary' is not null or undefined
            assertParamExists('glossaryDestroy', 'glossary', glossary)
            const localVarPath = `/glossary/{glossary}`
                .replace(`{${"glossary"}}`, encodeURIComponent(String(glossary)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach a synonym from the glossary entry
         * @param {string} glossary The glossary ID
         * @param {string} synonymId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryDetachSynonym: async (glossary: string, synonymId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'glossary' is not null or undefined
            assertParamExists('glossaryDetachSynonym', 'glossary', glossary)
            // verify required parameter 'synonymId' is not null or undefined
            assertParamExists('glossaryDetachSynonym', 'synonymId', synonymId)
            const localVarPath = `/glossary/{glossary}/detach-synonym`
                .replace(`{${"glossary"}}`, encodeURIComponent(String(glossary)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (synonymId !== undefined) {
                localVarQueryParameter['synonym_id'] = synonymId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/glossary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} glossary The glossary ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryShow: async (glossary: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'glossary' is not null or undefined
            assertParamExists('glossaryShow', 'glossary', glossary)
            const localVarPath = `/glossary/{glossary}`
                .replace(`{${"glossary"}}`, encodeURIComponent(String(glossary)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreGlossaryRequest} storeGlossaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryStore: async (storeGlossaryRequest: StoreGlossaryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeGlossaryRequest' is not null or undefined
            assertParamExists('glossaryStore', 'storeGlossaryRequest', storeGlossaryRequest)
            const localVarPath = `/glossary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeGlossaryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} glossary The glossary ID
         * @param {UpdateGlossaryRequest} updateGlossaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryUpdate: async (glossary: string, updateGlossaryRequest: UpdateGlossaryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'glossary' is not null or undefined
            assertParamExists('glossaryUpdate', 'glossary', glossary)
            // verify required parameter 'updateGlossaryRequest' is not null or undefined
            assertParamExists('glossaryUpdate', 'updateGlossaryRequest', updateGlossaryRequest)
            const localVarPath = `/glossary/{glossary}`
                .replace(`{${"glossary"}}`, encodeURIComponent(String(glossary)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGlossaryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} glossary The glossary ID
         * @param {UpdateGlossaryRequest} updateGlossaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryUpdate2: async (glossary: string, updateGlossaryRequest: UpdateGlossaryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'glossary' is not null or undefined
            assertParamExists('glossaryUpdate2', 'glossary', glossary)
            // verify required parameter 'updateGlossaryRequest' is not null or undefined
            assertParamExists('glossaryUpdate2', 'updateGlossaryRequest', updateGlossaryRequest)
            const localVarPath = `/glossary/{glossary}`
                .replace(`{${"glossary"}}`, encodeURIComponent(String(glossary)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGlossaryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GlossaryApi - functional programming interface
 */
export const GlossaryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GlossaryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Attach a synonym to the glossary entry
         * @param {string} glossary The glossary ID
         * @param {AttachGlossarySynonymRequest} attachGlossarySynonymRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glossaryAttachSynonym(glossary: string, attachGlossarySynonymRequest: AttachGlossarySynonymRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlossaryShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glossaryAttachSynonym(glossary, attachGlossarySynonymRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlossaryApi.glossaryAttachSynonym']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} glossary The glossary ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glossaryDestroy(glossary: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glossaryDestroy(glossary, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlossaryApi.glossaryDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Detach a synonym from the glossary entry
         * @param {string} glossary The glossary ID
         * @param {string} synonymId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glossaryDetachSynonym(glossary: string, synonymId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlossaryShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glossaryDetachSynonym(glossary, synonymId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlossaryApi.glossaryDetachSynonym']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glossaryIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlossaryIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glossaryIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlossaryApi.glossaryIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} glossary The glossary ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glossaryShow(glossary: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlossaryShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glossaryShow(glossary, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlossaryApi.glossaryShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreGlossaryRequest} storeGlossaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glossaryStore(storeGlossaryRequest: StoreGlossaryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlossaryShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glossaryStore(storeGlossaryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlossaryApi.glossaryStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} glossary The glossary ID
         * @param {UpdateGlossaryRequest} updateGlossaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glossaryUpdate(glossary: string, updateGlossaryRequest: UpdateGlossaryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlossaryShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glossaryUpdate(glossary, updateGlossaryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlossaryApi.glossaryUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} glossary The glossary ID
         * @param {UpdateGlossaryRequest} updateGlossaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glossaryUpdate2(glossary: string, updateGlossaryRequest: UpdateGlossaryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlossaryShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glossaryUpdate2(glossary, updateGlossaryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlossaryApi.glossaryUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GlossaryApi - factory interface
 */
export const GlossaryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GlossaryApiFp(configuration)
    return {
        /**
         * 
         * @summary Attach a synonym to the glossary entry
         * @param {string} glossary The glossary ID
         * @param {AttachGlossarySynonymRequest} attachGlossarySynonymRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryAttachSynonym(glossary: string, attachGlossarySynonymRequest: AttachGlossarySynonymRequest, options?: RawAxiosRequestConfig): AxiosPromise<GlossaryShow200Response> {
            return localVarFp.glossaryAttachSynonym(glossary, attachGlossarySynonymRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} glossary The glossary ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryDestroy(glossary: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.glossaryDestroy(glossary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detach a synonym from the glossary entry
         * @param {string} glossary The glossary ID
         * @param {string} synonymId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryDetachSynonym(glossary: string, synonymId: string, options?: RawAxiosRequestConfig): AxiosPromise<GlossaryShow200Response> {
            return localVarFp.glossaryDetachSynonym(glossary, synonymId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<GlossaryIndex200Response> {
            return localVarFp.glossaryIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} glossary The glossary ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryShow(glossary: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<GlossaryShow200Response> {
            return localVarFp.glossaryShow(glossary, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreGlossaryRequest} storeGlossaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryStore(storeGlossaryRequest: StoreGlossaryRequest, options?: RawAxiosRequestConfig): AxiosPromise<GlossaryShow200Response> {
            return localVarFp.glossaryStore(storeGlossaryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} glossary The glossary ID
         * @param {UpdateGlossaryRequest} updateGlossaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryUpdate(glossary: string, updateGlossaryRequest: UpdateGlossaryRequest, options?: RawAxiosRequestConfig): AxiosPromise<GlossaryShow200Response> {
            return localVarFp.glossaryUpdate(glossary, updateGlossaryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} glossary The glossary ID
         * @param {UpdateGlossaryRequest} updateGlossaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryUpdate2(glossary: string, updateGlossaryRequest: UpdateGlossaryRequest, options?: RawAxiosRequestConfig): AxiosPromise<GlossaryShow200Response> {
            return localVarFp.glossaryUpdate2(glossary, updateGlossaryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GlossaryApi - object-oriented interface
 */
export class GlossaryApi extends BaseAPI {
    /**
     * 
     * @summary Attach a synonym to the glossary entry
     * @param {string} glossary The glossary ID
     * @param {AttachGlossarySynonymRequest} attachGlossarySynonymRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public glossaryAttachSynonym(glossary: string, attachGlossarySynonymRequest: AttachGlossarySynonymRequest, options?: RawAxiosRequestConfig) {
        return GlossaryApiFp(this.configuration).glossaryAttachSynonym(glossary, attachGlossarySynonymRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} glossary The glossary ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public glossaryDestroy(glossary: string, options?: RawAxiosRequestConfig) {
        return GlossaryApiFp(this.configuration).glossaryDestroy(glossary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detach a synonym from the glossary entry
     * @param {string} glossary The glossary ID
     * @param {string} synonymId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public glossaryDetachSynonym(glossary: string, synonymId: string, options?: RawAxiosRequestConfig) {
        return GlossaryApiFp(this.configuration).glossaryDetachSynonym(glossary, synonymId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public glossaryIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return GlossaryApiFp(this.configuration).glossaryIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} glossary The glossary ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public glossaryShow(glossary: string, include?: string, options?: RawAxiosRequestConfig) {
        return GlossaryApiFp(this.configuration).glossaryShow(glossary, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreGlossaryRequest} storeGlossaryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public glossaryStore(storeGlossaryRequest: StoreGlossaryRequest, options?: RawAxiosRequestConfig) {
        return GlossaryApiFp(this.configuration).glossaryStore(storeGlossaryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} glossary The glossary ID
     * @param {UpdateGlossaryRequest} updateGlossaryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public glossaryUpdate(glossary: string, updateGlossaryRequest: UpdateGlossaryRequest, options?: RawAxiosRequestConfig) {
        return GlossaryApiFp(this.configuration).glossaryUpdate(glossary, updateGlossaryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} glossary The glossary ID
     * @param {UpdateGlossaryRequest} updateGlossaryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public glossaryUpdate2(glossary: string, updateGlossaryRequest: UpdateGlossaryRequest, options?: RawAxiosRequestConfig) {
        return GlossaryApiFp(this.configuration).glossaryUpdate2(glossary, updateGlossaryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GlossarySpellingApi - axios parameter creator
 */
export const GlossarySpellingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} glossarySpelling The glossary spelling ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossarySpellingDestroy: async (glossarySpelling: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'glossarySpelling' is not null or undefined
            assertParamExists('glossarySpellingDestroy', 'glossarySpelling', glossarySpelling)
            const localVarPath = `/glossary-spelling/{glossarySpelling}`
                .replace(`{${"glossarySpelling"}}`, encodeURIComponent(String(glossarySpelling)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossarySpellingIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/glossary-spelling`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} glossarySpelling The glossary spelling ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossarySpellingShow: async (glossarySpelling: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'glossarySpelling' is not null or undefined
            assertParamExists('glossarySpellingShow', 'glossarySpelling', glossarySpelling)
            const localVarPath = `/glossary-spelling/{glossarySpelling}`
                .replace(`{${"glossarySpelling"}}`, encodeURIComponent(String(glossarySpelling)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreGlossarySpellingRequest} storeGlossarySpellingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossarySpellingStore: async (storeGlossarySpellingRequest: StoreGlossarySpellingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeGlossarySpellingRequest' is not null or undefined
            assertParamExists('glossarySpellingStore', 'storeGlossarySpellingRequest', storeGlossarySpellingRequest)
            const localVarPath = `/glossary-spelling`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeGlossarySpellingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} glossarySpelling The glossary spelling ID
         * @param {UpdateGlossarySpellingRequest} [updateGlossarySpellingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossarySpellingUpdate: async (glossarySpelling: string, updateGlossarySpellingRequest?: UpdateGlossarySpellingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'glossarySpelling' is not null or undefined
            assertParamExists('glossarySpellingUpdate', 'glossarySpelling', glossarySpelling)
            const localVarPath = `/glossary-spelling/{glossarySpelling}`
                .replace(`{${"glossarySpelling"}}`, encodeURIComponent(String(glossarySpelling)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGlossarySpellingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} glossarySpelling The glossary spelling ID
         * @param {UpdateGlossarySpellingRequest} [updateGlossarySpellingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossarySpellingUpdate2: async (glossarySpelling: string, updateGlossarySpellingRequest?: UpdateGlossarySpellingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'glossarySpelling' is not null or undefined
            assertParamExists('glossarySpellingUpdate2', 'glossarySpelling', glossarySpelling)
            const localVarPath = `/glossary-spelling/{glossarySpelling}`
                .replace(`{${"glossarySpelling"}}`, encodeURIComponent(String(glossarySpelling)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGlossarySpellingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GlossarySpellingApi - functional programming interface
 */
export const GlossarySpellingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GlossarySpellingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} glossarySpelling The glossary spelling ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glossarySpellingDestroy(glossarySpelling: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glossarySpellingDestroy(glossarySpelling, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlossarySpellingApi.glossarySpellingDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glossarySpellingIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlossarySpellingIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glossarySpellingIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlossarySpellingApi.glossarySpellingIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} glossarySpelling The glossary spelling ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glossarySpellingShow(glossarySpelling: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlossarySpellingShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glossarySpellingShow(glossarySpelling, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlossarySpellingApi.glossarySpellingShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreGlossarySpellingRequest} storeGlossarySpellingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glossarySpellingStore(storeGlossarySpellingRequest: StoreGlossarySpellingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlossarySpellingShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glossarySpellingStore(storeGlossarySpellingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlossarySpellingApi.glossarySpellingStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} glossarySpelling The glossary spelling ID
         * @param {UpdateGlossarySpellingRequest} [updateGlossarySpellingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glossarySpellingUpdate(glossarySpelling: string, updateGlossarySpellingRequest?: UpdateGlossarySpellingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlossarySpellingShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glossarySpellingUpdate(glossarySpelling, updateGlossarySpellingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlossarySpellingApi.glossarySpellingUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} glossarySpelling The glossary spelling ID
         * @param {UpdateGlossarySpellingRequest} [updateGlossarySpellingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glossarySpellingUpdate2(glossarySpelling: string, updateGlossarySpellingRequest?: UpdateGlossarySpellingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlossarySpellingShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glossarySpellingUpdate2(glossarySpelling, updateGlossarySpellingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlossarySpellingApi.glossarySpellingUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GlossarySpellingApi - factory interface
 */
export const GlossarySpellingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GlossarySpellingApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} glossarySpelling The glossary spelling ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossarySpellingDestroy(glossarySpelling: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.glossarySpellingDestroy(glossarySpelling, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossarySpellingIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<GlossarySpellingIndex200Response> {
            return localVarFp.glossarySpellingIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} glossarySpelling The glossary spelling ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossarySpellingShow(glossarySpelling: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<GlossarySpellingShow200Response> {
            return localVarFp.glossarySpellingShow(glossarySpelling, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreGlossarySpellingRequest} storeGlossarySpellingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossarySpellingStore(storeGlossarySpellingRequest: StoreGlossarySpellingRequest, options?: RawAxiosRequestConfig): AxiosPromise<GlossarySpellingShow200Response> {
            return localVarFp.glossarySpellingStore(storeGlossarySpellingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} glossarySpelling The glossary spelling ID
         * @param {UpdateGlossarySpellingRequest} [updateGlossarySpellingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossarySpellingUpdate(glossarySpelling: string, updateGlossarySpellingRequest?: UpdateGlossarySpellingRequest, options?: RawAxiosRequestConfig): AxiosPromise<GlossarySpellingShow200Response> {
            return localVarFp.glossarySpellingUpdate(glossarySpelling, updateGlossarySpellingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} glossarySpelling The glossary spelling ID
         * @param {UpdateGlossarySpellingRequest} [updateGlossarySpellingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossarySpellingUpdate2(glossarySpelling: string, updateGlossarySpellingRequest?: UpdateGlossarySpellingRequest, options?: RawAxiosRequestConfig): AxiosPromise<GlossarySpellingShow200Response> {
            return localVarFp.glossarySpellingUpdate2(glossarySpelling, updateGlossarySpellingRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GlossarySpellingApi - object-oriented interface
 */
export class GlossarySpellingApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} glossarySpelling The glossary spelling ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public glossarySpellingDestroy(glossarySpelling: string, options?: RawAxiosRequestConfig) {
        return GlossarySpellingApiFp(this.configuration).glossarySpellingDestroy(glossarySpelling, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public glossarySpellingIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return GlossarySpellingApiFp(this.configuration).glossarySpellingIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} glossarySpelling The glossary spelling ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public glossarySpellingShow(glossarySpelling: string, include?: string, options?: RawAxiosRequestConfig) {
        return GlossarySpellingApiFp(this.configuration).glossarySpellingShow(glossarySpelling, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreGlossarySpellingRequest} storeGlossarySpellingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public glossarySpellingStore(storeGlossarySpellingRequest: StoreGlossarySpellingRequest, options?: RawAxiosRequestConfig) {
        return GlossarySpellingApiFp(this.configuration).glossarySpellingStore(storeGlossarySpellingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} glossarySpelling The glossary spelling ID
     * @param {UpdateGlossarySpellingRequest} [updateGlossarySpellingRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public glossarySpellingUpdate(glossarySpelling: string, updateGlossarySpellingRequest?: UpdateGlossarySpellingRequest, options?: RawAxiosRequestConfig) {
        return GlossarySpellingApiFp(this.configuration).glossarySpellingUpdate(glossarySpelling, updateGlossarySpellingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} glossarySpelling The glossary spelling ID
     * @param {UpdateGlossarySpellingRequest} [updateGlossarySpellingRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public glossarySpellingUpdate2(glossarySpelling: string, updateGlossarySpellingRequest?: UpdateGlossarySpellingRequest, options?: RawAxiosRequestConfig) {
        return GlossarySpellingApiFp(this.configuration).glossarySpellingUpdate2(glossarySpelling, updateGlossarySpellingRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GlossaryTranslationApi - axios parameter creator
 */
export const GlossaryTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} glossaryTranslation The glossary translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryTranslationDestroy: async (glossaryTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'glossaryTranslation' is not null or undefined
            assertParamExists('glossaryTranslationDestroy', 'glossaryTranslation', glossaryTranslation)
            const localVarPath = `/glossary-translation/{glossaryTranslation}`
                .replace(`{${"glossaryTranslation"}}`, encodeURIComponent(String(glossaryTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryTranslationIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/glossary-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} glossaryTranslation The glossary translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryTranslationShow: async (glossaryTranslation: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'glossaryTranslation' is not null or undefined
            assertParamExists('glossaryTranslationShow', 'glossaryTranslation', glossaryTranslation)
            const localVarPath = `/glossary-translation/{glossaryTranslation}`
                .replace(`{${"glossaryTranslation"}}`, encodeURIComponent(String(glossaryTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreGlossaryTranslationRequest} storeGlossaryTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryTranslationStore: async (storeGlossaryTranslationRequest: StoreGlossaryTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeGlossaryTranslationRequest' is not null or undefined
            assertParamExists('glossaryTranslationStore', 'storeGlossaryTranslationRequest', storeGlossaryTranslationRequest)
            const localVarPath = `/glossary-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeGlossaryTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} glossaryTranslation The glossary translation ID
         * @param {UpdateGlossaryTranslationRequest} [updateGlossaryTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryTranslationUpdate: async (glossaryTranslation: string, updateGlossaryTranslationRequest?: UpdateGlossaryTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'glossaryTranslation' is not null or undefined
            assertParamExists('glossaryTranslationUpdate', 'glossaryTranslation', glossaryTranslation)
            const localVarPath = `/glossary-translation/{glossaryTranslation}`
                .replace(`{${"glossaryTranslation"}}`, encodeURIComponent(String(glossaryTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGlossaryTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} glossaryTranslation The glossary translation ID
         * @param {UpdateGlossaryTranslationRequest} [updateGlossaryTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryTranslationUpdate2: async (glossaryTranslation: string, updateGlossaryTranslationRequest?: UpdateGlossaryTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'glossaryTranslation' is not null or undefined
            assertParamExists('glossaryTranslationUpdate2', 'glossaryTranslation', glossaryTranslation)
            const localVarPath = `/glossary-translation/{glossaryTranslation}`
                .replace(`{${"glossaryTranslation"}}`, encodeURIComponent(String(glossaryTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGlossaryTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GlossaryTranslationApi - functional programming interface
 */
export const GlossaryTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GlossaryTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} glossaryTranslation The glossary translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glossaryTranslationDestroy(glossaryTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glossaryTranslationDestroy(glossaryTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlossaryTranslationApi.glossaryTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glossaryTranslationIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlossaryTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glossaryTranslationIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlossaryTranslationApi.glossaryTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} glossaryTranslation The glossary translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glossaryTranslationShow(glossaryTranslation: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlossaryTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glossaryTranslationShow(glossaryTranslation, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlossaryTranslationApi.glossaryTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreGlossaryTranslationRequest} storeGlossaryTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glossaryTranslationStore(storeGlossaryTranslationRequest: StoreGlossaryTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlossaryTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glossaryTranslationStore(storeGlossaryTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlossaryTranslationApi.glossaryTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} glossaryTranslation The glossary translation ID
         * @param {UpdateGlossaryTranslationRequest} [updateGlossaryTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glossaryTranslationUpdate(glossaryTranslation: string, updateGlossaryTranslationRequest?: UpdateGlossaryTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlossaryTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glossaryTranslationUpdate(glossaryTranslation, updateGlossaryTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlossaryTranslationApi.glossaryTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} glossaryTranslation The glossary translation ID
         * @param {UpdateGlossaryTranslationRequest} [updateGlossaryTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glossaryTranslationUpdate2(glossaryTranslation: string, updateGlossaryTranslationRequest?: UpdateGlossaryTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlossaryTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glossaryTranslationUpdate2(glossaryTranslation, updateGlossaryTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlossaryTranslationApi.glossaryTranslationUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GlossaryTranslationApi - factory interface
 */
export const GlossaryTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GlossaryTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} glossaryTranslation The glossary translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryTranslationDestroy(glossaryTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.glossaryTranslationDestroy(glossaryTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryTranslationIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<GlossaryTranslationIndex200Response> {
            return localVarFp.glossaryTranslationIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} glossaryTranslation The glossary translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryTranslationShow(glossaryTranslation: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<GlossaryTranslationShow200Response> {
            return localVarFp.glossaryTranslationShow(glossaryTranslation, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreGlossaryTranslationRequest} storeGlossaryTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryTranslationStore(storeGlossaryTranslationRequest: StoreGlossaryTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<GlossaryTranslationShow200Response> {
            return localVarFp.glossaryTranslationStore(storeGlossaryTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} glossaryTranslation The glossary translation ID
         * @param {UpdateGlossaryTranslationRequest} [updateGlossaryTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryTranslationUpdate(glossaryTranslation: string, updateGlossaryTranslationRequest?: UpdateGlossaryTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<GlossaryTranslationShow200Response> {
            return localVarFp.glossaryTranslationUpdate(glossaryTranslation, updateGlossaryTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} glossaryTranslation The glossary translation ID
         * @param {UpdateGlossaryTranslationRequest} [updateGlossaryTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossaryTranslationUpdate2(glossaryTranslation: string, updateGlossaryTranslationRequest?: UpdateGlossaryTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<GlossaryTranslationShow200Response> {
            return localVarFp.glossaryTranslationUpdate2(glossaryTranslation, updateGlossaryTranslationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GlossaryTranslationApi - object-oriented interface
 */
export class GlossaryTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} glossaryTranslation The glossary translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public glossaryTranslationDestroy(glossaryTranslation: string, options?: RawAxiosRequestConfig) {
        return GlossaryTranslationApiFp(this.configuration).glossaryTranslationDestroy(glossaryTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public glossaryTranslationIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return GlossaryTranslationApiFp(this.configuration).glossaryTranslationIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} glossaryTranslation The glossary translation ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public glossaryTranslationShow(glossaryTranslation: string, include?: string, options?: RawAxiosRequestConfig) {
        return GlossaryTranslationApiFp(this.configuration).glossaryTranslationShow(glossaryTranslation, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreGlossaryTranslationRequest} storeGlossaryTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public glossaryTranslationStore(storeGlossaryTranslationRequest: StoreGlossaryTranslationRequest, options?: RawAxiosRequestConfig) {
        return GlossaryTranslationApiFp(this.configuration).glossaryTranslationStore(storeGlossaryTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} glossaryTranslation The glossary translation ID
     * @param {UpdateGlossaryTranslationRequest} [updateGlossaryTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public glossaryTranslationUpdate(glossaryTranslation: string, updateGlossaryTranslationRequest?: UpdateGlossaryTranslationRequest, options?: RawAxiosRequestConfig) {
        return GlossaryTranslationApiFp(this.configuration).glossaryTranslationUpdate(glossaryTranslation, updateGlossaryTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} glossaryTranslation The glossary translation ID
     * @param {UpdateGlossaryTranslationRequest} [updateGlossaryTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public glossaryTranslationUpdate2(glossaryTranslation: string, updateGlossaryTranslationRequest?: UpdateGlossaryTranslationRequest, options?: RawAxiosRequestConfig) {
        return GlossaryTranslationApiFp(this.configuration).glossaryTranslationUpdate2(glossaryTranslation, updateGlossaryTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImageUploadApi - axios parameter creator
 */
export const ImageUploadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadDestroy: async (imageUpload: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageUpload' is not null or undefined
            assertParamExists('imageUploadDestroy', 'imageUpload', imageUpload)
            const localVarPath = `/image-upload/{imageUpload}`
                .replace(`{${"imageUpload"}}`, encodeURIComponent(String(imageUpload)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/image-upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadShow: async (imageUpload: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageUpload' is not null or undefined
            assertParamExists('imageUploadShow', 'imageUpload', imageUpload)
            const localVarPath = `/image-upload/{imageUpload}`
                .replace(`{${"imageUpload"}}`, encodeURIComponent(String(imageUpload)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the processing status. If processing is complete, returns the AvailableImage details. If the ImageUpload no longer exists, check if an AvailableImage exists with the same ID.
         * @summary Get the processing status of an image upload
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadStatus: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageUploadStatus', 'id', id)
            const localVarPath = `/image-upload/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadStore: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('imageUploadStore', 'file', file)
            const localVarPath = `/image-upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageUploadApi - functional programming interface
 */
export const ImageUploadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImageUploadApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadDestroy(imageUpload: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadDestroy(imageUpload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadShow(imageUpload: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadShow(imageUpload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the processing status. If processing is complete, returns the AvailableImage details. If the ImageUpload no longer exists, check if an AvailableImage exists with the same ID.
         * @summary Get the processing status of an image upload
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadStatus(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadStatus(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadStore(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadStore(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImageUploadApi - factory interface
 */
export const ImageUploadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImageUploadApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadDestroy(imageUpload: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.imageUploadDestroy(imageUpload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadIndex(options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadIndex200Response> {
            return localVarFp.imageUploadIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadShow(imageUpload: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadShow200Response> {
            return localVarFp.imageUploadShow(imageUpload, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the processing status. If processing is complete, returns the AvailableImage details. If the ImageUpload no longer exists, check if an AvailableImage exists with the same ID.
         * @summary Get the processing status of an image upload
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadStatus(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadStatus200Response> {
            return localVarFp.imageUploadStatus(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadStore(file: File, options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadShow200Response> {
            return localVarFp.imageUploadStore(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImageUploadApi - object-oriented interface
 */
export class ImageUploadApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} imageUpload The image upload ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public imageUploadDestroy(imageUpload: string, options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadDestroy(imageUpload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public imageUploadIndex(options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} imageUpload The image upload ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public imageUploadShow(imageUpload: string, options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadShow(imageUpload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the processing status. If processing is complete, returns the AvailableImage details. If the ImageUpload no longer exists, check if an AvailableImage exists with the same ID.
     * @summary Get the processing status of an image upload
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public imageUploadStatus(id: string, options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadStatus(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public imageUploadStore(file: File, options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadStore(file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InfoApi - axios parameter creator
 */
export const InfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lightweight endpoint for health monitoring that returns only the essential health status information.
         * @summary Get only the health check status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns basic application information including: - Application name and version - Health check status for key services - Timestamp of the response
         * @summary Get application information including version and health status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple endpoint that returns just the version information for deployment tracking and API compatibility checks.
         * @summary Get application version information only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoVersion: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoApi - functional programming interface
 */
export const InfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfoApiAxiosParamCreator(configuration)
    return {
        /**
         * Lightweight endpoint for health monitoring that returns only the essential health status information.
         * @summary Get only the health check status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infoHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infoHealth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.infoHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns basic application information including: - Application name and version - Health check status for key services - Timestamp of the response
         * @summary Get application information including version and health status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infoIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infoIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.infoIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simple endpoint that returns just the version information for deployment tracking and API compatibility checks.
         * @summary Get application version information only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infoVersion(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infoVersion(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.infoVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InfoApi - factory interface
 */
export const InfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfoApiFp(configuration)
    return {
        /**
         * Lightweight endpoint for health monitoring that returns only the essential health status information.
         * @summary Get only the health check status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoHealth(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.infoHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns basic application information including: - Application name and version - Health check status for key services - Timestamp of the response
         * @summary Get application information including version and health status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoIndex(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.infoIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * Simple endpoint that returns just the version information for deployment tracking and API compatibility checks.
         * @summary Get application version information only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoVersion(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.infoVersion(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfoApi - object-oriented interface
 */
export class InfoApi extends BaseAPI {
    /**
     * Lightweight endpoint for health monitoring that returns only the essential health status information.
     * @summary Get only the health check status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public infoHealth(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).infoHealth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns basic application information including: - Application name and version - Health check status for key services - Timestamp of the response
     * @summary Get application information including version and health status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public infoIndex(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).infoIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simple endpoint that returns just the version information for deployment tracking and API compatibility checks.
     * @summary Get application version information only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public infoVersion(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).infoVersion(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemApi - axios parameter creator
 */
export const ItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Attach a single tag to an item
         * @param {string} item The item ID
         * @param {AttachTagItemRequest} attachTagItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemAttachTag: async (item: string, attachTagItemRequest: AttachTagItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemAttachTag', 'item', item)
            // verify required parameter 'attachTagItemRequest' is not null or undefined
            assertParamExists('itemAttachTag', 'attachTagItemRequest', attachTagItemRequest)
            const localVarPath = `/item/{item}/attach-tag`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachTagItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Attach multiple tags to an item
         * @param {string} item The item ID
         * @param {AttachTagsItemRequest} attachTagsItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemAttachTags: async (item: string, attachTagsItemRequest: AttachTagsItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemAttachTags', 'item', item)
            // verify required parameter 'attachTagsItemRequest' is not null or undefined
            assertParamExists('itemAttachTags', 'attachTagsItemRequest', attachTagsItemRequest)
            const localVarPath = `/item/{item}/attach-tags`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachTagsItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get items by type
         * @param {string} type 
         * @param {ItemByTypeTypeEnum} type2 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemByType: async (type: string, type2: ItemByTypeTypeEnum, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('itemByType', 'type', type)
            // verify required parameter 'type2' is not null or undefined
            assertParamExists('itemByType', 'type2', type2)
            const localVarPath = `/item/type/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type2 !== undefined) {
                localVarQueryParameter['type'] = type2;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get child items (items with a parent)
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemChildren: async (include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item/children`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDestroy: async (item: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemDestroy', 'item', item)
            const localVarPath = `/item/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach a single tag from an item
         * @param {string} item The item ID
         * @param {string} tagId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDetachTag: async (item: string, tagId: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemDetachTag', 'item', item)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('itemDetachTag', 'tagId', tagId)
            const localVarPath = `/item/{item}/detach-tag`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (tagId !== undefined) {
                localVarQueryParameter['tag_id'] = tagId;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach multiple tags from an item
         * @param {string} item The item ID
         * @param {Array<string>} [tagIds] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDetachTags: async (item: string, tagIds?: Array<string>, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemDetachTags', 'item', item)
            const localVarPath = `/item/{item}/detach-tags`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (tagIds) {
                localVarQueryParameter['tag_ids[]'] = tagIds;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get items for a specific tag
         * @param {string} tag The tag ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemForTag: async (tag: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('itemForTag', 'tag', tag)
            const localVarPath = `/item/for-tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get parent items (items with no parent)
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemParents: async (include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item/parents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} item The item ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemShow: async (item: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemShow', 'item', item)
            const localVarPath = `/item/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreItemRequest} storeItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemStore: async (storeItemRequest: StoreItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeItemRequest' is not null or undefined
            assertParamExists('itemStore', 'storeItemRequest', storeItemRequest)
            const localVarPath = `/item`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} item The item ID
         * @param {UpdateItemRequest} [updateItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdate: async (item: string, updateItemRequest?: UpdateItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemUpdate', 'item', item)
            const localVarPath = `/item/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} item The item ID
         * @param {UpdateItemRequest} [updateItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdate2: async (item: string, updateItemRequest?: UpdateItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemUpdate2', 'item', item)
            const localVarPath = `/item/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the tags associated with an item. This endpoint handles attaching and/or detaching tags from an item using a single operation. Designed for granular tag management, allowing callers to perform specific tag attach/detach operations without requiring a full item update
         * @param {string} item - The item to update tags for
         * @param {UpdateTagsItemRequest} [updateTagsItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdateTags: async (item: string, updateTagsItemRequest?: UpdateTagsItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemUpdateTags', 'item', item)
            const localVarPath = `/item/{item}/tags`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagsItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get items that have ALL of the specified tags (AND condition)
         * @param {WithAllTagsItemRequest} withAllTagsItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemWithAllTags: async (withAllTagsItemRequest: WithAllTagsItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withAllTagsItemRequest' is not null or undefined
            assertParamExists('itemWithAllTags', 'withAllTagsItemRequest', withAllTagsItemRequest)
            const localVarPath = `/item/with-all-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(withAllTagsItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get items that have ANY of the specified tags (OR condition)
         * @param {WithAnyTagsItemRequest} withAnyTagsItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemWithAnyTags: async (withAnyTagsItemRequest: WithAnyTagsItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withAnyTagsItemRequest' is not null or undefined
            assertParamExists('itemWithAnyTags', 'withAnyTagsItemRequest', withAnyTagsItemRequest)
            const localVarPath = `/item/with-any-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(withAnyTagsItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemApi - functional programming interface
 */
export const ItemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Attach a single tag to an item
         * @param {string} item The item ID
         * @param {AttachTagItemRequest} attachTagItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemAttachTag(item: string, attachTagItemRequest: AttachTagItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemAttachTag(item, attachTagItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemAttachTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Attach multiple tags to an item
         * @param {string} item The item ID
         * @param {AttachTagsItemRequest} attachTagsItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemAttachTags(item: string, attachTagsItemRequest: AttachTagsItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemAttachTags(item, attachTagsItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemAttachTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get items by type
         * @param {string} type 
         * @param {ItemByTypeTypeEnum} type2 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemByType(type: string, type2: ItemByTypeTypeEnum, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemForTag200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemByType(type, type2, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemByType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get child items (items with a parent)
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemChildren(include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemForTag200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemChildren(include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemChildren']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemDestroy(item: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemDestroy(item, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Detach a single tag from an item
         * @param {string} item The item ID
         * @param {string} tagId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemDetachTag(item: string, tagId: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemDetachTag(item, tagId, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemDetachTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Detach multiple tags from an item
         * @param {string} item The item ID
         * @param {Array<string>} [tagIds] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemDetachTags(item: string, tagIds?: Array<string>, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemDetachTags(item, tagIds, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemDetachTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get items for a specific tag
         * @param {string} tag The tag ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemForTag(tag: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemForTag200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemForTag(tag, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemForTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get parent items (items with no parent)
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemParents(include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemForTag200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemParents(include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemParents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} item The item ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemShow(item: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemShow(item, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreItemRequest} storeItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemStore(storeItemRequest: StoreItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemStore(storeItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} item The item ID
         * @param {UpdateItemRequest} [updateItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemUpdate(item: string, updateItemRequest?: UpdateItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemUpdate(item, updateItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} item The item ID
         * @param {UpdateItemRequest} [updateItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemUpdate2(item: string, updateItemRequest?: UpdateItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemUpdate2(item, updateItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the tags associated with an item. This endpoint handles attaching and/or detaching tags from an item using a single operation. Designed for granular tag management, allowing callers to perform specific tag attach/detach operations without requiring a full item update
         * @param {string} item - The item to update tags for
         * @param {UpdateTagsItemRequest} [updateTagsItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemUpdateTags(item: string, updateTagsItemRequest?: UpdateTagsItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemUpdateTags(item, updateTagsItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemUpdateTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get items that have ALL of the specified tags (AND condition)
         * @param {WithAllTagsItemRequest} withAllTagsItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemWithAllTags(withAllTagsItemRequest: WithAllTagsItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemForTag200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemWithAllTags(withAllTagsItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemWithAllTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get items that have ANY of the specified tags (OR condition)
         * @param {WithAnyTagsItemRequest} withAnyTagsItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemWithAnyTags(withAnyTagsItemRequest: WithAnyTagsItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemForTag200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemWithAnyTags(withAnyTagsItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemWithAnyTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemApi - factory interface
 */
export const ItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemApiFp(configuration)
    return {
        /**
         * 
         * @summary Attach a single tag to an item
         * @param {string} item The item ID
         * @param {AttachTagItemRequest} attachTagItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemAttachTag(item: string, attachTagItemRequest: AttachTagItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemShow200Response> {
            return localVarFp.itemAttachTag(item, attachTagItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Attach multiple tags to an item
         * @param {string} item The item ID
         * @param {AttachTagsItemRequest} attachTagsItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemAttachTags(item: string, attachTagsItemRequest: AttachTagsItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemShow200Response> {
            return localVarFp.itemAttachTags(item, attachTagsItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get items by type
         * @param {string} type 
         * @param {ItemByTypeTypeEnum} type2 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemByType(type: string, type2: ItemByTypeTypeEnum, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemForTag200Response> {
            return localVarFp.itemByType(type, type2, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get child items (items with a parent)
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemChildren(include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemForTag200Response> {
            return localVarFp.itemChildren(include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDestroy(item: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.itemDestroy(item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detach a single tag from an item
         * @param {string} item The item ID
         * @param {string} tagId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDetachTag(item: string, tagId: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemShow200Response> {
            return localVarFp.itemDetachTag(item, tagId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detach multiple tags from an item
         * @param {string} item The item ID
         * @param {Array<string>} [tagIds] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDetachTags(item: string, tagIds?: Array<string>, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemShow200Response> {
            return localVarFp.itemDetachTags(item, tagIds, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get items for a specific tag
         * @param {string} tag The tag ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemForTag(tag: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemForTag200Response> {
            return localVarFp.itemForTag(tag, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemIndex200Response> {
            return localVarFp.itemIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get parent items (items with no parent)
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemParents(include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemForTag200Response> {
            return localVarFp.itemParents(include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} item The item ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemShow(item: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemShow200Response> {
            return localVarFp.itemShow(item, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreItemRequest} storeItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemStore(storeItemRequest: StoreItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemShow200Response> {
            return localVarFp.itemStore(storeItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} item The item ID
         * @param {UpdateItemRequest} [updateItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdate(item: string, updateItemRequest?: UpdateItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemShow200Response> {
            return localVarFp.itemUpdate(item, updateItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} item The item ID
         * @param {UpdateItemRequest} [updateItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdate2(item: string, updateItemRequest?: UpdateItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemShow200Response> {
            return localVarFp.itemUpdate2(item, updateItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the tags associated with an item. This endpoint handles attaching and/or detaching tags from an item using a single operation. Designed for granular tag management, allowing callers to perform specific tag attach/detach operations without requiring a full item update
         * @param {string} item - The item to update tags for
         * @param {UpdateTagsItemRequest} [updateTagsItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdateTags(item: string, updateTagsItemRequest?: UpdateTagsItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemShow200Response> {
            return localVarFp.itemUpdateTags(item, updateTagsItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get items that have ALL of the specified tags (AND condition)
         * @param {WithAllTagsItemRequest} withAllTagsItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemWithAllTags(withAllTagsItemRequest: WithAllTagsItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemForTag200Response> {
            return localVarFp.itemWithAllTags(withAllTagsItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get items that have ANY of the specified tags (OR condition)
         * @param {WithAnyTagsItemRequest} withAnyTagsItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemWithAnyTags(withAnyTagsItemRequest: WithAnyTagsItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemForTag200Response> {
            return localVarFp.itemWithAnyTags(withAnyTagsItemRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemApi - object-oriented interface
 */
export class ItemApi extends BaseAPI {
    /**
     * 
     * @summary Attach a single tag to an item
     * @param {string} item The item ID
     * @param {AttachTagItemRequest} attachTagItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemAttachTag(item: string, attachTagItemRequest: AttachTagItemRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemAttachTag(item, attachTagItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Attach multiple tags to an item
     * @param {string} item The item ID
     * @param {AttachTagsItemRequest} attachTagsItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemAttachTags(item: string, attachTagsItemRequest: AttachTagsItemRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemAttachTags(item, attachTagsItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get items by type
     * @param {string} type 
     * @param {ItemByTypeTypeEnum} type2 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemByType(type: string, type2: ItemByTypeTypeEnum, include?: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemByType(type, type2, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get child items (items with a parent)
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemChildren(include?: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemChildren(include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} item The item ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemDestroy(item: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemDestroy(item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detach a single tag from an item
     * @param {string} item The item ID
     * @param {string} tagId 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemDetachTag(item: string, tagId: string, include?: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemDetachTag(item, tagId, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detach multiple tags from an item
     * @param {string} item The item ID
     * @param {Array<string>} [tagIds] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemDetachTags(item: string, tagIds?: Array<string>, include?: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemDetachTags(item, tagIds, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get items for a specific tag
     * @param {string} tag The tag ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemForTag(tag: string, include?: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemForTag(tag, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get parent items (items with no parent)
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemParents(include?: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemParents(include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} item The item ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemShow(item: string, include?: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemShow(item, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreItemRequest} storeItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemStore(storeItemRequest: StoreItemRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemStore(storeItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} item The item ID
     * @param {UpdateItemRequest} [updateItemRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemUpdate(item: string, updateItemRequest?: UpdateItemRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemUpdate(item, updateItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} item The item ID
     * @param {UpdateItemRequest} [updateItemRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemUpdate2(item: string, updateItemRequest?: UpdateItemRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemUpdate2(item, updateItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the tags associated with an item. This endpoint handles attaching and/or detaching tags from an item using a single operation. Designed for granular tag management, allowing callers to perform specific tag attach/detach operations without requiring a full item update
     * @param {string} item - The item to update tags for
     * @param {UpdateTagsItemRequest} [updateTagsItemRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemUpdateTags(item: string, updateTagsItemRequest?: UpdateTagsItemRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemUpdateTags(item, updateTagsItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get items that have ALL of the specified tags (AND condition)
     * @param {WithAllTagsItemRequest} withAllTagsItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemWithAllTags(withAllTagsItemRequest: WithAllTagsItemRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemWithAllTags(withAllTagsItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get items that have ANY of the specified tags (OR condition)
     * @param {WithAnyTagsItemRequest} withAnyTagsItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemWithAnyTags(withAnyTagsItemRequest: WithAnyTagsItemRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemWithAnyTags(withAnyTagsItemRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ItemByTypeTypeEnum = {
    Object: 'object',
    Monument: 'monument',
    Detail: 'detail',
    Picture: 'picture'
} as const;
export type ItemByTypeTypeEnum = typeof ItemByTypeTypeEnum[keyof typeof ItemByTypeTypeEnum];


/**
 * ItemImageApi - axios parameter creator
 */
export const ItemImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Attach an available image to an item
         * @param {string} item The item ID
         * @param {AttachFromAvailableItemImageRequest} attachFromAvailableItemImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemAttachImage: async (item: string, attachFromAvailableItemImageRequest: AttachFromAvailableItemImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemAttachImage', 'item', item)
            // verify required parameter 'attachFromAvailableItemImageRequest' is not null or undefined
            assertParamExists('itemAttachImage', 'attachFromAvailableItemImageRequest', attachFromAvailableItemImageRequest)
            const localVarPath = `/item/{item}/attach-image`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachFromAvailableItemImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified item image
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageDestroy: async (itemImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageDestroy', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach an item image and convert it back to available image
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageDetach: async (itemImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageDetach', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}/detach`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageDownload: async (itemImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageDownload', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}/download`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move item image down in display order
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageMoveDown: async (itemImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageMoveDown', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}/move-down`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move item image up in display order
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageMoveUp: async (itemImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageMoveUp', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}/move-up`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified item image
         * @param {string} itemImage The item image ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageShow: async (itemImage: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageShow', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tighten ordering for all images of the item
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageTightenOrdering: async (itemImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageTightenOrdering', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}/tighten-ordering`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified item image
         * @param {string} itemImage The item image ID
         * @param {UpdateItemImageRequest} [updateItemImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageUpdate: async (itemImage: string, updateItemImageRequest?: UpdateItemImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageUpdate', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateItemImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified item image
         * @param {string} itemImage The item image ID
         * @param {UpdateItemImageRequest} [updateItemImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageUpdate2: async (itemImage: string, updateItemImageRequest?: UpdateItemImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageUpdate2', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateItemImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageView: async (itemImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageView', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}/view`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of item images for a specific item
         * @param {string} item The item ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImagesIndex: async (item: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemImagesIndex', 'item', item)
            const localVarPath = `/item/{item}/images`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created item image
         * @param {string} item The item ID
         * @param {StoreItemImageRequest} storeItemImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImagesStore: async (item: string, storeItemImageRequest: StoreItemImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemImagesStore', 'item', item)
            // verify required parameter 'storeItemImageRequest' is not null or undefined
            assertParamExists('itemImagesStore', 'storeItemImageRequest', storeItemImageRequest)
            const localVarPath = `/item/{item}/images`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeItemImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemImageApi - functional programming interface
 */
export const ItemImageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemImageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Attach an available image to an item
         * @param {string} item The item ID
         * @param {AttachFromAvailableItemImageRequest} attachFromAvailableItemImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemAttachImage(item: string, attachFromAvailableItemImageRequest: AttachFromAvailableItemImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemAttachImage(item, attachFromAvailableItemImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemAttachImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified item image
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageDestroy(itemImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageDestroy(itemImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Detach an item image and convert it back to available image
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageDetach(itemImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionImageTightenOrdering200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageDetach(itemImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageDetach']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageDownload(itemImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageDownload(itemImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageDownload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move item image down in display order
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageMoveDown(itemImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageMoveDown(itemImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageMoveDown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move item image up in display order
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageMoveUp(itemImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageMoveUp(itemImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageMoveUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified item image
         * @param {string} itemImage The item image ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageShow(itemImage: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageShow(itemImage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tighten ordering for all images of the item
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageTightenOrdering(itemImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionImageTightenOrdering200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageTightenOrdering(itemImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageTightenOrdering']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified item image
         * @param {string} itemImage The item image ID
         * @param {UpdateItemImageRequest} [updateItemImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageUpdate(itemImage: string, updateItemImageRequest?: UpdateItemImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageUpdate(itemImage, updateItemImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified item image
         * @param {string} itemImage The item image ID
         * @param {UpdateItemImageRequest} [updateItemImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageUpdate2(itemImage: string, updateItemImageRequest?: UpdateItemImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageUpdate2(itemImage, updateItemImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageView(itemImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageView(itemImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of item images for a specific item
         * @param {string} item The item ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImagesIndex(item: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImagesIndex(item, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImagesIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created item image
         * @param {string} item The item ID
         * @param {StoreItemImageRequest} storeItemImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImagesStore(item: string, storeItemImageRequest: StoreItemImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImagesStore(item, storeItemImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImagesStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemImageApi - factory interface
 */
export const ItemImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemImageApiFp(configuration)
    return {
        /**
         * 
         * @summary Attach an available image to an item
         * @param {string} item The item ID
         * @param {AttachFromAvailableItemImageRequest} attachFromAvailableItemImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemAttachImage(item: string, attachFromAvailableItemImageRequest: AttachFromAvailableItemImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesStore200Response> {
            return localVarFp.itemAttachImage(item, attachFromAvailableItemImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified item image
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageDestroy(itemImage: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.itemImageDestroy(itemImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detach an item image and convert it back to available image
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageDetach(itemImage: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionImageTightenOrdering200Response> {
            return localVarFp.itemImageDetach(itemImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageDownload(itemImage: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.itemImageDownload(itemImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move item image down in display order
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageMoveDown(itemImage: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesStore200Response> {
            return localVarFp.itemImageMoveDown(itemImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move item image up in display order
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageMoveUp(itemImage: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesStore200Response> {
            return localVarFp.itemImageMoveUp(itemImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified item image
         * @param {string} itemImage The item image ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageShow(itemImage: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesStore200Response> {
            return localVarFp.itemImageShow(itemImage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Tighten ordering for all images of the item
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageTightenOrdering(itemImage: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionImageTightenOrdering200Response> {
            return localVarFp.itemImageTightenOrdering(itemImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified item image
         * @param {string} itemImage The item image ID
         * @param {UpdateItemImageRequest} [updateItemImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageUpdate(itemImage: string, updateItemImageRequest?: UpdateItemImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesStore200Response> {
            return localVarFp.itemImageUpdate(itemImage, updateItemImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified item image
         * @param {string} itemImage The item image ID
         * @param {UpdateItemImageRequest} [updateItemImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageUpdate2(itemImage: string, updateItemImageRequest?: UpdateItemImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesStore200Response> {
            return localVarFp.itemImageUpdate2(itemImage, updateItemImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageView(itemImage: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.itemImageView(itemImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of item images for a specific item
         * @param {string} item The item ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImagesIndex(item: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesIndex200Response> {
            return localVarFp.itemImagesIndex(item, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created item image
         * @param {string} item The item ID
         * @param {StoreItemImageRequest} storeItemImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImagesStore(item: string, storeItemImageRequest: StoreItemImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesStore200Response> {
            return localVarFp.itemImagesStore(item, storeItemImageRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemImageApi - object-oriented interface
 */
export class ItemImageApi extends BaseAPI {
    /**
     * 
     * @summary Attach an available image to an item
     * @param {string} item The item ID
     * @param {AttachFromAvailableItemImageRequest} attachFromAvailableItemImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemAttachImage(item: string, attachFromAvailableItemImageRequest: AttachFromAvailableItemImageRequest, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemAttachImage(item, attachFromAvailableItemImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified item image
     * @param {string} itemImage The item image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImageDestroy(itemImage: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageDestroy(itemImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detach an item image and convert it back to available image
     * @param {string} itemImage The item image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImageDetach(itemImage: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageDetach(itemImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the file to the caller
     * @param {string} itemImage The item image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImageDownload(itemImage: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageDownload(itemImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move item image down in display order
     * @param {string} itemImage The item image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImageMoveDown(itemImage: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageMoveDown(itemImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move item image up in display order
     * @param {string} itemImage The item image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImageMoveUp(itemImage: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageMoveUp(itemImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified item image
     * @param {string} itemImage The item image ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImageShow(itemImage: string, include?: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageShow(itemImage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Tighten ordering for all images of the item
     * @param {string} itemImage The item image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImageTightenOrdering(itemImage: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageTightenOrdering(itemImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified item image
     * @param {string} itemImage The item image ID
     * @param {UpdateItemImageRequest} [updateItemImageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImageUpdate(itemImage: string, updateItemImageRequest?: UpdateItemImageRequest, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageUpdate(itemImage, updateItemImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified item image
     * @param {string} itemImage The item image ID
     * @param {UpdateItemImageRequest} [updateItemImageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImageUpdate2(itemImage: string, updateItemImageRequest?: UpdateItemImageRequest, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageUpdate2(itemImage, updateItemImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
     * @param {string} itemImage The item image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImageView(itemImage: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageView(itemImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of item images for a specific item
     * @param {string} item The item ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImagesIndex(item: string, include?: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImagesIndex(item, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created item image
     * @param {string} item The item ID
     * @param {StoreItemImageRequest} storeItemImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemImagesStore(item: string, storeItemImageRequest: StoreItemImageRequest, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImagesStore(item, storeItemImageRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemItemLinkApi - axios parameter creator
 */
export const ItemItemLinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} itemItemLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemItemLinkDestroy: async (itemItemLink: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemItemLink' is not null or undefined
            assertParamExists('itemItemLinkDestroy', 'itemItemLink', itemItemLink)
            const localVarPath = `/item-item-link/{itemItemLink}`
                .replace(`{${"itemItemLink"}}`, encodeURIComponent(String(itemItemLink)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sourceId] 
         * @param {string} [targetId] 
         * @param {string} [contextId] 
         * @param {string} [itemId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemItemLinkIndex: async (page?: number, perPage?: number, sourceId?: string, targetId?: string, contextId?: string, itemId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item-item-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['source_id'] = sourceId;
            }

            if (targetId !== undefined) {
                localVarQueryParameter['target_id'] = targetId;
            }

            if (contextId !== undefined) {
                localVarQueryParameter['context_id'] = contextId;
            }

            if (itemId !== undefined) {
                localVarQueryParameter['item_id'] = itemId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} itemItemLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemItemLinkShow: async (itemItemLink: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemItemLink' is not null or undefined
            assertParamExists('itemItemLinkShow', 'itemItemLink', itemItemLink)
            const localVarPath = `/item-item-link/{itemItemLink}`
                .replace(`{${"itemItemLink"}}`, encodeURIComponent(String(itemItemLink)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreItemItemLinkRequest} storeItemItemLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemItemLinkStore: async (storeItemItemLinkRequest: StoreItemItemLinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeItemItemLinkRequest' is not null or undefined
            assertParamExists('itemItemLinkStore', 'storeItemItemLinkRequest', storeItemItemLinkRequest)
            const localVarPath = `/item-item-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeItemItemLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} itemItemLink 
         * @param {UpdateItemItemLinkRequest} updateItemItemLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemItemLinkUpdate: async (itemItemLink: string, updateItemItemLinkRequest: UpdateItemItemLinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemItemLink' is not null or undefined
            assertParamExists('itemItemLinkUpdate', 'itemItemLink', itemItemLink)
            // verify required parameter 'updateItemItemLinkRequest' is not null or undefined
            assertParamExists('itemItemLinkUpdate', 'updateItemItemLinkRequest', updateItemItemLinkRequest)
            const localVarPath = `/item-item-link/{itemItemLink}`
                .replace(`{${"itemItemLink"}}`, encodeURIComponent(String(itemItemLink)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateItemItemLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} itemItemLink 
         * @param {UpdateItemItemLinkRequest} updateItemItemLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemItemLinkUpdate2: async (itemItemLink: string, updateItemItemLinkRequest: UpdateItemItemLinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemItemLink' is not null or undefined
            assertParamExists('itemItemLinkUpdate2', 'itemItemLink', itemItemLink)
            // verify required parameter 'updateItemItemLinkRequest' is not null or undefined
            assertParamExists('itemItemLinkUpdate2', 'updateItemItemLinkRequest', updateItemItemLinkRequest)
            const localVarPath = `/item-item-link/{itemItemLink}`
                .replace(`{${"itemItemLink"}}`, encodeURIComponent(String(itemItemLink)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateItemItemLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemItemLinkApi - functional programming interface
 */
export const ItemItemLinkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemItemLinkApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} itemItemLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemItemLinkDestroy(itemItemLink: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemItemLinkDestroy(itemItemLink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemItemLinkApi.itemItemLinkDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sourceId] 
         * @param {string} [targetId] 
         * @param {string} [contextId] 
         * @param {string} [itemId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemItemLinkIndex(page?: number, perPage?: number, sourceId?: string, targetId?: string, contextId?: string, itemId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemItemLinkIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemItemLinkIndex(page, perPage, sourceId, targetId, contextId, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemItemLinkApi.itemItemLinkIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} itemItemLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemItemLinkShow(itemItemLink: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemItemLinkShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemItemLinkShow(itemItemLink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemItemLinkApi.itemItemLinkShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreItemItemLinkRequest} storeItemItemLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemItemLinkStore(storeItemItemLinkRequest: StoreItemItemLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemItemLinkShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemItemLinkStore(storeItemItemLinkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemItemLinkApi.itemItemLinkStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} itemItemLink 
         * @param {UpdateItemItemLinkRequest} updateItemItemLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemItemLinkUpdate(itemItemLink: string, updateItemItemLinkRequest: UpdateItemItemLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemItemLinkShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemItemLinkUpdate(itemItemLink, updateItemItemLinkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemItemLinkApi.itemItemLinkUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} itemItemLink 
         * @param {UpdateItemItemLinkRequest} updateItemItemLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemItemLinkUpdate2(itemItemLink: string, updateItemItemLinkRequest: UpdateItemItemLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemItemLinkShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemItemLinkUpdate2(itemItemLink, updateItemItemLinkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemItemLinkApi.itemItemLinkUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemItemLinkApi - factory interface
 */
export const ItemItemLinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemItemLinkApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} itemItemLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemItemLinkDestroy(itemItemLink: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.itemItemLinkDestroy(itemItemLink, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sourceId] 
         * @param {string} [targetId] 
         * @param {string} [contextId] 
         * @param {string} [itemId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemItemLinkIndex(page?: number, perPage?: number, sourceId?: string, targetId?: string, contextId?: string, itemId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemItemLinkIndex200Response> {
            return localVarFp.itemItemLinkIndex(page, perPage, sourceId, targetId, contextId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} itemItemLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemItemLinkShow(itemItemLink: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemItemLinkShow200Response> {
            return localVarFp.itemItemLinkShow(itemItemLink, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreItemItemLinkRequest} storeItemItemLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemItemLinkStore(storeItemItemLinkRequest: StoreItemItemLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemItemLinkShow200Response> {
            return localVarFp.itemItemLinkStore(storeItemItemLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} itemItemLink 
         * @param {UpdateItemItemLinkRequest} updateItemItemLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemItemLinkUpdate(itemItemLink: string, updateItemItemLinkRequest: UpdateItemItemLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemItemLinkShow200Response> {
            return localVarFp.itemItemLinkUpdate(itemItemLink, updateItemItemLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} itemItemLink 
         * @param {UpdateItemItemLinkRequest} updateItemItemLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemItemLinkUpdate2(itemItemLink: string, updateItemItemLinkRequest: UpdateItemItemLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemItemLinkShow200Response> {
            return localVarFp.itemItemLinkUpdate2(itemItemLink, updateItemItemLinkRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemItemLinkApi - object-oriented interface
 */
export class ItemItemLinkApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} itemItemLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemItemLinkDestroy(itemItemLink: string, options?: RawAxiosRequestConfig) {
        return ItemItemLinkApiFp(this.configuration).itemItemLinkDestroy(itemItemLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [sourceId] 
     * @param {string} [targetId] 
     * @param {string} [contextId] 
     * @param {string} [itemId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemItemLinkIndex(page?: number, perPage?: number, sourceId?: string, targetId?: string, contextId?: string, itemId?: string, options?: RawAxiosRequestConfig) {
        return ItemItemLinkApiFp(this.configuration).itemItemLinkIndex(page, perPage, sourceId, targetId, contextId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} itemItemLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemItemLinkShow(itemItemLink: string, options?: RawAxiosRequestConfig) {
        return ItemItemLinkApiFp(this.configuration).itemItemLinkShow(itemItemLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreItemItemLinkRequest} storeItemItemLinkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemItemLinkStore(storeItemItemLinkRequest: StoreItemItemLinkRequest, options?: RawAxiosRequestConfig) {
        return ItemItemLinkApiFp(this.configuration).itemItemLinkStore(storeItemItemLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} itemItemLink 
     * @param {UpdateItemItemLinkRequest} updateItemItemLinkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemItemLinkUpdate(itemItemLink: string, updateItemItemLinkRequest: UpdateItemItemLinkRequest, options?: RawAxiosRequestConfig) {
        return ItemItemLinkApiFp(this.configuration).itemItemLinkUpdate(itemItemLink, updateItemItemLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} itemItemLink 
     * @param {UpdateItemItemLinkRequest} updateItemItemLinkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemItemLinkUpdate2(itemItemLink: string, updateItemItemLinkRequest: UpdateItemItemLinkRequest, options?: RawAxiosRequestConfig) {
        return ItemItemLinkApiFp(this.configuration).itemItemLinkUpdate2(itemItemLink, updateItemItemLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemTranslationApi - axios parameter creator
 */
export const ItemTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationDestroy: async (itemTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationDestroy', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [itemId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationIndex: async (page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (itemId !== undefined) {
                localVarQueryParameter['item_id'] = itemId;
            }

            if (languageId !== undefined) {
                localVarQueryParameter['language_id'] = languageId;
            }

            if (contextId !== undefined) {
                localVarQueryParameter['context_id'] = contextId;
            }

            if (defaultContext !== undefined) {
                localVarQueryParameter['default_context'] = defaultContext;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationShow: async (itemTranslation: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationShow', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {StoreItemTranslationRequest} storeItemTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationStore: async (storeItemTranslationRequest: StoreItemTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeItemTranslationRequest' is not null or undefined
            assertParamExists('itemTranslationStore', 'storeItemTranslationRequest', storeItemTranslationRequest)
            const localVarPath = `/item-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeItemTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate: async (itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationUpdate', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateItemTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate2: async (itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationUpdate2', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateItemTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemTranslationApi - functional programming interface
 */
export const ItemTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationDestroy(itemTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [itemId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationIndex(page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationIndex(page, perPage, itemId, languageId, contextId, defaultContext, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationShow(itemTranslation: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationShow(itemTranslation, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {StoreItemTranslationRequest} storeItemTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationStore(storeItemTranslationRequest: StoreItemTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationStore(storeItemTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationUpdate(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationUpdate(itemTranslation, updateItemTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationUpdate2(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationUpdate2(itemTranslation, updateItemTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemTranslationApi - factory interface
 */
export const ItemTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.itemTranslationDestroy(itemTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [itemId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationIndex(page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationIndex200Response> {
            return localVarFp.itemTranslationIndex(page, perPage, itemId, languageId, contextId, defaultContext, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationShow(itemTranslation: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationShow(itemTranslation, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {StoreItemTranslationRequest} storeItemTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationStore(storeItemTranslationRequest: StoreItemTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationStore(storeItemTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationUpdate(itemTranslation, updateItemTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate2(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationUpdate2(itemTranslation, updateItemTranslationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemTranslationApi - object-oriented interface
 */
export class ItemTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationDestroy(itemTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of item translations
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [itemId] 
     * @param {string} [languageId] 
     * @param {string} [contextId] 
     * @param {boolean} [defaultContext] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationIndex(page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationIndex(page, perPage, itemId, languageId, contextId, defaultContext, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationShow(itemTranslation: string, include?: string, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationShow(itemTranslation, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created item translation
     * @param {StoreItemTranslationRequest} storeItemTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationStore(storeItemTranslationRequest: StoreItemTranslationRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationStore(storeItemTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationUpdate(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationUpdate(itemTranslation, updateItemTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationUpdate2(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationUpdate2(itemTranslation, updateItemTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemTranslationsApi - axios parameter creator
 */
export const ItemTranslationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationDestroy: async (itemTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationDestroy', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [itemId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationIndex: async (page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (itemId !== undefined) {
                localVarQueryParameter['item_id'] = itemId;
            }

            if (languageId !== undefined) {
                localVarQueryParameter['language_id'] = languageId;
            }

            if (contextId !== undefined) {
                localVarQueryParameter['context_id'] = contextId;
            }

            if (defaultContext !== undefined) {
                localVarQueryParameter['default_context'] = defaultContext;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationShow: async (itemTranslation: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationShow', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {StoreItemTranslationRequest} storeItemTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationStore: async (storeItemTranslationRequest: StoreItemTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeItemTranslationRequest' is not null or undefined
            assertParamExists('itemTranslationStore', 'storeItemTranslationRequest', storeItemTranslationRequest)
            const localVarPath = `/item-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeItemTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate: async (itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationUpdate', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateItemTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate2: async (itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationUpdate2', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateItemTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemTranslationsApi - functional programming interface
 */
export const ItemTranslationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemTranslationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationDestroy(itemTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [itemId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationIndex(page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationIndex(page, perPage, itemId, languageId, contextId, defaultContext, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationShow(itemTranslation: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationShow(itemTranslation, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {StoreItemTranslationRequest} storeItemTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationStore(storeItemTranslationRequest: StoreItemTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationStore(storeItemTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationUpdate(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationUpdate(itemTranslation, updateItemTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationUpdate2(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationUpdate2(itemTranslation, updateItemTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemTranslationsApi - factory interface
 */
export const ItemTranslationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemTranslationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.itemTranslationDestroy(itemTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [itemId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationIndex(page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationIndex200Response> {
            return localVarFp.itemTranslationIndex(page, perPage, itemId, languageId, contextId, defaultContext, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationShow(itemTranslation: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationShow(itemTranslation, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {StoreItemTranslationRequest} storeItemTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationStore(storeItemTranslationRequest: StoreItemTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationStore(storeItemTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationUpdate(itemTranslation, updateItemTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate2(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationUpdate2(itemTranslation, updateItemTranslationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemTranslationsApi - object-oriented interface
 */
export class ItemTranslationsApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationDestroy(itemTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of item translations
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [itemId] 
     * @param {string} [languageId] 
     * @param {string} [contextId] 
     * @param {boolean} [defaultContext] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationIndex(page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationIndex(page, perPage, itemId, languageId, contextId, defaultContext, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationShow(itemTranslation: string, include?: string, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationShow(itemTranslation, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created item translation
     * @param {StoreItemTranslationRequest} storeItemTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationStore(storeItemTranslationRequest: StoreItemTranslationRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationStore(storeItemTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationUpdate(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationUpdate(itemTranslation, updateItemTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {UpdateItemTranslationRequest} [updateItemTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemTranslationUpdate2(itemTranslation: string, updateItemTranslationRequest?: UpdateItemTranslationRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationUpdate2(itemTranslation, updateItemTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LanguageApi - axios parameter creator
 */
export const LanguageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clear the default flag from any language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageClearDefault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/language/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageDestroy: async (language: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('languageDestroy', 'language', language)
            const localVarPath = `/language/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the default Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageGetDefault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/language/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the english Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageGetEnglish: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/language/english`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageIndex: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/language`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set or unset a Language as the default one
         * @param {string} language The language ID
         * @param {SetDefaultLanguageRequest} setDefaultLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageSetDefault: async (language: string, setDefaultLanguageRequest: SetDefaultLanguageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('languageSetDefault', 'language', language)
            // verify required parameter 'setDefaultLanguageRequest' is not null or undefined
            assertParamExists('languageSetDefault', 'setDefaultLanguageRequest', setDefaultLanguageRequest)
            const localVarPath = `/language/{language}/default`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setDefaultLanguageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageShow: async (language: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('languageShow', 'language', language)
            const localVarPath = `/language/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreLanguageRequest} storeLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageStore: async (storeLanguageRequest: StoreLanguageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeLanguageRequest' is not null or undefined
            assertParamExists('languageStore', 'storeLanguageRequest', storeLanguageRequest)
            const localVarPath = `/language`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeLanguageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} language The language ID
         * @param {UpdateLanguageRequest} updateLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageUpdate: async (language: string, updateLanguageRequest: UpdateLanguageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('languageUpdate', 'language', language)
            // verify required parameter 'updateLanguageRequest' is not null or undefined
            assertParamExists('languageUpdate', 'updateLanguageRequest', updateLanguageRequest)
            const localVarPath = `/language/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLanguageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} language The language ID
         * @param {UpdateLanguageRequest} updateLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageUpdate2: async (language: string, updateLanguageRequest: UpdateLanguageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('languageUpdate2', 'language', language)
            // verify required parameter 'updateLanguageRequest' is not null or undefined
            assertParamExists('languageUpdate2', 'updateLanguageRequest', updateLanguageRequest)
            const localVarPath = `/language/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLanguageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LanguageApi - functional programming interface
 */
export const LanguageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LanguageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Clear the default flag from any language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageClearDefault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextClearDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageClearDefault(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageClearDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageDestroy(language: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageDestroy(language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the default Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageGetDefault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageGetDefault(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageGetDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the english Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageGetEnglish(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageGetEnglish(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageGetEnglish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageIndex(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageIndex(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set or unset a Language as the default one
         * @param {string} language The language ID
         * @param {SetDefaultLanguageRequest} setDefaultLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageSetDefault(language: string, setDefaultLanguageRequest: SetDefaultLanguageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageSetDefault(language, setDefaultLanguageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageSetDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageShow(language: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageShow(language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreLanguageRequest} storeLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageStore(storeLanguageRequest: StoreLanguageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageStore(storeLanguageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} language The language ID
         * @param {UpdateLanguageRequest} updateLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageUpdate(language: string, updateLanguageRequest: UpdateLanguageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageUpdate(language, updateLanguageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} language The language ID
         * @param {UpdateLanguageRequest} updateLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageUpdate2(language: string, updateLanguageRequest: UpdateLanguageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageGetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageUpdate2(language, updateLanguageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LanguageApi - factory interface
 */
export const LanguageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LanguageApiFp(configuration)
    return {
        /**
         * 
         * @summary Clear the default flag from any language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageClearDefault(options?: RawAxiosRequestConfig): AxiosPromise<ContextClearDefault200Response> {
            return localVarFp.languageClearDefault(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageDestroy(language: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.languageDestroy(language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the default Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageGetDefault(options?: RawAxiosRequestConfig): AxiosPromise<LanguageGetDefault200Response> {
            return localVarFp.languageGetDefault(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the english Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageGetEnglish(options?: RawAxiosRequestConfig): AxiosPromise<LanguageGetDefault200Response> {
            return localVarFp.languageGetEnglish(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageIndex(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<LanguageIndex200Response> {
            return localVarFp.languageIndex(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set or unset a Language as the default one
         * @param {string} language The language ID
         * @param {SetDefaultLanguageRequest} setDefaultLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageSetDefault(language: string, setDefaultLanguageRequest: SetDefaultLanguageRequest, options?: RawAxiosRequestConfig): AxiosPromise<LanguageGetDefault200Response> {
            return localVarFp.languageSetDefault(language, setDefaultLanguageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageShow(language: string, options?: RawAxiosRequestConfig): AxiosPromise<LanguageGetDefault200Response> {
            return localVarFp.languageShow(language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreLanguageRequest} storeLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageStore(storeLanguageRequest: StoreLanguageRequest, options?: RawAxiosRequestConfig): AxiosPromise<LanguageGetDefault200Response> {
            return localVarFp.languageStore(storeLanguageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} language The language ID
         * @param {UpdateLanguageRequest} updateLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageUpdate(language: string, updateLanguageRequest: UpdateLanguageRequest, options?: RawAxiosRequestConfig): AxiosPromise<LanguageGetDefault200Response> {
            return localVarFp.languageUpdate(language, updateLanguageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} language The language ID
         * @param {UpdateLanguageRequest} updateLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageUpdate2(language: string, updateLanguageRequest: UpdateLanguageRequest, options?: RawAxiosRequestConfig): AxiosPromise<LanguageGetDefault200Response> {
            return localVarFp.languageUpdate2(language, updateLanguageRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LanguageApi - object-oriented interface
 */
export class LanguageApi extends BaseAPI {
    /**
     * 
     * @summary Clear the default flag from any language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageClearDefault(options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageClearDefault(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} language The language ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageDestroy(language: string, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageDestroy(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the default Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageGetDefault(options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageGetDefault(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the english Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageGetEnglish(options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageGetEnglish(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageIndex(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageIndex(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set or unset a Language as the default one
     * @param {string} language The language ID
     * @param {SetDefaultLanguageRequest} setDefaultLanguageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageSetDefault(language: string, setDefaultLanguageRequest: SetDefaultLanguageRequest, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageSetDefault(language, setDefaultLanguageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} language The language ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageShow(language: string, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageShow(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreLanguageRequest} storeLanguageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageStore(storeLanguageRequest: StoreLanguageRequest, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageStore(storeLanguageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} language The language ID
     * @param {UpdateLanguageRequest} updateLanguageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageUpdate(language: string, updateLanguageRequest: UpdateLanguageRequest, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageUpdate(language, updateLanguageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} language The language ID
     * @param {UpdateLanguageRequest} updateLanguageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageUpdate2(language: string, updateLanguageRequest: UpdateLanguageRequest, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageUpdate2(language, updateLanguageRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LanguageTranslationApi - axios parameter creator
 */
export const LanguageTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} languageTranslation The language translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageTranslationDestroy: async (languageTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'languageTranslation' is not null or undefined
            assertParamExists('languageTranslationDestroy', 'languageTranslation', languageTranslation)
            const localVarPath = `/language-translation/{languageTranslation}`
                .replace(`{${"languageTranslation"}}`, encodeURIComponent(String(languageTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageTranslationIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/language-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} languageTranslation The language translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageTranslationShow: async (languageTranslation: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'languageTranslation' is not null or undefined
            assertParamExists('languageTranslationShow', 'languageTranslation', languageTranslation)
            const localVarPath = `/language-translation/{languageTranslation}`
                .replace(`{${"languageTranslation"}}`, encodeURIComponent(String(languageTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreLanguageTranslationRequest} storeLanguageTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageTranslationStore: async (storeLanguageTranslationRequest: StoreLanguageTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeLanguageTranslationRequest' is not null or undefined
            assertParamExists('languageTranslationStore', 'storeLanguageTranslationRequest', storeLanguageTranslationRequest)
            const localVarPath = `/language-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeLanguageTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} languageTranslation The language translation ID
         * @param {UpdateLanguageTranslationRequest} [updateLanguageTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageTranslationUpdate: async (languageTranslation: string, updateLanguageTranslationRequest?: UpdateLanguageTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'languageTranslation' is not null or undefined
            assertParamExists('languageTranslationUpdate', 'languageTranslation', languageTranslation)
            const localVarPath = `/language-translation/{languageTranslation}`
                .replace(`{${"languageTranslation"}}`, encodeURIComponent(String(languageTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLanguageTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} languageTranslation The language translation ID
         * @param {UpdateLanguageTranslationRequest} [updateLanguageTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageTranslationUpdate2: async (languageTranslation: string, updateLanguageTranslationRequest?: UpdateLanguageTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'languageTranslation' is not null or undefined
            assertParamExists('languageTranslationUpdate2', 'languageTranslation', languageTranslation)
            const localVarPath = `/language-translation/{languageTranslation}`
                .replace(`{${"languageTranslation"}}`, encodeURIComponent(String(languageTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLanguageTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LanguageTranslationApi - functional programming interface
 */
export const LanguageTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LanguageTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} languageTranslation The language translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageTranslationDestroy(languageTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageTranslationDestroy(languageTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageTranslationApi.languageTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageTranslationIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageTranslationIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageTranslationApi.languageTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} languageTranslation The language translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageTranslationShow(languageTranslation: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageTranslationShow(languageTranslation, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageTranslationApi.languageTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreLanguageTranslationRequest} storeLanguageTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageTranslationStore(storeLanguageTranslationRequest: StoreLanguageTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageTranslationStore(storeLanguageTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageTranslationApi.languageTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} languageTranslation The language translation ID
         * @param {UpdateLanguageTranslationRequest} [updateLanguageTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageTranslationUpdate(languageTranslation: string, updateLanguageTranslationRequest?: UpdateLanguageTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageTranslationUpdate(languageTranslation, updateLanguageTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageTranslationApi.languageTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} languageTranslation The language translation ID
         * @param {UpdateLanguageTranslationRequest} [updateLanguageTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageTranslationUpdate2(languageTranslation: string, updateLanguageTranslationRequest?: UpdateLanguageTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageTranslationUpdate2(languageTranslation, updateLanguageTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageTranslationApi.languageTranslationUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LanguageTranslationApi - factory interface
 */
export const LanguageTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LanguageTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} languageTranslation The language translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageTranslationDestroy(languageTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.languageTranslationDestroy(languageTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageTranslationIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<LanguageTranslationIndex200Response> {
            return localVarFp.languageTranslationIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} languageTranslation The language translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageTranslationShow(languageTranslation: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<LanguageTranslationShow200Response> {
            return localVarFp.languageTranslationShow(languageTranslation, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreLanguageTranslationRequest} storeLanguageTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageTranslationStore(storeLanguageTranslationRequest: StoreLanguageTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<LanguageTranslationShow200Response> {
            return localVarFp.languageTranslationStore(storeLanguageTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} languageTranslation The language translation ID
         * @param {UpdateLanguageTranslationRequest} [updateLanguageTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageTranslationUpdate(languageTranslation: string, updateLanguageTranslationRequest?: UpdateLanguageTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<LanguageTranslationShow200Response> {
            return localVarFp.languageTranslationUpdate(languageTranslation, updateLanguageTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} languageTranslation The language translation ID
         * @param {UpdateLanguageTranslationRequest} [updateLanguageTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageTranslationUpdate2(languageTranslation: string, updateLanguageTranslationRequest?: UpdateLanguageTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<LanguageTranslationShow200Response> {
            return localVarFp.languageTranslationUpdate2(languageTranslation, updateLanguageTranslationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LanguageTranslationApi - object-oriented interface
 */
export class LanguageTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} languageTranslation The language translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageTranslationDestroy(languageTranslation: string, options?: RawAxiosRequestConfig) {
        return LanguageTranslationApiFp(this.configuration).languageTranslationDestroy(languageTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageTranslationIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return LanguageTranslationApiFp(this.configuration).languageTranslationIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} languageTranslation The language translation ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageTranslationShow(languageTranslation: string, include?: string, options?: RawAxiosRequestConfig) {
        return LanguageTranslationApiFp(this.configuration).languageTranslationShow(languageTranslation, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreLanguageTranslationRequest} storeLanguageTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageTranslationStore(storeLanguageTranslationRequest: StoreLanguageTranslationRequest, options?: RawAxiosRequestConfig) {
        return LanguageTranslationApiFp(this.configuration).languageTranslationStore(storeLanguageTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} languageTranslation The language translation ID
     * @param {UpdateLanguageTranslationRequest} [updateLanguageTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageTranslationUpdate(languageTranslation: string, updateLanguageTranslationRequest?: UpdateLanguageTranslationRequest, options?: RawAxiosRequestConfig) {
        return LanguageTranslationApiFp(this.configuration).languageTranslationUpdate(languageTranslation, updateLanguageTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} languageTranslation The language translation ID
     * @param {UpdateLanguageTranslationRequest} [updateLanguageTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public languageTranslationUpdate2(languageTranslation: string, updateLanguageTranslationRequest?: UpdateLanguageTranslationRequest, options?: RawAxiosRequestConfig) {
        return LanguageTranslationApiFp(this.configuration).languageTranslationUpdate2(languageTranslation, updateLanguageTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationApi - axios parameter creator
 */
export const LocationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified location
         * @param {string} location The location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationDestroy: async (location: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('locationDestroy', 'location', location)
            const localVarPath = `/location/{location}`
                .replace(`{${"location"}}`, encodeURIComponent(String(location)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of locations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified location
         * @param {string} location The location ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationShow: async (location: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('locationShow', 'location', location)
            const localVarPath = `/location/{location}`
                .replace(`{${"location"}}`, encodeURIComponent(String(location)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created location
         * @param {StoreLocationRequest} storeLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationStore: async (storeLocationRequest: StoreLocationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeLocationRequest' is not null or undefined
            assertParamExists('locationStore', 'storeLocationRequest', storeLocationRequest)
            const localVarPath = `/location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified location
         * @param {string} location The location ID
         * @param {UpdateLocationRequest} updateLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationUpdate: async (location: string, updateLocationRequest: UpdateLocationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('locationUpdate', 'location', location)
            // verify required parameter 'updateLocationRequest' is not null or undefined
            assertParamExists('locationUpdate', 'updateLocationRequest', updateLocationRequest)
            const localVarPath = `/location/{location}`
                .replace(`{${"location"}}`, encodeURIComponent(String(location)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified location
         * @param {string} location The location ID
         * @param {UpdateLocationRequest} updateLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationUpdate2: async (location: string, updateLocationRequest: UpdateLocationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('locationUpdate2', 'location', location)
            // verify required parameter 'updateLocationRequest' is not null or undefined
            assertParamExists('locationUpdate2', 'updateLocationRequest', updateLocationRequest)
            const localVarPath = `/location/{location}`
                .replace(`{${"location"}}`, encodeURIComponent(String(location)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationApi - functional programming interface
 */
export const LocationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified location
         * @param {string} location The location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationDestroy(location: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationDestroy(location, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of locations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified location
         * @param {string} location The location ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationShow(location: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationShow(location, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created location
         * @param {StoreLocationRequest} storeLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationStore(storeLocationRequest: StoreLocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationStore(storeLocationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified location
         * @param {string} location The location ID
         * @param {UpdateLocationRequest} updateLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationUpdate(location: string, updateLocationRequest: UpdateLocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationUpdate(location, updateLocationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified location
         * @param {string} location The location ID
         * @param {UpdateLocationRequest} updateLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationUpdate2(location: string, updateLocationRequest: UpdateLocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationUpdate2(location, updateLocationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationApi - factory interface
 */
export const LocationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified location
         * @param {string} location The location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationDestroy(location: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.locationDestroy(location, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of locations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<LocationIndex200Response> {
            return localVarFp.locationIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified location
         * @param {string} location The location ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationShow(location: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<LocationShow200Response> {
            return localVarFp.locationShow(location, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created location
         * @param {StoreLocationRequest} storeLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationStore(storeLocationRequest: StoreLocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationShow200Response> {
            return localVarFp.locationStore(storeLocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified location
         * @param {string} location The location ID
         * @param {UpdateLocationRequest} updateLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationUpdate(location: string, updateLocationRequest: UpdateLocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationShow200Response> {
            return localVarFp.locationUpdate(location, updateLocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified location
         * @param {string} location The location ID
         * @param {UpdateLocationRequest} updateLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationUpdate2(location: string, updateLocationRequest: UpdateLocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationShow200Response> {
            return localVarFp.locationUpdate2(location, updateLocationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationApi - object-oriented interface
 */
export class LocationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified location
     * @param {string} location The location ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationDestroy(location: string, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationDestroy(location, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of locations
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified location
     * @param {string} location The location ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationShow(location: string, include?: string, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationShow(location, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created location
     * @param {StoreLocationRequest} storeLocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationStore(storeLocationRequest: StoreLocationRequest, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationStore(storeLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified location
     * @param {string} location The location ID
     * @param {UpdateLocationRequest} updateLocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationUpdate(location: string, updateLocationRequest: UpdateLocationRequest, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationUpdate(location, updateLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified location
     * @param {string} location The location ID
     * @param {UpdateLocationRequest} updateLocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationUpdate2(location: string, updateLocationRequest: UpdateLocationRequest, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationUpdate2(location, updateLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationTranslationApi - axios parameter creator
 */
export const LocationTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationDestroy: async (locationTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationTranslation' is not null or undefined
            assertParamExists('locationTranslationDestroy', 'locationTranslation', locationTranslation)
            const localVarPath = `/location-translation/{locationTranslation}`
                .replace(`{${"locationTranslation"}}`, encodeURIComponent(String(locationTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/location-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationShow: async (locationTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationTranslation' is not null or undefined
            assertParamExists('locationTranslationShow', 'locationTranslation', locationTranslation)
            const localVarPath = `/location-translation/{locationTranslation}`
                .replace(`{${"locationTranslation"}}`, encodeURIComponent(String(locationTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreLocationTranslationRequest} storeLocationTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationStore: async (storeLocationTranslationRequest: StoreLocationTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeLocationTranslationRequest' is not null or undefined
            assertParamExists('locationTranslationStore', 'storeLocationTranslationRequest', storeLocationTranslationRequest)
            const localVarPath = `/location-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeLocationTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} locationTranslation The location translation ID
         * @param {UpdateLocationTranslationRequest} [updateLocationTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationUpdate: async (locationTranslation: string, updateLocationTranslationRequest?: UpdateLocationTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationTranslation' is not null or undefined
            assertParamExists('locationTranslationUpdate', 'locationTranslation', locationTranslation)
            const localVarPath = `/location-translation/{locationTranslation}`
                .replace(`{${"locationTranslation"}}`, encodeURIComponent(String(locationTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLocationTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} locationTranslation The location translation ID
         * @param {UpdateLocationTranslationRequest} [updateLocationTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationUpdate2: async (locationTranslation: string, updateLocationTranslationRequest?: UpdateLocationTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationTranslation' is not null or undefined
            assertParamExists('locationTranslationUpdate2', 'locationTranslation', locationTranslation)
            const localVarPath = `/location-translation/{locationTranslation}`
                .replace(`{${"locationTranslation"}}`, encodeURIComponent(String(locationTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLocationTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationTranslationApi - functional programming interface
 */
export const LocationTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationDestroy(locationTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationDestroy(locationTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationShow(locationTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationShow(locationTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreLocationTranslationRequest} storeLocationTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationStore(storeLocationTranslationRequest: StoreLocationTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationStore(storeLocationTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} locationTranslation The location translation ID
         * @param {UpdateLocationTranslationRequest} [updateLocationTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationUpdate(locationTranslation: string, updateLocationTranslationRequest?: UpdateLocationTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationUpdate(locationTranslation, updateLocationTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} locationTranslation The location translation ID
         * @param {UpdateLocationTranslationRequest} [updateLocationTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationUpdate2(locationTranslation: string, updateLocationTranslationRequest?: UpdateLocationTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationUpdate2(locationTranslation, updateLocationTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationTranslationApi - factory interface
 */
export const LocationTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationDestroy(locationTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.locationTranslationDestroy(locationTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<LocationTranslationIndex200Response> {
            return localVarFp.locationTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationShow(locationTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<LocationTranslationShow200Response> {
            return localVarFp.locationTranslationShow(locationTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreLocationTranslationRequest} storeLocationTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationStore(storeLocationTranslationRequest: StoreLocationTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationTranslationShow200Response> {
            return localVarFp.locationTranslationStore(storeLocationTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} locationTranslation The location translation ID
         * @param {UpdateLocationTranslationRequest} [updateLocationTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationUpdate(locationTranslation: string, updateLocationTranslationRequest?: UpdateLocationTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationTranslationShow200Response> {
            return localVarFp.locationTranslationUpdate(locationTranslation, updateLocationTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} locationTranslation The location translation ID
         * @param {UpdateLocationTranslationRequest} [updateLocationTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationUpdate2(locationTranslation: string, updateLocationTranslationRequest?: UpdateLocationTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationTranslationShow200Response> {
            return localVarFp.locationTranslationUpdate2(locationTranslation, updateLocationTranslationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationTranslationApi - object-oriented interface
 */
export class LocationTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} locationTranslation The location translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationTranslationDestroy(locationTranslation: string, options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationDestroy(locationTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationTranslationIndex(options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} locationTranslation The location translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationTranslationShow(locationTranslation: string, options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationShow(locationTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreLocationTranslationRequest} storeLocationTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationTranslationStore(storeLocationTranslationRequest: StoreLocationTranslationRequest, options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationStore(storeLocationTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} locationTranslation The location translation ID
     * @param {UpdateLocationTranslationRequest} [updateLocationTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationTranslationUpdate(locationTranslation: string, updateLocationTranslationRequest?: UpdateLocationTranslationRequest, options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationUpdate(locationTranslation, updateLocationTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} locationTranslation The location translation ID
     * @param {UpdateLocationTranslationRequest} [updateLocationTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationTranslationUpdate2(locationTranslation: string, updateLocationTranslationRequest?: UpdateLocationTranslationRequest, options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationUpdate2(locationTranslation, updateLocationTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MarkdownApi - axios parameter creator
 */
export const MarkdownApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownAllowedElements: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markdown/allowed-elements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownFromHtml: async (markdownFromHtmlRequest: MarkdownFromHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownFromHtmlRequest' is not null or undefined
            assertParamExists('markdownFromHtml', 'markdownFromHtmlRequest', markdownFromHtmlRequest)
            const localVarPath = `/markdown/from-html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownFromHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownIsMarkdown: async (markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownIsMarkdownRequest' is not null or undefined
            assertParamExists('markdownIsMarkdown', 'markdownIsMarkdownRequest', markdownIsMarkdownRequest)
            const localVarPath = `/markdown/is-markdown`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownIsMarkdownRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownPreview: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markdown/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownToHtml: async (markdownToHtmlRequest: MarkdownToHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownToHtmlRequest' is not null or undefined
            assertParamExists('markdownToHtml', 'markdownToHtmlRequest', markdownToHtmlRequest)
            const localVarPath = `/markdown/to-html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownToHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownValidate: async (markdownToHtmlRequest: MarkdownToHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownToHtmlRequest' is not null or undefined
            assertParamExists('markdownValidate', 'markdownToHtmlRequest', markdownToHtmlRequest)
            const localVarPath = `/markdown/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownToHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarkdownApi - functional programming interface
 */
export const MarkdownApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarkdownApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownAllowedElements(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownAllowedElements(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownAllowedElements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownFromHtml(markdownFromHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownFromHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownIsMarkdown(markdownIsMarkdownRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownIsMarkdown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownPreview(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownPreview(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownPreview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownToHtml(markdownToHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownToHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownValidate(markdownToHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownValidate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MarkdownApi - factory interface
 */
export const MarkdownApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarkdownApiFp(configuration)
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownAllowedElements(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownAllowedElements(options).then((request) => request(axios, basePath));
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownFromHtml(markdownFromHtmlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownIsMarkdown(markdownIsMarkdownRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownPreview(options?: RawAxiosRequestConfig): AxiosPromise<ConversionResource> {
            return localVarFp.markdownPreview(options).then((request) => request(axios, basePath));
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownToHtml(markdownToHtmlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownValidate(markdownToHtmlRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarkdownApi - object-oriented interface
 */
export class MarkdownApi extends BaseAPI {
    /**
     * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
     * @summary Get allowed HTML tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownAllowedElements(options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownAllowedElements(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
     * @summary Convert HTML to Markdown
     * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownFromHtml(markdownFromHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
     * @summary Check if content is Markdown
     * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownIsMarkdown(markdownIsMarkdownRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
     * @summary Preview Markdown content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownPreview(options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownPreview(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
     * @summary Convert Markdown to HTML
     * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownToHtml(markdownToHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates Markdown content without converting it, useful for form validation.
     * @summary Validate Markdown content
     * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownValidate(markdownToHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi - axios parameter creator
 */
export const MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownAllowedElements: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markdown/allowed-elements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownFromHtml: async (markdownFromHtmlRequest: MarkdownFromHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownFromHtmlRequest' is not null or undefined
            assertParamExists('markdownFromHtml', 'markdownFromHtmlRequest', markdownFromHtmlRequest)
            const localVarPath = `/markdown/from-html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownFromHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownIsMarkdown: async (markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownIsMarkdownRequest' is not null or undefined
            assertParamExists('markdownIsMarkdown', 'markdownIsMarkdownRequest', markdownIsMarkdownRequest)
            const localVarPath = `/markdown/is-markdown`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownIsMarkdownRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownPreview: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markdown/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownToHtml: async (markdownToHtmlRequest: MarkdownToHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownToHtmlRequest' is not null or undefined
            assertParamExists('markdownToHtml', 'markdownToHtmlRequest', markdownToHtmlRequest)
            const localVarPath = `/markdown/to-html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownToHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownValidate: async (markdownToHtmlRequest: MarkdownToHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownToHtmlRequest' is not null or undefined
            assertParamExists('markdownValidate', 'markdownToHtmlRequest', markdownToHtmlRequest)
            const localVarPath = `/markdown/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownToHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi - functional programming interface
 */
export const MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownAllowedElements(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownAllowedElements(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownAllowedElements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownFromHtml(markdownFromHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownFromHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownIsMarkdown(markdownIsMarkdownRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownIsMarkdown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownPreview(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownPreview(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownPreview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownToHtml(markdownToHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownToHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownValidate(markdownToHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownValidate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi - factory interface
 */
export const MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(configuration)
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownAllowedElements(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownAllowedElements(options).then((request) => request(axios, basePath));
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownFromHtml(markdownFromHtmlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownIsMarkdown(markdownIsMarkdownRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownPreview(options?: RawAxiosRequestConfig): AxiosPromise<ConversionResource> {
            return localVarFp.markdownPreview(options).then((request) => request(axios, basePath));
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownToHtml(markdownToHtmlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownValidate(markdownToHtmlRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi - object-oriented interface
 */
export class MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi extends BaseAPI {
    /**
     * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
     * @summary Get allowed HTML tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownAllowedElements(options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownAllowedElements(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
     * @summary Convert HTML to Markdown
     * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownFromHtml(markdownFromHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
     * @summary Check if content is Markdown
     * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownIsMarkdown(markdownIsMarkdownRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
     * @summary Preview Markdown content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownPreview(options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownPreview(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
     * @summary Convert Markdown to HTML
     * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownToHtml(markdownToHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates Markdown content without converting it, useful for form validation.
     * @summary Validate Markdown content
     * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownValidate(markdownToHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MobileAppAuthenticationApi - axios parameter creator
 */
export const MobileAppAuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Acquire a token for the user
         * @param {AcquireTokenMobileAppAuthenticationRequest} acquireTokenMobileAppAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenAcquire: async (acquireTokenMobileAppAuthenticationRequest: AcquireTokenMobileAppAuthenticationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acquireTokenMobileAppAuthenticationRequest' is not null or undefined
            assertParamExists('tokenAcquire', 'acquireTokenMobileAppAuthenticationRequest', acquireTokenMobileAppAuthenticationRequest)
            const localVarPath = `/mobile/acquire-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(acquireTokenMobileAppAuthenticationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user\'s 2FA status
         * @param {TwoFactorStatusMobileAppAuthenticationRequest} twoFactorStatusMobileAppAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenTwoFactorStatus: async (twoFactorStatusMobileAppAuthenticationRequest: TwoFactorStatusMobileAppAuthenticationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFactorStatusMobileAppAuthenticationRequest' is not null or undefined
            assertParamExists('tokenTwoFactorStatus', 'twoFactorStatusMobileAppAuthenticationRequest', twoFactorStatusMobileAppAuthenticationRequest)
            const localVarPath = `/mobile/two-factor-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFactorStatusMobileAppAuthenticationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify two-factor authentication and acquire token
         * @param {VerifyTwoFactorMobileAppAuthenticationRequest} verifyTwoFactorMobileAppAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenVerifyTwoFactor: async (verifyTwoFactorMobileAppAuthenticationRequest: VerifyTwoFactorMobileAppAuthenticationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyTwoFactorMobileAppAuthenticationRequest' is not null or undefined
            assertParamExists('tokenVerifyTwoFactor', 'verifyTwoFactorMobileAppAuthenticationRequest', verifyTwoFactorMobileAppAuthenticationRequest)
            const localVarPath = `/mobile/verify-two-factor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyTwoFactorMobileAppAuthenticationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke all the token for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenWipe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mobile/wipe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MobileAppAuthenticationApi - functional programming interface
 */
export const MobileAppAuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MobileAppAuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Acquire a token for the user
         * @param {AcquireTokenMobileAppAuthenticationRequest} acquireTokenMobileAppAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenAcquire(acquireTokenMobileAppAuthenticationRequest: AcquireTokenMobileAppAuthenticationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenAcquire201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenAcquire(acquireTokenMobileAppAuthenticationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MobileAppAuthenticationApi.tokenAcquire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user\'s 2FA status
         * @param {TwoFactorStatusMobileAppAuthenticationRequest} twoFactorStatusMobileAppAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenTwoFactorStatus(twoFactorStatusMobileAppAuthenticationRequest: TwoFactorStatusMobileAppAuthenticationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenTwoFactorStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenTwoFactorStatus(twoFactorStatusMobileAppAuthenticationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MobileAppAuthenticationApi.tokenTwoFactorStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify two-factor authentication and acquire token
         * @param {VerifyTwoFactorMobileAppAuthenticationRequest} verifyTwoFactorMobileAppAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenVerifyTwoFactor(verifyTwoFactorMobileAppAuthenticationRequest: VerifyTwoFactorMobileAppAuthenticationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenVerifyTwoFactor201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenVerifyTwoFactor(verifyTwoFactorMobileAppAuthenticationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MobileAppAuthenticationApi.tokenVerifyTwoFactor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Revoke all the token for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenWipe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenWipe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MobileAppAuthenticationApi.tokenWipe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MobileAppAuthenticationApi - factory interface
 */
export const MobileAppAuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MobileAppAuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary Acquire a token for the user
         * @param {AcquireTokenMobileAppAuthenticationRequest} acquireTokenMobileAppAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenAcquire(acquireTokenMobileAppAuthenticationRequest: AcquireTokenMobileAppAuthenticationRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenAcquire201Response> {
            return localVarFp.tokenAcquire(acquireTokenMobileAppAuthenticationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user\'s 2FA status
         * @param {TwoFactorStatusMobileAppAuthenticationRequest} twoFactorStatusMobileAppAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenTwoFactorStatus(twoFactorStatusMobileAppAuthenticationRequest: TwoFactorStatusMobileAppAuthenticationRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenTwoFactorStatus200Response> {
            return localVarFp.tokenTwoFactorStatus(twoFactorStatusMobileAppAuthenticationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify two-factor authentication and acquire token
         * @param {VerifyTwoFactorMobileAppAuthenticationRequest} verifyTwoFactorMobileAppAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenVerifyTwoFactor(verifyTwoFactorMobileAppAuthenticationRequest: VerifyTwoFactorMobileAppAuthenticationRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenVerifyTwoFactor201Response> {
            return localVarFp.tokenVerifyTwoFactor(verifyTwoFactorMobileAppAuthenticationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke all the token for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenWipe(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tokenWipe(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MobileAppAuthenticationApi - object-oriented interface
 */
export class MobileAppAuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Acquire a token for the user
     * @param {AcquireTokenMobileAppAuthenticationRequest} acquireTokenMobileAppAuthenticationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tokenAcquire(acquireTokenMobileAppAuthenticationRequest: AcquireTokenMobileAppAuthenticationRequest, options?: RawAxiosRequestConfig) {
        return MobileAppAuthenticationApiFp(this.configuration).tokenAcquire(acquireTokenMobileAppAuthenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user\'s 2FA status
     * @param {TwoFactorStatusMobileAppAuthenticationRequest} twoFactorStatusMobileAppAuthenticationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tokenTwoFactorStatus(twoFactorStatusMobileAppAuthenticationRequest: TwoFactorStatusMobileAppAuthenticationRequest, options?: RawAxiosRequestConfig) {
        return MobileAppAuthenticationApiFp(this.configuration).tokenTwoFactorStatus(twoFactorStatusMobileAppAuthenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify two-factor authentication and acquire token
     * @param {VerifyTwoFactorMobileAppAuthenticationRequest} verifyTwoFactorMobileAppAuthenticationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tokenVerifyTwoFactor(verifyTwoFactorMobileAppAuthenticationRequest: VerifyTwoFactorMobileAppAuthenticationRequest, options?: RawAxiosRequestConfig) {
        return MobileAppAuthenticationApiFp(this.configuration).tokenVerifyTwoFactor(verifyTwoFactorMobileAppAuthenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke all the token for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tokenWipe(options?: RawAxiosRequestConfig) {
        return MobileAppAuthenticationApiFp(this.configuration).tokenWipe(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PartnerApi - axios parameter creator
 */
export const PartnerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerDestroy: async (partner: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partner' is not null or undefined
            assertParamExists('partnerDestroy', 'partner', partner)
            const localVarPath = `/partner/{partner}`
                .replace(`{${"partner"}}`, encodeURIComponent(String(partner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/partner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partner The partner ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerShow: async (partner: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partner' is not null or undefined
            assertParamExists('partnerShow', 'partner', partner)
            const localVarPath = `/partner/{partner}`
                .replace(`{${"partner"}}`, encodeURIComponent(String(partner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StorePartnerRequest} storePartnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerStore: async (storePartnerRequest: StorePartnerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storePartnerRequest' is not null or undefined
            assertParamExists('partnerStore', 'storePartnerRequest', storePartnerRequest)
            const localVarPath = `/partner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storePartnerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partner The partner ID
         * @param {UpdatePartnerRequest} updatePartnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerUpdate: async (partner: string, updatePartnerRequest: UpdatePartnerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partner' is not null or undefined
            assertParamExists('partnerUpdate', 'partner', partner)
            // verify required parameter 'updatePartnerRequest' is not null or undefined
            assertParamExists('partnerUpdate', 'updatePartnerRequest', updatePartnerRequest)
            const localVarPath = `/partner/{partner}`
                .replace(`{${"partner"}}`, encodeURIComponent(String(partner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePartnerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partner The partner ID
         * @param {UpdatePartnerRequest} updatePartnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerUpdate2: async (partner: string, updatePartnerRequest: UpdatePartnerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partner' is not null or undefined
            assertParamExists('partnerUpdate2', 'partner', partner)
            // verify required parameter 'updatePartnerRequest' is not null or undefined
            assertParamExists('partnerUpdate2', 'updatePartnerRequest', updatePartnerRequest)
            const localVarPath = `/partner/{partner}`
                .replace(`{${"partner"}}`, encodeURIComponent(String(partner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePartnerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnerApi - functional programming interface
 */
export const PartnerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartnerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerDestroy(partner: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerDestroy(partner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partner The partner ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerShow(partner: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerShow(partner, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StorePartnerRequest} storePartnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerStore(storePartnerRequest: StorePartnerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerStore(storePartnerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partner The partner ID
         * @param {UpdatePartnerRequest} updatePartnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerUpdate(partner: string, updatePartnerRequest: UpdatePartnerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerUpdate(partner, updatePartnerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partner The partner ID
         * @param {UpdatePartnerRequest} updatePartnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerUpdate2(partner: string, updatePartnerRequest: UpdatePartnerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerUpdate2(partner, updatePartnerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PartnerApi - factory interface
 */
export const PartnerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartnerApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerDestroy(partner: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.partnerDestroy(partner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<PartnerIndex200Response> {
            return localVarFp.partnerIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partner The partner ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerShow(partner: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<PartnerShow200Response> {
            return localVarFp.partnerShow(partner, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StorePartnerRequest} storePartnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerStore(storePartnerRequest: StorePartnerRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerShow200Response> {
            return localVarFp.partnerStore(storePartnerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partner The partner ID
         * @param {UpdatePartnerRequest} updatePartnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerUpdate(partner: string, updatePartnerRequest: UpdatePartnerRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerShow200Response> {
            return localVarFp.partnerUpdate(partner, updatePartnerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partner The partner ID
         * @param {UpdatePartnerRequest} updatePartnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerUpdate2(partner: string, updatePartnerRequest: UpdatePartnerRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerShow200Response> {
            return localVarFp.partnerUpdate2(partner, updatePartnerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartnerApi - object-oriented interface
 */
export class PartnerApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} partner The partner ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerDestroy(partner: string, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerDestroy(partner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} partner The partner ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerShow(partner: string, include?: string, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerShow(partner, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StorePartnerRequest} storePartnerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerStore(storePartnerRequest: StorePartnerRequest, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerStore(storePartnerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} partner The partner ID
     * @param {UpdatePartnerRequest} updatePartnerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerUpdate(partner: string, updatePartnerRequest: UpdatePartnerRequest, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerUpdate(partner, updatePartnerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} partner The partner ID
     * @param {UpdatePartnerRequest} updatePartnerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerUpdate2(partner: string, updatePartnerRequest: UpdatePartnerRequest, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerUpdate2(partner, updatePartnerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PartnerImageApi - axios parameter creator
 */
export const PartnerImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Attach an available image to a partner
         * @param {string} partner The partner ID
         * @param {AttachFromAvailablePartnerImageRequest} attachFromAvailablePartnerImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerAttachImage: async (partner: string, attachFromAvailablePartnerImageRequest: AttachFromAvailablePartnerImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partner' is not null or undefined
            assertParamExists('partnerAttachImage', 'partner', partner)
            // verify required parameter 'attachFromAvailablePartnerImageRequest' is not null or undefined
            assertParamExists('partnerAttachImage', 'attachFromAvailablePartnerImageRequest', attachFromAvailablePartnerImageRequest)
            const localVarPath = `/partner/{partner}/attach-image`
                .replace(`{${"partner"}}`, encodeURIComponent(String(partner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachFromAvailablePartnerImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partnerImage The partner image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageDestroy: async (partnerImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerImage' is not null or undefined
            assertParamExists('partnerImageDestroy', 'partnerImage', partnerImage)
            const localVarPath = `/partner-image/{partnerImage}`
                .replace(`{${"partnerImage"}}`, encodeURIComponent(String(partnerImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach a partner image and convert it back to available image
         * @param {string} partnerImage The partner image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageDetach: async (partnerImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerImage' is not null or undefined
            assertParamExists('partnerImageDetach', 'partnerImage', partnerImage)
            const localVarPath = `/partner-image/{partnerImage}/detach`
                .replace(`{${"partnerImage"}}`, encodeURIComponent(String(partnerImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} partnerImage The partner image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageDownload: async (partnerImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerImage' is not null or undefined
            assertParamExists('partnerImageDownload', 'partnerImage', partnerImage)
            const localVarPath = `/partner-image/{partnerImage}/download`
                .replace(`{${"partnerImage"}}`, encodeURIComponent(String(partnerImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/partner-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move partner image down in display order
         * @param {string} partnerImage The partner image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageMoveDown: async (partnerImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerImage' is not null or undefined
            assertParamExists('partnerImageMoveDown', 'partnerImage', partnerImage)
            const localVarPath = `/partner-image/{partnerImage}/move-down`
                .replace(`{${"partnerImage"}}`, encodeURIComponent(String(partnerImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move partner image up in display order
         * @param {string} partnerImage The partner image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageMoveUp: async (partnerImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerImage' is not null or undefined
            assertParamExists('partnerImageMoveUp', 'partnerImage', partnerImage)
            const localVarPath = `/partner-image/{partnerImage}/move-up`
                .replace(`{${"partnerImage"}}`, encodeURIComponent(String(partnerImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partnerImage The partner image ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageShow: async (partnerImage: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerImage' is not null or undefined
            assertParamExists('partnerImageShow', 'partnerImage', partnerImage)
            const localVarPath = `/partner-image/{partnerImage}`
                .replace(`{${"partnerImage"}}`, encodeURIComponent(String(partnerImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StorePartnerImageRequest} storePartnerImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageStore: async (storePartnerImageRequest: StorePartnerImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storePartnerImageRequest' is not null or undefined
            assertParamExists('partnerImageStore', 'storePartnerImageRequest', storePartnerImageRequest)
            const localVarPath = `/partner-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storePartnerImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tighten ordering for all images of the partner
         * @param {string} partnerImage The partner image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageTightenOrdering: async (partnerImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerImage' is not null or undefined
            assertParamExists('partnerImageTightenOrdering', 'partnerImage', partnerImage)
            const localVarPath = `/partner-image/{partnerImage}/tighten-ordering`
                .replace(`{${"partnerImage"}}`, encodeURIComponent(String(partnerImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partnerImage The partner image ID
         * @param {UpdatePartnerImageRequest} updatePartnerImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageUpdate: async (partnerImage: string, updatePartnerImageRequest: UpdatePartnerImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerImage' is not null or undefined
            assertParamExists('partnerImageUpdate', 'partnerImage', partnerImage)
            // verify required parameter 'updatePartnerImageRequest' is not null or undefined
            assertParamExists('partnerImageUpdate', 'updatePartnerImageRequest', updatePartnerImageRequest)
            const localVarPath = `/partner-image/{partnerImage}`
                .replace(`{${"partnerImage"}}`, encodeURIComponent(String(partnerImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePartnerImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partnerImage The partner image ID
         * @param {UpdatePartnerImageRequest} updatePartnerImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageUpdate2: async (partnerImage: string, updatePartnerImageRequest: UpdatePartnerImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerImage' is not null or undefined
            assertParamExists('partnerImageUpdate2', 'partnerImage', partnerImage)
            // verify required parameter 'updatePartnerImageRequest' is not null or undefined
            assertParamExists('partnerImageUpdate2', 'updatePartnerImageRequest', updatePartnerImageRequest)
            const localVarPath = `/partner-image/{partnerImage}`
                .replace(`{${"partnerImage"}}`, encodeURIComponent(String(partnerImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePartnerImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} partnerImage The partner image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageView: async (partnerImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerImage' is not null or undefined
            assertParamExists('partnerImageView', 'partnerImage', partnerImage)
            const localVarPath = `/partner-image/{partnerImage}/view`
                .replace(`{${"partnerImage"}}`, encodeURIComponent(String(partnerImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnerImageApi - functional programming interface
 */
export const PartnerImageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartnerImageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Attach an available image to a partner
         * @param {string} partner The partner ID
         * @param {AttachFromAvailablePartnerImageRequest} attachFromAvailablePartnerImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerAttachImage(partner: string, attachFromAvailablePartnerImageRequest: AttachFromAvailablePartnerImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerAttachImage(partner, attachFromAvailablePartnerImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerImageApi.partnerAttachImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partnerImage The partner image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerImageDestroy(partnerImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerImageDestroy(partnerImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerImageApi.partnerImageDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Detach a partner image and convert it back to available image
         * @param {string} partnerImage The partner image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerImageDetach(partnerImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionImageTightenOrdering200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerImageDetach(partnerImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerImageApi.partnerImageDetach']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} partnerImage The partner image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerImageDownload(partnerImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerImageDownload(partnerImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerImageApi.partnerImageDownload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerImageIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerImageIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerImageIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerImageApi.partnerImageIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move partner image down in display order
         * @param {string} partnerImage The partner image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerImageMoveDown(partnerImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerImageMoveDown(partnerImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerImageApi.partnerImageMoveDown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move partner image up in display order
         * @param {string} partnerImage The partner image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerImageMoveUp(partnerImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerImageMoveUp(partnerImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerImageApi.partnerImageMoveUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partnerImage The partner image ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerImageShow(partnerImage: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerImageShow(partnerImage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerImageApi.partnerImageShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StorePartnerImageRequest} storePartnerImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerImageStore(storePartnerImageRequest: StorePartnerImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerImageStore(storePartnerImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerImageApi.partnerImageStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tighten ordering for all images of the partner
         * @param {string} partnerImage The partner image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerImageTightenOrdering(partnerImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionImageTightenOrdering200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerImageTightenOrdering(partnerImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerImageApi.partnerImageTightenOrdering']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partnerImage The partner image ID
         * @param {UpdatePartnerImageRequest} updatePartnerImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerImageUpdate(partnerImage: string, updatePartnerImageRequest: UpdatePartnerImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerImageUpdate(partnerImage, updatePartnerImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerImageApi.partnerImageUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partnerImage The partner image ID
         * @param {UpdatePartnerImageRequest} updatePartnerImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerImageUpdate2(partnerImage: string, updatePartnerImageRequest: UpdatePartnerImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerImageUpdate2(partnerImage, updatePartnerImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerImageApi.partnerImageUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} partnerImage The partner image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerImageView(partnerImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerImageView(partnerImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerImageApi.partnerImageView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PartnerImageApi - factory interface
 */
export const PartnerImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartnerImageApiFp(configuration)
    return {
        /**
         * 
         * @summary Attach an available image to a partner
         * @param {string} partner The partner ID
         * @param {AttachFromAvailablePartnerImageRequest} attachFromAvailablePartnerImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerAttachImage(partner: string, attachFromAvailablePartnerImageRequest: AttachFromAvailablePartnerImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerImageShow200Response> {
            return localVarFp.partnerAttachImage(partner, attachFromAvailablePartnerImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partnerImage The partner image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageDestroy(partnerImage: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.partnerImageDestroy(partnerImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detach a partner image and convert it back to available image
         * @param {string} partnerImage The partner image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageDetach(partnerImage: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionImageTightenOrdering200Response> {
            return localVarFp.partnerImageDetach(partnerImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} partnerImage The partner image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageDownload(partnerImage: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.partnerImageDownload(partnerImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<PartnerImageIndex200Response> {
            return localVarFp.partnerImageIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move partner image down in display order
         * @param {string} partnerImage The partner image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageMoveDown(partnerImage: string, options?: RawAxiosRequestConfig): AxiosPromise<PartnerImageShow200Response> {
            return localVarFp.partnerImageMoveDown(partnerImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move partner image up in display order
         * @param {string} partnerImage The partner image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageMoveUp(partnerImage: string, options?: RawAxiosRequestConfig): AxiosPromise<PartnerImageShow200Response> {
            return localVarFp.partnerImageMoveUp(partnerImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partnerImage The partner image ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageShow(partnerImage: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<PartnerImageShow200Response> {
            return localVarFp.partnerImageShow(partnerImage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StorePartnerImageRequest} storePartnerImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageStore(storePartnerImageRequest: StorePartnerImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerImageShow200Response> {
            return localVarFp.partnerImageStore(storePartnerImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Tighten ordering for all images of the partner
         * @param {string} partnerImage The partner image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageTightenOrdering(partnerImage: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionImageTightenOrdering200Response> {
            return localVarFp.partnerImageTightenOrdering(partnerImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partnerImage The partner image ID
         * @param {UpdatePartnerImageRequest} updatePartnerImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageUpdate(partnerImage: string, updatePartnerImageRequest: UpdatePartnerImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerImageShow200Response> {
            return localVarFp.partnerImageUpdate(partnerImage, updatePartnerImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partnerImage The partner image ID
         * @param {UpdatePartnerImageRequest} updatePartnerImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageUpdate2(partnerImage: string, updatePartnerImageRequest: UpdatePartnerImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerImageShow200Response> {
            return localVarFp.partnerImageUpdate2(partnerImage, updatePartnerImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} partnerImage The partner image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerImageView(partnerImage: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.partnerImageView(partnerImage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartnerImageApi - object-oriented interface
 */
export class PartnerImageApi extends BaseAPI {
    /**
     * 
     * @summary Attach an available image to a partner
     * @param {string} partner The partner ID
     * @param {AttachFromAvailablePartnerImageRequest} attachFromAvailablePartnerImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerAttachImage(partner: string, attachFromAvailablePartnerImageRequest: AttachFromAvailablePartnerImageRequest, options?: RawAxiosRequestConfig) {
        return PartnerImageApiFp(this.configuration).partnerAttachImage(partner, attachFromAvailablePartnerImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} partnerImage The partner image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerImageDestroy(partnerImage: string, options?: RawAxiosRequestConfig) {
        return PartnerImageApiFp(this.configuration).partnerImageDestroy(partnerImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detach a partner image and convert it back to available image
     * @param {string} partnerImage The partner image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerImageDetach(partnerImage: string, options?: RawAxiosRequestConfig) {
        return PartnerImageApiFp(this.configuration).partnerImageDetach(partnerImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the file to the caller
     * @param {string} partnerImage The partner image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerImageDownload(partnerImage: string, options?: RawAxiosRequestConfig) {
        return PartnerImageApiFp(this.configuration).partnerImageDownload(partnerImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerImageIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return PartnerImageApiFp(this.configuration).partnerImageIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move partner image down in display order
     * @param {string} partnerImage The partner image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerImageMoveDown(partnerImage: string, options?: RawAxiosRequestConfig) {
        return PartnerImageApiFp(this.configuration).partnerImageMoveDown(partnerImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move partner image up in display order
     * @param {string} partnerImage The partner image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerImageMoveUp(partnerImage: string, options?: RawAxiosRequestConfig) {
        return PartnerImageApiFp(this.configuration).partnerImageMoveUp(partnerImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} partnerImage The partner image ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerImageShow(partnerImage: string, include?: string, options?: RawAxiosRequestConfig) {
        return PartnerImageApiFp(this.configuration).partnerImageShow(partnerImage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StorePartnerImageRequest} storePartnerImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerImageStore(storePartnerImageRequest: StorePartnerImageRequest, options?: RawAxiosRequestConfig) {
        return PartnerImageApiFp(this.configuration).partnerImageStore(storePartnerImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Tighten ordering for all images of the partner
     * @param {string} partnerImage The partner image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerImageTightenOrdering(partnerImage: string, options?: RawAxiosRequestConfig) {
        return PartnerImageApiFp(this.configuration).partnerImageTightenOrdering(partnerImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} partnerImage The partner image ID
     * @param {UpdatePartnerImageRequest} updatePartnerImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerImageUpdate(partnerImage: string, updatePartnerImageRequest: UpdatePartnerImageRequest, options?: RawAxiosRequestConfig) {
        return PartnerImageApiFp(this.configuration).partnerImageUpdate(partnerImage, updatePartnerImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} partnerImage The partner image ID
     * @param {UpdatePartnerImageRequest} updatePartnerImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerImageUpdate2(partnerImage: string, updatePartnerImageRequest: UpdatePartnerImageRequest, options?: RawAxiosRequestConfig) {
        return PartnerImageApiFp(this.configuration).partnerImageUpdate2(partnerImage, updatePartnerImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
     * @param {string} partnerImage The partner image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerImageView(partnerImage: string, options?: RawAxiosRequestConfig) {
        return PartnerImageApiFp(this.configuration).partnerImageView(partnerImage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PartnerTranslationApi - axios parameter creator
 */
export const PartnerTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partnerTranslation The partner translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationDestroy: async (partnerTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerTranslation' is not null or undefined
            assertParamExists('partnerTranslationDestroy', 'partnerTranslation', partnerTranslation)
            const localVarPath = `/partner-translation/{partnerTranslation}`
                .replace(`{${"partnerTranslation"}}`, encodeURIComponent(String(partnerTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/partner-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partnerTranslation The partner translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationShow: async (partnerTranslation: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerTranslation' is not null or undefined
            assertParamExists('partnerTranslationShow', 'partnerTranslation', partnerTranslation)
            const localVarPath = `/partner-translation/{partnerTranslation}`
                .replace(`{${"partnerTranslation"}}`, encodeURIComponent(String(partnerTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StorePartnerTranslationRequest} storePartnerTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationStore: async (storePartnerTranslationRequest: StorePartnerTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storePartnerTranslationRequest' is not null or undefined
            assertParamExists('partnerTranslationStore', 'storePartnerTranslationRequest', storePartnerTranslationRequest)
            const localVarPath = `/partner-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storePartnerTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partnerTranslation The partner translation ID
         * @param {UpdatePartnerTranslationRequest} updatePartnerTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationUpdate: async (partnerTranslation: string, updatePartnerTranslationRequest: UpdatePartnerTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerTranslation' is not null or undefined
            assertParamExists('partnerTranslationUpdate', 'partnerTranslation', partnerTranslation)
            // verify required parameter 'updatePartnerTranslationRequest' is not null or undefined
            assertParamExists('partnerTranslationUpdate', 'updatePartnerTranslationRequest', updatePartnerTranslationRequest)
            const localVarPath = `/partner-translation/{partnerTranslation}`
                .replace(`{${"partnerTranslation"}}`, encodeURIComponent(String(partnerTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePartnerTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partnerTranslation The partner translation ID
         * @param {UpdatePartnerTranslationRequest} updatePartnerTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationUpdate2: async (partnerTranslation: string, updatePartnerTranslationRequest: UpdatePartnerTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerTranslation' is not null or undefined
            assertParamExists('partnerTranslationUpdate2', 'partnerTranslation', partnerTranslation)
            // verify required parameter 'updatePartnerTranslationRequest' is not null or undefined
            assertParamExists('partnerTranslationUpdate2', 'updatePartnerTranslationRequest', updatePartnerTranslationRequest)
            const localVarPath = `/partner-translation/{partnerTranslation}`
                .replace(`{${"partnerTranslation"}}`, encodeURIComponent(String(partnerTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePartnerTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnerTranslationApi - functional programming interface
 */
export const PartnerTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartnerTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partnerTranslation The partner translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerTranslationDestroy(partnerTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerTranslationDestroy(partnerTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerTranslationApi.partnerTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerTranslationIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerTranslationIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerTranslationApi.partnerTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partnerTranslation The partner translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerTranslationShow(partnerTranslation: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerTranslationShow(partnerTranslation, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerTranslationApi.partnerTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StorePartnerTranslationRequest} storePartnerTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerTranslationStore(storePartnerTranslationRequest: StorePartnerTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerTranslationStore(storePartnerTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerTranslationApi.partnerTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partnerTranslation The partner translation ID
         * @param {UpdatePartnerTranslationRequest} updatePartnerTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerTranslationUpdate(partnerTranslation: string, updatePartnerTranslationRequest: UpdatePartnerTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerTranslationUpdate(partnerTranslation, updatePartnerTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerTranslationApi.partnerTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partnerTranslation The partner translation ID
         * @param {UpdatePartnerTranslationRequest} updatePartnerTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerTranslationUpdate2(partnerTranslation: string, updatePartnerTranslationRequest: UpdatePartnerTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerTranslationUpdate2(partnerTranslation, updatePartnerTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerTranslationApi.partnerTranslationUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PartnerTranslationApi - factory interface
 */
export const PartnerTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartnerTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partnerTranslation The partner translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationDestroy(partnerTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.partnerTranslationDestroy(partnerTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<PartnerTranslationIndex200Response> {
            return localVarFp.partnerTranslationIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partnerTranslation The partner translation ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationShow(partnerTranslation: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<PartnerTranslationShow200Response> {
            return localVarFp.partnerTranslationShow(partnerTranslation, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StorePartnerTranslationRequest} storePartnerTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationStore(storePartnerTranslationRequest: StorePartnerTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerTranslationShow200Response> {
            return localVarFp.partnerTranslationStore(storePartnerTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partnerTranslation The partner translation ID
         * @param {UpdatePartnerTranslationRequest} updatePartnerTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationUpdate(partnerTranslation: string, updatePartnerTranslationRequest: UpdatePartnerTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerTranslationShow200Response> {
            return localVarFp.partnerTranslationUpdate(partnerTranslation, updatePartnerTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partnerTranslation The partner translation ID
         * @param {UpdatePartnerTranslationRequest} updatePartnerTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationUpdate2(partnerTranslation: string, updatePartnerTranslationRequest: UpdatePartnerTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerTranslationShow200Response> {
            return localVarFp.partnerTranslationUpdate2(partnerTranslation, updatePartnerTranslationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartnerTranslationApi - object-oriented interface
 */
export class PartnerTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} partnerTranslation The partner translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerTranslationDestroy(partnerTranslation: string, options?: RawAxiosRequestConfig) {
        return PartnerTranslationApiFp(this.configuration).partnerTranslationDestroy(partnerTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerTranslationIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return PartnerTranslationApiFp(this.configuration).partnerTranslationIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} partnerTranslation The partner translation ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerTranslationShow(partnerTranslation: string, include?: string, options?: RawAxiosRequestConfig) {
        return PartnerTranslationApiFp(this.configuration).partnerTranslationShow(partnerTranslation, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StorePartnerTranslationRequest} storePartnerTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerTranslationStore(storePartnerTranslationRequest: StorePartnerTranslationRequest, options?: RawAxiosRequestConfig) {
        return PartnerTranslationApiFp(this.configuration).partnerTranslationStore(storePartnerTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} partnerTranslation The partner translation ID
     * @param {UpdatePartnerTranslationRequest} updatePartnerTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerTranslationUpdate(partnerTranslation: string, updatePartnerTranslationRequest: UpdatePartnerTranslationRequest, options?: RawAxiosRequestConfig) {
        return PartnerTranslationApiFp(this.configuration).partnerTranslationUpdate(partnerTranslation, updatePartnerTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} partnerTranslation The partner translation ID
     * @param {UpdatePartnerTranslationRequest} updatePartnerTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerTranslationUpdate2(partnerTranslation: string, updatePartnerTranslationRequest: UpdatePartnerTranslationRequest, options?: RawAxiosRequestConfig) {
        return PartnerTranslationApiFp(this.configuration).partnerTranslationUpdate2(partnerTranslation, updatePartnerTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PartnerTranslationImageApi - axios parameter creator
 */
export const PartnerTranslationImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Attach an available image to a partner translation
         * @param {string} partnerTranslation The partner translation ID
         * @param {AttachFromAvailablePartnerTranslationImageRequest} attachFromAvailablePartnerTranslationImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationAttachImage: async (partnerTranslation: string, attachFromAvailablePartnerTranslationImageRequest: AttachFromAvailablePartnerTranslationImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerTranslation' is not null or undefined
            assertParamExists('partnerTranslationAttachImage', 'partnerTranslation', partnerTranslation)
            // verify required parameter 'attachFromAvailablePartnerTranslationImageRequest' is not null or undefined
            assertParamExists('partnerTranslationAttachImage', 'attachFromAvailablePartnerTranslationImageRequest', attachFromAvailablePartnerTranslationImageRequest)
            const localVarPath = `/partner-translation/{partnerTranslation}/attach-image`
                .replace(`{${"partnerTranslation"}}`, encodeURIComponent(String(partnerTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachFromAvailablePartnerTranslationImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageDestroy: async (partnerTranslationImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerTranslationImage' is not null or undefined
            assertParamExists('partnerTranslationImageDestroy', 'partnerTranslationImage', partnerTranslationImage)
            const localVarPath = `/partner-translation-image/{partnerTranslationImage}`
                .replace(`{${"partnerTranslationImage"}}`, encodeURIComponent(String(partnerTranslationImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach a partner translation image and convert it back to available image
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageDetach: async (partnerTranslationImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerTranslationImage' is not null or undefined
            assertParamExists('partnerTranslationImageDetach', 'partnerTranslationImage', partnerTranslationImage)
            const localVarPath = `/partner-translation-image/{partnerTranslationImage}/detach`
                .replace(`{${"partnerTranslationImage"}}`, encodeURIComponent(String(partnerTranslationImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageDownload: async (partnerTranslationImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerTranslationImage' is not null or undefined
            assertParamExists('partnerTranslationImageDownload', 'partnerTranslationImage', partnerTranslationImage)
            const localVarPath = `/partner-translation-image/{partnerTranslationImage}/download`
                .replace(`{${"partnerTranslationImage"}}`, encodeURIComponent(String(partnerTranslationImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/partner-translation-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move partner translation image down in display order
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageMoveDown: async (partnerTranslationImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerTranslationImage' is not null or undefined
            assertParamExists('partnerTranslationImageMoveDown', 'partnerTranslationImage', partnerTranslationImage)
            const localVarPath = `/partner-translation-image/{partnerTranslationImage}/move-down`
                .replace(`{${"partnerTranslationImage"}}`, encodeURIComponent(String(partnerTranslationImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move partner translation image up in display order
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageMoveUp: async (partnerTranslationImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerTranslationImage' is not null or undefined
            assertParamExists('partnerTranslationImageMoveUp', 'partnerTranslationImage', partnerTranslationImage)
            const localVarPath = `/partner-translation-image/{partnerTranslationImage}/move-up`
                .replace(`{${"partnerTranslationImage"}}`, encodeURIComponent(String(partnerTranslationImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageShow: async (partnerTranslationImage: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerTranslationImage' is not null or undefined
            assertParamExists('partnerTranslationImageShow', 'partnerTranslationImage', partnerTranslationImage)
            const localVarPath = `/partner-translation-image/{partnerTranslationImage}`
                .replace(`{${"partnerTranslationImage"}}`, encodeURIComponent(String(partnerTranslationImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StorePartnerTranslationImageRequest} storePartnerTranslationImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageStore: async (storePartnerTranslationImageRequest: StorePartnerTranslationImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storePartnerTranslationImageRequest' is not null or undefined
            assertParamExists('partnerTranslationImageStore', 'storePartnerTranslationImageRequest', storePartnerTranslationImageRequest)
            const localVarPath = `/partner-translation-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storePartnerTranslationImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tighten ordering for all images of the partner translation
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageTightenOrdering: async (partnerTranslationImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerTranslationImage' is not null or undefined
            assertParamExists('partnerTranslationImageTightenOrdering', 'partnerTranslationImage', partnerTranslationImage)
            const localVarPath = `/partner-translation-image/{partnerTranslationImage}/tighten-ordering`
                .replace(`{${"partnerTranslationImage"}}`, encodeURIComponent(String(partnerTranslationImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {UpdatePartnerTranslationImageRequest} updatePartnerTranslationImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageUpdate: async (partnerTranslationImage: string, updatePartnerTranslationImageRequest: UpdatePartnerTranslationImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerTranslationImage' is not null or undefined
            assertParamExists('partnerTranslationImageUpdate', 'partnerTranslationImage', partnerTranslationImage)
            // verify required parameter 'updatePartnerTranslationImageRequest' is not null or undefined
            assertParamExists('partnerTranslationImageUpdate', 'updatePartnerTranslationImageRequest', updatePartnerTranslationImageRequest)
            const localVarPath = `/partner-translation-image/{partnerTranslationImage}`
                .replace(`{${"partnerTranslationImage"}}`, encodeURIComponent(String(partnerTranslationImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePartnerTranslationImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {UpdatePartnerTranslationImageRequest} updatePartnerTranslationImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageUpdate2: async (partnerTranslationImage: string, updatePartnerTranslationImageRequest: UpdatePartnerTranslationImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerTranslationImage' is not null or undefined
            assertParamExists('partnerTranslationImageUpdate2', 'partnerTranslationImage', partnerTranslationImage)
            // verify required parameter 'updatePartnerTranslationImageRequest' is not null or undefined
            assertParamExists('partnerTranslationImageUpdate2', 'updatePartnerTranslationImageRequest', updatePartnerTranslationImageRequest)
            const localVarPath = `/partner-translation-image/{partnerTranslationImage}`
                .replace(`{${"partnerTranslationImage"}}`, encodeURIComponent(String(partnerTranslationImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePartnerTranslationImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageView: async (partnerTranslationImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerTranslationImage' is not null or undefined
            assertParamExists('partnerTranslationImageView', 'partnerTranslationImage', partnerTranslationImage)
            const localVarPath = `/partner-translation-image/{partnerTranslationImage}/view`
                .replace(`{${"partnerTranslationImage"}}`, encodeURIComponent(String(partnerTranslationImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnerTranslationImageApi - functional programming interface
 */
export const PartnerTranslationImageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartnerTranslationImageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Attach an available image to a partner translation
         * @param {string} partnerTranslation The partner translation ID
         * @param {AttachFromAvailablePartnerTranslationImageRequest} attachFromAvailablePartnerTranslationImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerTranslationAttachImage(partnerTranslation: string, attachFromAvailablePartnerTranslationImageRequest: AttachFromAvailablePartnerTranslationImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerTranslationImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerTranslationAttachImage(partnerTranslation, attachFromAvailablePartnerTranslationImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerTranslationImageApi.partnerTranslationAttachImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerTranslationImageDestroy(partnerTranslationImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerTranslationImageDestroy(partnerTranslationImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerTranslationImageApi.partnerTranslationImageDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Detach a partner translation image and convert it back to available image
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerTranslationImageDetach(partnerTranslationImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionImageTightenOrdering200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerTranslationImageDetach(partnerTranslationImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerTranslationImageApi.partnerTranslationImageDetach']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerTranslationImageDownload(partnerTranslationImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerTranslationImageDownload(partnerTranslationImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerTranslationImageApi.partnerTranslationImageDownload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerTranslationImageIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerTranslationImageIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerTranslationImageIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerTranslationImageApi.partnerTranslationImageIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move partner translation image down in display order
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerTranslationImageMoveDown(partnerTranslationImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerTranslationImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerTranslationImageMoveDown(partnerTranslationImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerTranslationImageApi.partnerTranslationImageMoveDown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move partner translation image up in display order
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerTranslationImageMoveUp(partnerTranslationImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerTranslationImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerTranslationImageMoveUp(partnerTranslationImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerTranslationImageApi.partnerTranslationImageMoveUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerTranslationImageShow(partnerTranslationImage: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerTranslationImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerTranslationImageShow(partnerTranslationImage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerTranslationImageApi.partnerTranslationImageShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StorePartnerTranslationImageRequest} storePartnerTranslationImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerTranslationImageStore(storePartnerTranslationImageRequest: StorePartnerTranslationImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerTranslationImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerTranslationImageStore(storePartnerTranslationImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerTranslationImageApi.partnerTranslationImageStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tighten ordering for all images of the partner translation
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerTranslationImageTightenOrdering(partnerTranslationImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionImageTightenOrdering200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerTranslationImageTightenOrdering(partnerTranslationImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerTranslationImageApi.partnerTranslationImageTightenOrdering']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {UpdatePartnerTranslationImageRequest} updatePartnerTranslationImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerTranslationImageUpdate(partnerTranslationImage: string, updatePartnerTranslationImageRequest: UpdatePartnerTranslationImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerTranslationImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerTranslationImageUpdate(partnerTranslationImage, updatePartnerTranslationImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerTranslationImageApi.partnerTranslationImageUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {UpdatePartnerTranslationImageRequest} updatePartnerTranslationImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerTranslationImageUpdate2(partnerTranslationImage: string, updatePartnerTranslationImageRequest: UpdatePartnerTranslationImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerTranslationImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerTranslationImageUpdate2(partnerTranslationImage, updatePartnerTranslationImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerTranslationImageApi.partnerTranslationImageUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerTranslationImageView(partnerTranslationImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerTranslationImageView(partnerTranslationImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerTranslationImageApi.partnerTranslationImageView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PartnerTranslationImageApi - factory interface
 */
export const PartnerTranslationImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartnerTranslationImageApiFp(configuration)
    return {
        /**
         * 
         * @summary Attach an available image to a partner translation
         * @param {string} partnerTranslation The partner translation ID
         * @param {AttachFromAvailablePartnerTranslationImageRequest} attachFromAvailablePartnerTranslationImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationAttachImage(partnerTranslation: string, attachFromAvailablePartnerTranslationImageRequest: AttachFromAvailablePartnerTranslationImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerTranslationImageShow200Response> {
            return localVarFp.partnerTranslationAttachImage(partnerTranslation, attachFromAvailablePartnerTranslationImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageDestroy(partnerTranslationImage: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.partnerTranslationImageDestroy(partnerTranslationImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detach a partner translation image and convert it back to available image
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageDetach(partnerTranslationImage: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionImageTightenOrdering200Response> {
            return localVarFp.partnerTranslationImageDetach(partnerTranslationImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageDownload(partnerTranslationImage: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.partnerTranslationImageDownload(partnerTranslationImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<PartnerTranslationImageIndex200Response> {
            return localVarFp.partnerTranslationImageIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move partner translation image down in display order
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageMoveDown(partnerTranslationImage: string, options?: RawAxiosRequestConfig): AxiosPromise<PartnerTranslationImageShow200Response> {
            return localVarFp.partnerTranslationImageMoveDown(partnerTranslationImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move partner translation image up in display order
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageMoveUp(partnerTranslationImage: string, options?: RawAxiosRequestConfig): AxiosPromise<PartnerTranslationImageShow200Response> {
            return localVarFp.partnerTranslationImageMoveUp(partnerTranslationImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageShow(partnerTranslationImage: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<PartnerTranslationImageShow200Response> {
            return localVarFp.partnerTranslationImageShow(partnerTranslationImage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StorePartnerTranslationImageRequest} storePartnerTranslationImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageStore(storePartnerTranslationImageRequest: StorePartnerTranslationImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerTranslationImageShow200Response> {
            return localVarFp.partnerTranslationImageStore(storePartnerTranslationImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Tighten ordering for all images of the partner translation
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageTightenOrdering(partnerTranslationImage: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionImageTightenOrdering200Response> {
            return localVarFp.partnerTranslationImageTightenOrdering(partnerTranslationImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {UpdatePartnerTranslationImageRequest} updatePartnerTranslationImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageUpdate(partnerTranslationImage: string, updatePartnerTranslationImageRequest: UpdatePartnerTranslationImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerTranslationImageShow200Response> {
            return localVarFp.partnerTranslationImageUpdate(partnerTranslationImage, updatePartnerTranslationImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {UpdatePartnerTranslationImageRequest} updatePartnerTranslationImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageUpdate2(partnerTranslationImage: string, updatePartnerTranslationImageRequest: UpdatePartnerTranslationImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerTranslationImageShow200Response> {
            return localVarFp.partnerTranslationImageUpdate2(partnerTranslationImage, updatePartnerTranslationImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} partnerTranslationImage The partner translation image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTranslationImageView(partnerTranslationImage: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.partnerTranslationImageView(partnerTranslationImage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartnerTranslationImageApi - object-oriented interface
 */
export class PartnerTranslationImageApi extends BaseAPI {
    /**
     * 
     * @summary Attach an available image to a partner translation
     * @param {string} partnerTranslation The partner translation ID
     * @param {AttachFromAvailablePartnerTranslationImageRequest} attachFromAvailablePartnerTranslationImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerTranslationAttachImage(partnerTranslation: string, attachFromAvailablePartnerTranslationImageRequest: AttachFromAvailablePartnerTranslationImageRequest, options?: RawAxiosRequestConfig) {
        return PartnerTranslationImageApiFp(this.configuration).partnerTranslationAttachImage(partnerTranslation, attachFromAvailablePartnerTranslationImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} partnerTranslationImage The partner translation image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerTranslationImageDestroy(partnerTranslationImage: string, options?: RawAxiosRequestConfig) {
        return PartnerTranslationImageApiFp(this.configuration).partnerTranslationImageDestroy(partnerTranslationImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detach a partner translation image and convert it back to available image
     * @param {string} partnerTranslationImage The partner translation image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerTranslationImageDetach(partnerTranslationImage: string, options?: RawAxiosRequestConfig) {
        return PartnerTranslationImageApiFp(this.configuration).partnerTranslationImageDetach(partnerTranslationImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the file to the caller
     * @param {string} partnerTranslationImage The partner translation image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerTranslationImageDownload(partnerTranslationImage: string, options?: RawAxiosRequestConfig) {
        return PartnerTranslationImageApiFp(this.configuration).partnerTranslationImageDownload(partnerTranslationImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerTranslationImageIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return PartnerTranslationImageApiFp(this.configuration).partnerTranslationImageIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move partner translation image down in display order
     * @param {string} partnerTranslationImage The partner translation image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerTranslationImageMoveDown(partnerTranslationImage: string, options?: RawAxiosRequestConfig) {
        return PartnerTranslationImageApiFp(this.configuration).partnerTranslationImageMoveDown(partnerTranslationImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move partner translation image up in display order
     * @param {string} partnerTranslationImage The partner translation image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerTranslationImageMoveUp(partnerTranslationImage: string, options?: RawAxiosRequestConfig) {
        return PartnerTranslationImageApiFp(this.configuration).partnerTranslationImageMoveUp(partnerTranslationImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} partnerTranslationImage The partner translation image ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerTranslationImageShow(partnerTranslationImage: string, include?: string, options?: RawAxiosRequestConfig) {
        return PartnerTranslationImageApiFp(this.configuration).partnerTranslationImageShow(partnerTranslationImage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StorePartnerTranslationImageRequest} storePartnerTranslationImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerTranslationImageStore(storePartnerTranslationImageRequest: StorePartnerTranslationImageRequest, options?: RawAxiosRequestConfig) {
        return PartnerTranslationImageApiFp(this.configuration).partnerTranslationImageStore(storePartnerTranslationImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Tighten ordering for all images of the partner translation
     * @param {string} partnerTranslationImage The partner translation image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerTranslationImageTightenOrdering(partnerTranslationImage: string, options?: RawAxiosRequestConfig) {
        return PartnerTranslationImageApiFp(this.configuration).partnerTranslationImageTightenOrdering(partnerTranslationImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} partnerTranslationImage The partner translation image ID
     * @param {UpdatePartnerTranslationImageRequest} updatePartnerTranslationImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerTranslationImageUpdate(partnerTranslationImage: string, updatePartnerTranslationImageRequest: UpdatePartnerTranslationImageRequest, options?: RawAxiosRequestConfig) {
        return PartnerTranslationImageApiFp(this.configuration).partnerTranslationImageUpdate(partnerTranslationImage, updatePartnerTranslationImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} partnerTranslationImage The partner translation image ID
     * @param {UpdatePartnerTranslationImageRequest} updatePartnerTranslationImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerTranslationImageUpdate2(partnerTranslationImage: string, updatePartnerTranslationImageRequest: UpdatePartnerTranslationImageRequest, options?: RawAxiosRequestConfig) {
        return PartnerTranslationImageApiFp(this.configuration).partnerTranslationImageUpdate2(partnerTranslationImage, updatePartnerTranslationImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
     * @param {string} partnerTranslationImage The partner translation image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partnerTranslationImageView(partnerTranslationImage: string, options?: RawAxiosRequestConfig) {
        return PartnerTranslationImageApiFp(this.configuration).partnerTranslationImageView(partnerTranslationImage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectApi - axios parameter creator
 */
export const ProjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} project The project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDestroy: async (project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectDestroy', 'project', project)
            const localVarPath = `/project/{project}`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all visible projects. The project becomes \"visible\" when all conditions are matched: - is_enabled is true - is_launched is true - current date >= launch_date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEnabled: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project/enabled`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggle Enable/disable on a project
         * @param {string} project The project ID
         * @param {SetEnabledProjectRequest} setEnabledProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSetEnabled: async (project: string, setEnabledProjectRequest: SetEnabledProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectSetEnabled', 'project', project)
            // verify required parameter 'setEnabledProjectRequest' is not null or undefined
            assertParamExists('projectSetEnabled', 'setEnabledProjectRequest', setEnabledProjectRequest)
            const localVarPath = `/project/{project}/enabled`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setEnabledProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggle Launched/not-launched on a project. Important: It is independant from the `launch_date` value. It is an idicator showing that the project is to be considered \'laucnhed\' as soon as the launch date it reached
         * @param {string} project The project ID
         * @param {SetLaunchedProjectRequest} setLaunchedProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSetLaunched: async (project: string, setLaunchedProjectRequest: SetLaunchedProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectSetLaunched', 'project', project)
            // verify required parameter 'setLaunchedProjectRequest' is not null or undefined
            assertParamExists('projectSetLaunched', 'setLaunchedProjectRequest', setLaunchedProjectRequest)
            const localVarPath = `/project/{project}/launched`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setLaunchedProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} project The project ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectShow: async (project: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectShow', 'project', project)
            const localVarPath = `/project/{project}`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreProjectRequest} storeProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStore: async (storeProjectRequest: StoreProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeProjectRequest' is not null or undefined
            assertParamExists('projectStore', 'storeProjectRequest', storeProjectRequest)
            const localVarPath = `/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} project The project ID
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectUpdate: async (project: string, updateProjectRequest: UpdateProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectUpdate', 'project', project)
            // verify required parameter 'updateProjectRequest' is not null or undefined
            assertParamExists('projectUpdate', 'updateProjectRequest', updateProjectRequest)
            const localVarPath = `/project/{project}`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} project The project ID
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectUpdate2: async (project: string, updateProjectRequest: UpdateProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectUpdate2', 'project', project)
            // verify required parameter 'updateProjectRequest' is not null or undefined
            assertParamExists('projectUpdate2', 'updateProjectRequest', updateProjectRequest)
            const localVarPath = `/project/{project}`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectApi - functional programming interface
 */
export const ProjectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} project The project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectDestroy(project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectDestroy(project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all visible projects. The project becomes \"visible\" when all conditions are matched: - is_enabled is true - is_launched is true - current date >= launch_date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectEnabled(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectEnabled200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectEnabled(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectEnabled']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Toggle Enable/disable on a project
         * @param {string} project The project ID
         * @param {SetEnabledProjectRequest} setEnabledProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectSetEnabled(project: string, setEnabledProjectRequest: SetEnabledProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectSetEnabled(project, setEnabledProjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectSetEnabled']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Toggle Launched/not-launched on a project. Important: It is independant from the `launch_date` value. It is an idicator showing that the project is to be considered \'laucnhed\' as soon as the launch date it reached
         * @param {string} project The project ID
         * @param {SetLaunchedProjectRequest} setLaunchedProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectSetLaunched(project: string, setLaunchedProjectRequest: SetLaunchedProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectSetLaunched(project, setLaunchedProjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectSetLaunched']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} project The project ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectShow(project: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectShow(project, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreProjectRequest} storeProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectStore(storeProjectRequest: StoreProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectStore(storeProjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} project The project ID
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectUpdate(project: string, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectUpdate(project, updateProjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} project The project ID
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectUpdate2(project: string, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectUpdate2(project, updateProjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectApi - factory interface
 */
export const ProjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} project The project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDestroy(project: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.projectDestroy(project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all visible projects. The project becomes \"visible\" when all conditions are matched: - is_enabled is true - is_launched is true - current date >= launch_date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEnabled(options?: RawAxiosRequestConfig): AxiosPromise<ProjectEnabled200Response> {
            return localVarFp.projectEnabled(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectIndex200Response> {
            return localVarFp.projectIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Toggle Enable/disable on a project
         * @param {string} project The project ID
         * @param {SetEnabledProjectRequest} setEnabledProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSetEnabled(project: string, setEnabledProjectRequest: SetEnabledProjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectShow200Response> {
            return localVarFp.projectSetEnabled(project, setEnabledProjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Toggle Launched/not-launched on a project. Important: It is independant from the `launch_date` value. It is an idicator showing that the project is to be considered \'laucnhed\' as soon as the launch date it reached
         * @param {string} project The project ID
         * @param {SetLaunchedProjectRequest} setLaunchedProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSetLaunched(project: string, setLaunchedProjectRequest: SetLaunchedProjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectShow200Response> {
            return localVarFp.projectSetLaunched(project, setLaunchedProjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} project The project ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectShow(project: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectShow200Response> {
            return localVarFp.projectShow(project, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreProjectRequest} storeProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStore(storeProjectRequest: StoreProjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectShow200Response> {
            return localVarFp.projectStore(storeProjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} project The project ID
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectUpdate(project: string, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectShow200Response> {
            return localVarFp.projectUpdate(project, updateProjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} project The project ID
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectUpdate2(project: string, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectShow200Response> {
            return localVarFp.projectUpdate2(project, updateProjectRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectApi - object-oriented interface
 */
export class ProjectApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} project The project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectDestroy(project: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectDestroy(project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all visible projects. The project becomes \"visible\" when all conditions are matched: - is_enabled is true - is_launched is true - current date >= launch_date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectEnabled(options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectEnabled(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Toggle Enable/disable on a project
     * @param {string} project The project ID
     * @param {SetEnabledProjectRequest} setEnabledProjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectSetEnabled(project: string, setEnabledProjectRequest: SetEnabledProjectRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectSetEnabled(project, setEnabledProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Toggle Launched/not-launched on a project. Important: It is independant from the `launch_date` value. It is an idicator showing that the project is to be considered \'laucnhed\' as soon as the launch date it reached
     * @param {string} project The project ID
     * @param {SetLaunchedProjectRequest} setLaunchedProjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectSetLaunched(project: string, setLaunchedProjectRequest: SetLaunchedProjectRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectSetLaunched(project, setLaunchedProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} project The project ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectShow(project: string, include?: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectShow(project, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreProjectRequest} storeProjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectStore(storeProjectRequest: StoreProjectRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectStore(storeProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} project The project ID
     * @param {UpdateProjectRequest} updateProjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectUpdate(project: string, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectUpdate(project, updateProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} project The project ID
     * @param {UpdateProjectRequest} updateProjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectUpdate2(project: string, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectUpdate2(project, updateProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProvinceApi - axios parameter creator
 */
export const ProvinceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified province
         * @param {string} province The province ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceDestroy: async (province: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'province' is not null or undefined
            assertParamExists('provinceDestroy', 'province', province)
            const localVarPath = `/province/{province}`
                .replace(`{${"province"}}`, encodeURIComponent(String(province)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of provinces
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/province`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified province
         * @param {string} province The province ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceShow: async (province: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'province' is not null or undefined
            assertParamExists('provinceShow', 'province', province)
            const localVarPath = `/province/{province}`
                .replace(`{${"province"}}`, encodeURIComponent(String(province)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created province
         * @param {StoreProvinceRequest} storeProvinceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceStore: async (storeProvinceRequest: StoreProvinceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeProvinceRequest' is not null or undefined
            assertParamExists('provinceStore', 'storeProvinceRequest', storeProvinceRequest)
            const localVarPath = `/province`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeProvinceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified province
         * @param {string} province The province ID
         * @param {UpdateProvinceRequest} updateProvinceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceUpdate: async (province: string, updateProvinceRequest: UpdateProvinceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'province' is not null or undefined
            assertParamExists('provinceUpdate', 'province', province)
            // verify required parameter 'updateProvinceRequest' is not null or undefined
            assertParamExists('provinceUpdate', 'updateProvinceRequest', updateProvinceRequest)
            const localVarPath = `/province/{province}`
                .replace(`{${"province"}}`, encodeURIComponent(String(province)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProvinceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified province
         * @param {string} province The province ID
         * @param {UpdateProvinceRequest} updateProvinceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceUpdate2: async (province: string, updateProvinceRequest: UpdateProvinceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'province' is not null or undefined
            assertParamExists('provinceUpdate2', 'province', province)
            // verify required parameter 'updateProvinceRequest' is not null or undefined
            assertParamExists('provinceUpdate2', 'updateProvinceRequest', updateProvinceRequest)
            const localVarPath = `/province/{province}`
                .replace(`{${"province"}}`, encodeURIComponent(String(province)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProvinceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvinceApi - functional programming interface
 */
export const ProvinceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProvinceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified province
         * @param {string} province The province ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceDestroy(province: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceDestroy(province, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of provinces
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified province
         * @param {string} province The province ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceShow(province: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceShow(province, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created province
         * @param {StoreProvinceRequest} storeProvinceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceStore(storeProvinceRequest: StoreProvinceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceStore(storeProvinceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified province
         * @param {string} province The province ID
         * @param {UpdateProvinceRequest} updateProvinceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceUpdate(province: string, updateProvinceRequest: UpdateProvinceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceUpdate(province, updateProvinceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified province
         * @param {string} province The province ID
         * @param {UpdateProvinceRequest} updateProvinceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceUpdate2(province: string, updateProvinceRequest: UpdateProvinceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceUpdate2(province, updateProvinceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProvinceApi - factory interface
 */
export const ProvinceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProvinceApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified province
         * @param {string} province The province ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceDestroy(province: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.provinceDestroy(province, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of provinces
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceIndex200Response> {
            return localVarFp.provinceIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified province
         * @param {string} province The province ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceShow(province: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceShow200Response> {
            return localVarFp.provinceShow(province, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created province
         * @param {StoreProvinceRequest} storeProvinceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceStore(storeProvinceRequest: StoreProvinceRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceShow200Response> {
            return localVarFp.provinceStore(storeProvinceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified province
         * @param {string} province The province ID
         * @param {UpdateProvinceRequest} updateProvinceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceUpdate(province: string, updateProvinceRequest: UpdateProvinceRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceShow200Response> {
            return localVarFp.provinceUpdate(province, updateProvinceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified province
         * @param {string} province The province ID
         * @param {UpdateProvinceRequest} updateProvinceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceUpdate2(province: string, updateProvinceRequest: UpdateProvinceRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceShow200Response> {
            return localVarFp.provinceUpdate2(province, updateProvinceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProvinceApi - object-oriented interface
 */
export class ProvinceApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified province
     * @param {string} province The province ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceDestroy(province: string, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceDestroy(province, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of provinces
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified province
     * @param {string} province The province ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceShow(province: string, include?: string, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceShow(province, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created province
     * @param {StoreProvinceRequest} storeProvinceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceStore(storeProvinceRequest: StoreProvinceRequest, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceStore(storeProvinceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified province
     * @param {string} province The province ID
     * @param {UpdateProvinceRequest} updateProvinceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceUpdate(province: string, updateProvinceRequest: UpdateProvinceRequest, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceUpdate(province, updateProvinceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified province
     * @param {string} province The province ID
     * @param {UpdateProvinceRequest} updateProvinceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceUpdate2(province: string, updateProvinceRequest: UpdateProvinceRequest, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceUpdate2(province, updateProvinceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProvinceTranslationApi - axios parameter creator
 */
export const ProvinceTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationDestroy: async (provinceTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provinceTranslation' is not null or undefined
            assertParamExists('provinceTranslationDestroy', 'provinceTranslation', provinceTranslation)
            const localVarPath = `/province-translation/{provinceTranslation}`
                .replace(`{${"provinceTranslation"}}`, encodeURIComponent(String(provinceTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/province-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationShow: async (provinceTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provinceTranslation' is not null or undefined
            assertParamExists('provinceTranslationShow', 'provinceTranslation', provinceTranslation)
            const localVarPath = `/province-translation/{provinceTranslation}`
                .replace(`{${"provinceTranslation"}}`, encodeURIComponent(String(provinceTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreProvinceTranslationRequest} storeProvinceTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationStore: async (storeProvinceTranslationRequest: StoreProvinceTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeProvinceTranslationRequest' is not null or undefined
            assertParamExists('provinceTranslationStore', 'storeProvinceTranslationRequest', storeProvinceTranslationRequest)
            const localVarPath = `/province-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeProvinceTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} provinceTranslation The province translation ID
         * @param {UpdateProvinceTranslationRequest} [updateProvinceTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationUpdate: async (provinceTranslation: string, updateProvinceTranslationRequest?: UpdateProvinceTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provinceTranslation' is not null or undefined
            assertParamExists('provinceTranslationUpdate', 'provinceTranslation', provinceTranslation)
            const localVarPath = `/province-translation/{provinceTranslation}`
                .replace(`{${"provinceTranslation"}}`, encodeURIComponent(String(provinceTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProvinceTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} provinceTranslation The province translation ID
         * @param {UpdateProvinceTranslationRequest} [updateProvinceTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationUpdate2: async (provinceTranslation: string, updateProvinceTranslationRequest?: UpdateProvinceTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provinceTranslation' is not null or undefined
            assertParamExists('provinceTranslationUpdate2', 'provinceTranslation', provinceTranslation)
            const localVarPath = `/province-translation/{provinceTranslation}`
                .replace(`{${"provinceTranslation"}}`, encodeURIComponent(String(provinceTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProvinceTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvinceTranslationApi - functional programming interface
 */
export const ProvinceTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProvinceTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationDestroy(provinceTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationDestroy(provinceTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationShow(provinceTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationShow(provinceTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreProvinceTranslationRequest} storeProvinceTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationStore(storeProvinceTranslationRequest: StoreProvinceTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationStore(storeProvinceTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} provinceTranslation The province translation ID
         * @param {UpdateProvinceTranslationRequest} [updateProvinceTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationUpdate(provinceTranslation: string, updateProvinceTranslationRequest?: UpdateProvinceTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationUpdate(provinceTranslation, updateProvinceTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} provinceTranslation The province translation ID
         * @param {UpdateProvinceTranslationRequest} [updateProvinceTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationUpdate2(provinceTranslation: string, updateProvinceTranslationRequest?: UpdateProvinceTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationUpdate2(provinceTranslation, updateProvinceTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProvinceTranslationApi - factory interface
 */
export const ProvinceTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProvinceTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationDestroy(provinceTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.provinceTranslationDestroy(provinceTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<ProvinceTranslationIndex200Response> {
            return localVarFp.provinceTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationShow(provinceTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceTranslationShow200Response> {
            return localVarFp.provinceTranslationShow(provinceTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreProvinceTranslationRequest} storeProvinceTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationStore(storeProvinceTranslationRequest: StoreProvinceTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceTranslationShow200Response> {
            return localVarFp.provinceTranslationStore(storeProvinceTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} provinceTranslation The province translation ID
         * @param {UpdateProvinceTranslationRequest} [updateProvinceTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationUpdate(provinceTranslation: string, updateProvinceTranslationRequest?: UpdateProvinceTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceTranslationShow200Response> {
            return localVarFp.provinceTranslationUpdate(provinceTranslation, updateProvinceTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} provinceTranslation The province translation ID
         * @param {UpdateProvinceTranslationRequest} [updateProvinceTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationUpdate2(provinceTranslation: string, updateProvinceTranslationRequest?: UpdateProvinceTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceTranslationShow200Response> {
            return localVarFp.provinceTranslationUpdate2(provinceTranslation, updateProvinceTranslationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProvinceTranslationApi - object-oriented interface
 */
export class ProvinceTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} provinceTranslation The province translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceTranslationDestroy(provinceTranslation: string, options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationDestroy(provinceTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceTranslationIndex(options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} provinceTranslation The province translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceTranslationShow(provinceTranslation: string, options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationShow(provinceTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreProvinceTranslationRequest} storeProvinceTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceTranslationStore(storeProvinceTranslationRequest: StoreProvinceTranslationRequest, options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationStore(storeProvinceTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} provinceTranslation The province translation ID
     * @param {UpdateProvinceTranslationRequest} [updateProvinceTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceTranslationUpdate(provinceTranslation: string, updateProvinceTranslationRequest?: UpdateProvinceTranslationRequest, options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationUpdate(provinceTranslation, updateProvinceTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} provinceTranslation The province translation ID
     * @param {UpdateProvinceTranslationRequest} [updateProvinceTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public provinceTranslationUpdate2(provinceTranslation: string, updateProvinceTranslationRequest?: UpdateProvinceTranslationRequest, options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationUpdate2(provinceTranslation, updateProvinceTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagApi - axios parameter creator
 */
export const TagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDestroy: async (tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('tagDestroy', 'tag', tag)
            const localVarPath = `/tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tags for a specific item
         * @param {string} item The item ID
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagForItem: async (item: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('tagForItem', 'item', item)
            const localVarPath = `/tag/for-item/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagIndex: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagShow: async (tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('tagShow', 'tag', tag)
            const localVarPath = `/tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreTagRequest} storeTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagStore: async (storeTagRequest: StoreTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeTagRequest' is not null or undefined
            assertParamExists('tagStore', 'storeTagRequest', storeTagRequest)
            const localVarPath = `/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} tag The tag ID
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagUpdate: async (tag: string, updateTagRequest: UpdateTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('tagUpdate', 'tag', tag)
            // verify required parameter 'updateTagRequest' is not null or undefined
            assertParamExists('tagUpdate', 'updateTagRequest', updateTagRequest)
            const localVarPath = `/tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} tag The tag ID
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagUpdate2: async (tag: string, updateTagRequest: UpdateTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('tagUpdate2', 'tag', tag)
            // verify required parameter 'updateTagRequest' is not null or undefined
            assertParamExists('tagUpdate2', 'updateTagRequest', updateTagRequest)
            const localVarPath = `/tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagApi - functional programming interface
 */
export const TagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagDestroy(tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagDestroy(tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get tags for a specific item
         * @param {string} item The item ID
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagForItem(item: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagForItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagForItem(item, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagForItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagIndex(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagForItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagIndex(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagShow(tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagShow(tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreTagRequest} storeTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagStore(storeTagRequest: StoreTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagStore(storeTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} tag The tag ID
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagUpdate(tag: string, updateTagRequest: UpdateTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagUpdate(tag, updateTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} tag The tag ID
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagUpdate2(tag: string, updateTagRequest: UpdateTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagUpdate2(tag, updateTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagApi - factory interface
 */
export const TagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDestroy(tag: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tagDestroy(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tags for a specific item
         * @param {string} item The item ID
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagForItem(item: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<TagForItem200Response> {
            return localVarFp.tagForItem(item, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagIndex(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<TagForItem200Response> {
            return localVarFp.tagIndex(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagShow(tag: string, options?: RawAxiosRequestConfig): AxiosPromise<TagShow200Response> {
            return localVarFp.tagShow(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreTagRequest} storeTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagStore(storeTagRequest: StoreTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<TagShow200Response> {
            return localVarFp.tagStore(storeTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} tag The tag ID
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagUpdate(tag: string, updateTagRequest: UpdateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<TagShow200Response> {
            return localVarFp.tagUpdate(tag, updateTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} tag The tag ID
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagUpdate2(tag: string, updateTagRequest: UpdateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<TagShow200Response> {
            return localVarFp.tagUpdate2(tag, updateTagRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagApi - object-oriented interface
 */
export class TagApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} tag The tag ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagDestroy(tag: string, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagDestroy(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tags for a specific item
     * @param {string} item The item ID
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagForItem(item: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagForItem(item, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagIndex(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagIndex(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} tag The tag ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagShow(tag: string, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagShow(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreTagRequest} storeTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagStore(storeTagRequest: StoreTagRequest, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagStore(storeTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} tag The tag ID
     * @param {UpdateTagRequest} updateTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagUpdate(tag: string, updateTagRequest: UpdateTagRequest, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagUpdate(tag, updateTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} tag The tag ID
     * @param {UpdateTagRequest} updateTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagUpdate2(tag: string, updateTagRequest: UpdateTagRequest, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagUpdate2(tag, updateTagRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ThemeApi - axios parameter creator
 */
export const ThemeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified theme from storage
         * @param {string} theme The theme ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeDestroy: async (theme: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'theme' is not null or undefined
            assertParamExists('themeDestroy', 'theme', theme)
            const localVarPath = `/theme/{theme}`
                .replace(`{${"theme"}}`, encodeURIComponent(String(theme)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/theme`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} theme The theme ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeShow: async (theme: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'theme' is not null or undefined
            assertParamExists('themeShow', 'theme', theme)
            const localVarPath = `/theme/{theme}`
                .replace(`{${"theme"}}`, encodeURIComponent(String(theme)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created theme in storage
         * @param {StoreThemeRequest} storeThemeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeStore: async (storeThemeRequest: StoreThemeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeThemeRequest' is not null or undefined
            assertParamExists('themeStore', 'storeThemeRequest', storeThemeRequest)
            const localVarPath = `/theme`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeThemeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified theme in storage
         * @param {string} theme The theme ID
         * @param {UpdateThemeRequest} [updateThemeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeUpdate: async (theme: string, updateThemeRequest?: UpdateThemeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'theme' is not null or undefined
            assertParamExists('themeUpdate', 'theme', theme)
            const localVarPath = `/theme/{theme}`
                .replace(`{${"theme"}}`, encodeURIComponent(String(theme)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateThemeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified theme in storage
         * @param {string} theme The theme ID
         * @param {UpdateThemeRequest} [updateThemeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeUpdate2: async (theme: string, updateThemeRequest?: UpdateThemeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'theme' is not null or undefined
            assertParamExists('themeUpdate2', 'theme', theme)
            const localVarPath = `/theme/{theme}`
                .replace(`{${"theme"}}`, encodeURIComponent(String(theme)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateThemeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThemeApi - functional programming interface
 */
export const ThemeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThemeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme from storage
         * @param {string} theme The theme ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeDestroy(theme: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeDestroy(theme, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeApi.themeDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeApi.themeIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} theme The theme ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeShow(theme: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeShow(theme, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeApi.themeShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created theme in storage
         * @param {StoreThemeRequest} storeThemeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeStore(storeThemeRequest: StoreThemeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeStore(storeThemeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeApi.themeStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified theme in storage
         * @param {string} theme The theme ID
         * @param {UpdateThemeRequest} [updateThemeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeUpdate(theme: string, updateThemeRequest?: UpdateThemeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeUpdate(theme, updateThemeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeApi.themeUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified theme in storage
         * @param {string} theme The theme ID
         * @param {UpdateThemeRequest} [updateThemeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeUpdate2(theme: string, updateThemeRequest?: UpdateThemeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeUpdate2(theme, updateThemeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeApi.themeUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ThemeApi - factory interface
 */
export const ThemeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThemeApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme from storage
         * @param {string} theme The theme ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeDestroy(theme: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.themeDestroy(theme, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ThemeIndex200Response> {
            return localVarFp.themeIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} theme The theme ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeShow(theme: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ThemeShow200Response> {
            return localVarFp.themeShow(theme, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created theme in storage
         * @param {StoreThemeRequest} storeThemeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeStore(storeThemeRequest: StoreThemeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeShow200Response> {
            return localVarFp.themeStore(storeThemeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified theme in storage
         * @param {string} theme The theme ID
         * @param {UpdateThemeRequest} [updateThemeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeUpdate(theme: string, updateThemeRequest?: UpdateThemeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeShow200Response> {
            return localVarFp.themeUpdate(theme, updateThemeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified theme in storage
         * @param {string} theme The theme ID
         * @param {UpdateThemeRequest} [updateThemeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeUpdate2(theme: string, updateThemeRequest?: UpdateThemeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeShow200Response> {
            return localVarFp.themeUpdate2(theme, updateThemeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThemeApi - object-oriented interface
 */
export class ThemeApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified theme from storage
     * @param {string} theme The theme ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeDestroy(theme: string, options?: RawAxiosRequestConfig) {
        return ThemeApiFp(this.configuration).themeDestroy(theme, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return ThemeApiFp(this.configuration).themeIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} theme The theme ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeShow(theme: string, include?: string, options?: RawAxiosRequestConfig) {
        return ThemeApiFp(this.configuration).themeShow(theme, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created theme in storage
     * @param {StoreThemeRequest} storeThemeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeStore(storeThemeRequest: StoreThemeRequest, options?: RawAxiosRequestConfig) {
        return ThemeApiFp(this.configuration).themeStore(storeThemeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified theme in storage
     * @param {string} theme The theme ID
     * @param {UpdateThemeRequest} [updateThemeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeUpdate(theme: string, updateThemeRequest?: UpdateThemeRequest, options?: RawAxiosRequestConfig) {
        return ThemeApiFp(this.configuration).themeUpdate(theme, updateThemeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified theme in storage
     * @param {string} theme The theme ID
     * @param {UpdateThemeRequest} [updateThemeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeUpdate2(theme: string, updateThemeRequest?: UpdateThemeRequest, options?: RawAxiosRequestConfig) {
        return ThemeApiFp(this.configuration).themeUpdate2(theme, updateThemeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ThemeTranslationApi - axios parameter creator
 */
export const ThemeTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationDestroy: async (themeTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationDestroy', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {string} [themeId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationIndex: async (themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/theme-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (themeId !== undefined) {
                localVarQueryParameter['theme_id'] = themeId;
            }

            if (languageId !== undefined) {
                localVarQueryParameter['language_id'] = languageId;
            }

            if (contextId !== undefined) {
                localVarQueryParameter['context_id'] = contextId;
            }

            if (defaultContext !== undefined) {
                localVarQueryParameter['default_context'] = defaultContext;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationShow: async (themeTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationShow', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {StoreThemeTranslationRequest} storeThemeTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationStore: async (storeThemeTranslationRequest: StoreThemeTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeThemeTranslationRequest' is not null or undefined
            assertParamExists('themeTranslationStore', 'storeThemeTranslationRequest', storeThemeTranslationRequest)
            const localVarPath = `/theme-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeThemeTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate: async (themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationUpdate', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateThemeTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate2: async (themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationUpdate2', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateThemeTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThemeTranslationApi - functional programming interface
 */
export const ThemeTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThemeTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationDestroy(themeTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationApi.themeTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {string} [themeId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationIndex(themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThemeTranslationResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationIndex(themeId, languageId, contextId, defaultContext, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationApi.themeTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationShow(themeTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationApi.themeTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {StoreThemeTranslationRequest} storeThemeTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationStore(storeThemeTranslationRequest: StoreThemeTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationStore(storeThemeTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationApi.themeTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationUpdate(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationUpdate(themeTranslation, updateThemeTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationApi.themeTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationUpdate2(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationUpdate2(themeTranslation, updateThemeTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationApi.themeTranslationUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ThemeTranslationApi - factory interface
 */
export const ThemeTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThemeTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.themeTranslationDestroy(themeTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {string} [themeId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationIndex(themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<ThemeTranslationResource>> {
            return localVarFp.themeTranslationIndex(themeId, languageId, contextId, defaultContext, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationShow200Response> {
            return localVarFp.themeTranslationShow(themeTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {StoreThemeTranslationRequest} storeThemeTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationStore(storeThemeTranslationRequest: StoreThemeTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationShow200Response> {
            return localVarFp.themeTranslationStore(storeThemeTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationShow200Response> {
            return localVarFp.themeTranslationUpdate(themeTranslation, updateThemeTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate2(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationShow200Response> {
            return localVarFp.themeTranslationUpdate2(themeTranslation, updateThemeTranslationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThemeTranslationApi - object-oriented interface
 */
export class ThemeTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig) {
        return ThemeTranslationApiFp(this.configuration).themeTranslationDestroy(themeTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of theme translations
     * @param {string} [themeId] 
     * @param {string} [languageId] 
     * @param {string} [contextId] 
     * @param {boolean} [defaultContext] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationIndex(themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig) {
        return ThemeTranslationApiFp(this.configuration).themeTranslationIndex(themeId, languageId, contextId, defaultContext, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig) {
        return ThemeTranslationApiFp(this.configuration).themeTranslationShow(themeTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created theme translation
     * @param {StoreThemeTranslationRequest} storeThemeTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationStore(storeThemeTranslationRequest: StoreThemeTranslationRequest, options?: RawAxiosRequestConfig) {
        return ThemeTranslationApiFp(this.configuration).themeTranslationStore(storeThemeTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationUpdate(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig) {
        return ThemeTranslationApiFp(this.configuration).themeTranslationUpdate(themeTranslation, updateThemeTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationUpdate2(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig) {
        return ThemeTranslationApiFp(this.configuration).themeTranslationUpdate2(themeTranslation, updateThemeTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ThemeTranslationsApi - axios parameter creator
 */
export const ThemeTranslationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationDestroy: async (themeTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationDestroy', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {string} [themeId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationIndex: async (themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/theme-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (themeId !== undefined) {
                localVarQueryParameter['theme_id'] = themeId;
            }

            if (languageId !== undefined) {
                localVarQueryParameter['language_id'] = languageId;
            }

            if (contextId !== undefined) {
                localVarQueryParameter['context_id'] = contextId;
            }

            if (defaultContext !== undefined) {
                localVarQueryParameter['default_context'] = defaultContext;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationShow: async (themeTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationShow', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {StoreThemeTranslationRequest} storeThemeTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationStore: async (storeThemeTranslationRequest: StoreThemeTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeThemeTranslationRequest' is not null or undefined
            assertParamExists('themeTranslationStore', 'storeThemeTranslationRequest', storeThemeTranslationRequest)
            const localVarPath = `/theme-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeThemeTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate: async (themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationUpdate', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateThemeTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate2: async (themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationUpdate2', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateThemeTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThemeTranslationsApi - functional programming interface
 */
export const ThemeTranslationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThemeTranslationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationDestroy(themeTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationsApi.themeTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {string} [themeId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationIndex(themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThemeTranslationResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationIndex(themeId, languageId, contextId, defaultContext, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationsApi.themeTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationShow(themeTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationsApi.themeTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {StoreThemeTranslationRequest} storeThemeTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationStore(storeThemeTranslationRequest: StoreThemeTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationStore(storeThemeTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationsApi.themeTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationUpdate(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationUpdate(themeTranslation, updateThemeTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationsApi.themeTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationUpdate2(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationUpdate2(themeTranslation, updateThemeTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationsApi.themeTranslationUpdate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ThemeTranslationsApi - factory interface
 */
export const ThemeTranslationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThemeTranslationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.themeTranslationDestroy(themeTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {string} [themeId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationIndex(themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<ThemeTranslationResource>> {
            return localVarFp.themeTranslationIndex(themeId, languageId, contextId, defaultContext, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationShow200Response> {
            return localVarFp.themeTranslationShow(themeTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {StoreThemeTranslationRequest} storeThemeTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationStore(storeThemeTranslationRequest: StoreThemeTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationShow200Response> {
            return localVarFp.themeTranslationStore(storeThemeTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationShow200Response> {
            return localVarFp.themeTranslationUpdate(themeTranslation, updateThemeTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate2(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationShow200Response> {
            return localVarFp.themeTranslationUpdate2(themeTranslation, updateThemeTranslationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThemeTranslationsApi - object-oriented interface
 */
export class ThemeTranslationsApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig) {
        return ThemeTranslationsApiFp(this.configuration).themeTranslationDestroy(themeTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of theme translations
     * @param {string} [themeId] 
     * @param {string} [languageId] 
     * @param {string} [contextId] 
     * @param {boolean} [defaultContext] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationIndex(themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig) {
        return ThemeTranslationsApiFp(this.configuration).themeTranslationIndex(themeId, languageId, contextId, defaultContext, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig) {
        return ThemeTranslationsApiFp(this.configuration).themeTranslationShow(themeTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created theme translation
     * @param {StoreThemeTranslationRequest} storeThemeTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationStore(storeThemeTranslationRequest: StoreThemeTranslationRequest, options?: RawAxiosRequestConfig) {
        return ThemeTranslationsApiFp(this.configuration).themeTranslationStore(storeThemeTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationUpdate(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig) {
        return ThemeTranslationsApiFp(this.configuration).themeTranslationUpdate(themeTranslation, updateThemeTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {UpdateThemeTranslationRequest} [updateThemeTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public themeTranslationUpdate2(themeTranslation: string, updateThemeTranslationRequest?: UpdateThemeTranslationRequest, options?: RawAxiosRequestConfig) {
        return ThemeTranslationsApiFp(this.configuration).themeTranslationUpdate2(themeTranslation, updateThemeTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserPermissionsApi - axios parameter creator
 */
export const UserPermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of permission names that the authenticated user has. This is a read-only endpoint for UI clients to determine what features to show to the user.
         * @summary Get the authenticated user\'s permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPermissions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserPermissionsApi - functional programming interface
 */
export const UserPermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserPermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of permission names that the authenticated user has. This is a read-only endpoint for UI clients to determine what features to show to the user.
         * @summary Get the authenticated user\'s permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPermissions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPermissions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPermissions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserPermissionsApi.userPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserPermissionsApi - factory interface
 */
export const UserPermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserPermissionsApiFp(configuration)
    return {
        /**
         * Returns a list of permission names that the authenticated user has. This is a read-only endpoint for UI clients to determine what features to show to the user.
         * @summary Get the authenticated user\'s permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPermissions(options?: RawAxiosRequestConfig): AxiosPromise<UserPermissions200Response> {
            return localVarFp.userPermissions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserPermissionsApi - object-oriented interface
 */
export class UserPermissionsApi extends BaseAPI {
    /**
     * Returns a list of permission names that the authenticated user has. This is a read-only endpoint for UI clients to determine what features to show to the user.
     * @summary Get the authenticated user\'s permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userPermissions(options?: RawAxiosRequestConfig) {
        return UserPermissionsApiFp(this.configuration).userPermissions(options).then((request) => request(this.axios, this.basePath));
    }
}



