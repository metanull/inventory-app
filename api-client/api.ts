/* tslint:disable */
/* eslint-disable */
/**
 * Inventory-App
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddressIndex200Response
 */
export interface AddressIndex200Response {
    /**
     * 
     * @type {Array<AddressResource>}
     * @memberof AddressIndex200Response
     */
    'data': Array<AddressResource>;
}
/**
 * 
 * @export
 * @interface AddressResource
 */
export interface AddressResource {
    /**
     * 
     * @type {string}
     * @memberof AddressResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AddressResource
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof AddressResource
     */
    'country_id': string;
    /**
     * 
     * @type {Array<AddressTranslationResource>}
     * @memberof AddressResource
     */
    'translations'?: Array<AddressTranslationResource>;
    /**
     * 
     * @type {string}
     * @memberof AddressResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface AddressStore201Response
 */
export interface AddressStore201Response {
    /**
     * 
     * @type {AddressResource}
     * @memberof AddressStore201Response
     */
    'data': AddressResource;
}
/**
 * 
 * @export
 * @interface AddressStore422Response
 */
export interface AddressStore422Response {
    /**
     * 
     * @type {string}
     * @memberof AddressStore422Response
     */
    'errors': string;
}
/**
 * 
 * @export
 * @interface AddressStoreRequest
 */
export interface AddressStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressStoreRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {number}
     * @memberof AddressStoreRequest
     */
    'country_id': number;
    /**
     * 
     * @type {Array<AddressStoreRequestTranslationsInner>}
     * @memberof AddressStoreRequest
     */
    'translations'?: Array<AddressStoreRequestTranslationsInner>;
}
/**
 * 
 * @export
 * @interface AddressStoreRequestTranslationsInner
 */
export interface AddressStoreRequestTranslationsInner {
    /**
     * 
     * @type {number}
     * @memberof AddressStoreRequestTranslationsInner
     */
    'language_id': number;
    /**
     * 
     * @type {string}
     * @memberof AddressStoreRequestTranslationsInner
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof AddressStoreRequestTranslationsInner
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface AddressTranslationIndex200Response
 */
export interface AddressTranslationIndex200Response {
    /**
     * 
     * @type {Array<AddressTranslationResource>}
     * @memberof AddressTranslationIndex200Response
     */
    'data': Array<AddressTranslationResource>;
}
/**
 * 
 * @export
 * @interface AddressTranslationResource
 */
export interface AddressTranslationResource {
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationResource
     */
    'address_id': string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationResource
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationResource
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationResource
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface AddressTranslationStore200Response
 */
export interface AddressTranslationStore200Response {
    /**
     * 
     * @type {AddressTranslationResource}
     * @memberof AddressTranslationStore200Response
     */
    'data': AddressTranslationResource;
}
/**
 * 
 * @export
 * @interface AddressTranslationStoreRequest
 */
export interface AddressTranslationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationStoreRequest
     */
    'address_id': string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationStoreRequest
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationStoreRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface AddressTranslationUpdateRequest
 */
export interface AddressTranslationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationUpdateRequest
     */
    'address_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationUpdateRequest
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationUpdateRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface AddressUpdateRequest
 */
export interface AddressUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressUpdateRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdateRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {number}
     * @memberof AddressUpdateRequest
     */
    'country_id': number;
    /**
     * 
     * @type {Array<AddressUpdateRequestTranslationsInner>}
     * @memberof AddressUpdateRequest
     */
    'translations'?: Array<AddressUpdateRequestTranslationsInner>;
}
/**
 * 
 * @export
 * @interface AddressUpdateRequestTranslationsInner
 */
export interface AddressUpdateRequestTranslationsInner {
    /**
     * 
     * @type {number}
     * @memberof AddressUpdateRequestTranslationsInner
     */
    'language_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdateRequestTranslationsInner
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdateRequestTranslationsInner
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface ArtistResource
 */
export interface ArtistResource {
    /**
     * 
     * @type {string}
     * @memberof ArtistResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ArtistResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ArtistResource
     */
    'place_of_birth': string | null;
    /**
     * 
     * @type {string}
     * @memberof ArtistResource
     */
    'place_of_death': string | null;
    /**
     * 
     * @type {string}
     * @memberof ArtistResource
     */
    'date_of_birth': string | null;
    /**
     * 
     * @type {string}
     * @memberof ArtistResource
     */
    'date_of_death': string | null;
    /**
     * 
     * @type {string}
     * @memberof ArtistResource
     */
    'period_of_activity': string | null;
    /**
     * 
     * @type {string}
     * @memberof ArtistResource
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ArtistResource
     */
    'backward_compatibility': string | null;
    /**
     * 
     * @type {string}
     * @memberof ArtistResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof ArtistResource
     */
    'updated_at': string | null;
    /**
     * 
     * @type {Array<ItemResource>}
     * @memberof ArtistResource
     */
    'items'?: Array<ItemResource>;
}
/**
 * 
 * @export
 * @interface AuthorResource
 */
export interface AuthorResource {
    /**
     * 
     * @type {string}
     * @memberof AuthorResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AuthorResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AuthorResource
     */
    'internal_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthorResource
     */
    'backward_compatibility': string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthorResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthorResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface AvailableImageIndex200Response
 */
export interface AvailableImageIndex200Response {
    /**
     * 
     * @type {Array<AvailableImageResource>}
     * @memberof AvailableImageIndex200Response
     */
    'data': Array<AvailableImageResource>;
}
/**
 * 
 * @export
 * @interface AvailableImageResource
 */
export interface AvailableImageResource {
    /**
     * The unique identifier of the picture (GUID)
     * @type {string}
     * @memberof AvailableImageResource
     */
    'id': string;
    /**
     * The path to the picture file
     * @type {string}
     * @memberof AvailableImageResource
     */
    'path': string | null;
    /**
     * A user defined comment associated with the file
     * @type {string}
     * @memberof AvailableImageResource
     */
    'comment': string | null;
    /**
     * Date of creation
     * @type {string}
     * @memberof AvailableImageResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof AvailableImageResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface AvailableImageShow200Response
 */
export interface AvailableImageShow200Response {
    /**
     * 
     * @type {AvailableImageResource}
     * @memberof AvailableImageShow200Response
     */
    'data': AvailableImageResource;
}
/**
 * 
 * @export
 * @interface AvailableImageUpdateRequest
 */
export interface AvailableImageUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof AvailableImageUpdateRequest
     */
    'comment'?: string | null;
}
/**
 * 
 * @export
 * @interface CollectionIndex200Response
 */
export interface CollectionIndex200Response {
    /**
     * 
     * @type {Array<CollectionResource>}
     * @memberof CollectionIndex200Response
     */
    'data': Array<CollectionResource>;
}
/**
 * 
 * @export
 * @interface CollectionResource
 */
export interface CollectionResource {
    /**
     * 
     * @type {string}
     * @memberof CollectionResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CollectionResource
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof CollectionResource
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof CollectionResource
     */
    'context_id': string;
    /**
     * 
     * @type {string}
     * @memberof CollectionResource
     */
    'backward_compatibility': string | null;
    /**
     * 
     * @type {string}
     * @memberof CollectionResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof CollectionResource
     */
    'updated_at': string | null;
    /**
     * Relationships
     * @type {LanguageResource}
     * @memberof CollectionResource
     */
    'language'?: LanguageResource;
    /**
     * 
     * @type {ContextResource}
     * @memberof CollectionResource
     */
    'context'?: ContextResource;
    /**
     * 
     * @type {Array<CollectionTranslationResource>}
     * @memberof CollectionResource
     */
    'translations'?: Array<CollectionTranslationResource>;
    /**
     * 
     * @type {Array<PartnerResource>}
     * @memberof CollectionResource
     */
    'partners'?: Array<PartnerResource>;
    /**
     * 
     * @type {Array<ItemResource>}
     * @memberof CollectionResource
     */
    'items'?: Array<ItemResource>;
    /**
     * Computed attributes
     * @type {string}
     * @memberof CollectionResource
     */
    'items_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectionResource
     */
    'partners_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectionResource
     */
    'translations_count'?: string;
}
/**
 * 
 * @export
 * @interface CollectionStore200Response
 */
export interface CollectionStore200Response {
    /**
     * 
     * @type {CollectionResource}
     * @memberof CollectionStore200Response
     */
    'data': CollectionResource;
}
/**
 * 
 * @export
 * @interface CollectionStoreRequest
 */
export interface CollectionStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof CollectionStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof CollectionStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof CollectionStoreRequest
     */
    'context_id': string;
    /**
     * 
     * @type {string}
     * @memberof CollectionStoreRequest
     */
    'backward_compatibility'?: string | null;
}
/**
 * 
 * @export
 * @interface CollectionTranslationResource
 */
export interface CollectionTranslationResource {
    /**
     * 
     * @type {string}
     * @memberof CollectionTranslationResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CollectionTranslationResource
     */
    'collection_id': string;
    /**
     * 
     * @type {string}
     * @memberof CollectionTranslationResource
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof CollectionTranslationResource
     */
    'context_id': string;
    /**
     * 
     * @type {string}
     * @memberof CollectionTranslationResource
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CollectionTranslationResource
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CollectionTranslationResource
     */
    'url': string | null;
    /**
     * 
     * @type {string}
     * @memberof CollectionTranslationResource
     */
    'backward_compatibility': string | null;
    /**
     * 
     * @type {Array<any>}
     * @memberof CollectionTranslationResource
     */
    'extra': Array<any> | null;
    /**
     * 
     * @type {string}
     * @memberof CollectionTranslationResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof CollectionTranslationResource
     */
    'updated_at': string | null;
    /**
     * Relationships
     * @type {CollectionResource}
     * @memberof CollectionTranslationResource
     */
    'collection'?: CollectionResource;
    /**
     * 
     * @type {LanguageResource}
     * @memberof CollectionTranslationResource
     */
    'language'?: LanguageResource;
    /**
     * 
     * @type {ContextResource}
     * @memberof CollectionTranslationResource
     */
    'context'?: ContextResource;
}
/**
 * 
 * @export
 * @interface CollectionUpdateRequest
 */
export interface CollectionUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof CollectionUpdateRequest
     */
    'internal_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectionUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectionUpdateRequest
     */
    'context_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectionUpdateRequest
     */
    'backward_compatibility'?: string | null;
}
/**
 * 
 * @export
 * @interface ContactIndex200Response
 */
export interface ContactIndex200Response {
    /**
     * 
     * @type {Array<ContactResource>}
     * @memberof ContactIndex200Response
     */
    'data': Array<ContactResource>;
}
/**
 * 
 * @export
 * @interface ContactResource
 */
export interface ContactResource {
    /**
     * 
     * @type {string}
     * @memberof ContactResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContactResource
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ContactResource
     */
    'phone_number': string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResource
     */
    'formatted_phone_number': string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResource
     */
    'fax_number': string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResource
     */
    'formatted_fax_number': string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResource
     */
    'email': string | null;
    /**
     * 
     * @type {Array<ContactTranslationResource>}
     * @memberof ContactResource
     */
    'translations'?: Array<ContactTranslationResource>;
    /**
     * 
     * @type {string}
     * @memberof ContactResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ContactStore201Response
 */
export interface ContactStore201Response {
    /**
     * 
     * @type {ContactResource}
     * @memberof ContactStore201Response
     */
    'data': ContactResource;
}
/**
 * 
 * @export
 * @interface ContactStoreRequest
 */
export interface ContactStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ContactStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ContactStoreRequest
     */
    'phone_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactStoreRequest
     */
    'fax_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactStoreRequest
     */
    'email'?: string | null;
    /**
     * 
     * @type {Array<ContactStoreRequestTranslationsInner>}
     * @memberof ContactStoreRequest
     */
    'translations': Array<ContactStoreRequestTranslationsInner>;
}
/**
 * 
 * @export
 * @interface ContactStoreRequestTranslationsInner
 */
export interface ContactStoreRequestTranslationsInner {
    /**
     * 
     * @type {number}
     * @memberof ContactStoreRequestTranslationsInner
     */
    'language_id': number;
    /**
     * 
     * @type {string}
     * @memberof ContactStoreRequestTranslationsInner
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface ContactTranslationIndex200Response
 */
export interface ContactTranslationIndex200Response {
    /**
     * 
     * @type {Array<ContactTranslationResource>}
     * @memberof ContactTranslationIndex200Response
     */
    'data': Array<ContactTranslationResource>;
}
/**
 * 
 * @export
 * @interface ContactTranslationResource
 */
export interface ContactTranslationResource {
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationResource
     */
    'contact_id': string;
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationResource
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationResource
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ContactTranslationStore200Response
 */
export interface ContactTranslationStore200Response {
    /**
     * 
     * @type {ContactTranslationResource}
     * @memberof ContactTranslationStore200Response
     */
    'data': ContactTranslationResource;
}
/**
 * 
 * @export
 * @interface ContactTranslationStoreRequest
 */
export interface ContactTranslationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationStoreRequest
     */
    'contact_id': string;
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationStoreRequest
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface ContactTranslationUpdateRequest
 */
export interface ContactTranslationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationUpdateRequest
     */
    'contact_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationUpdateRequest
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface ContactUpdateRequest
 */
export interface ContactUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateRequest
     */
    'phone_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateRequest
     */
    'fax_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateRequest
     */
    'email'?: string | null;
    /**
     * 
     * @type {Array<ContactUpdateRequestTranslationsInner>}
     * @memberof ContactUpdateRequest
     */
    'translations'?: Array<ContactUpdateRequestTranslationsInner>;
}
/**
 * 
 * @export
 * @interface ContactUpdateRequestTranslationsInner
 */
export interface ContactUpdateRequestTranslationsInner {
    /**
     * 
     * @type {number}
     * @memberof ContactUpdateRequestTranslationsInner
     */
    'language_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateRequestTranslationsInner
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface ContextGetDefault404Response
 */
export interface ContextGetDefault404Response {
    /**
     * 
     * @type {string}
     * @memberof ContextGetDefault404Response
     */
    'message': ContextGetDefault404ResponseMessageEnum;
}

export const ContextGetDefault404ResponseMessageEnum = {
    NoDefaultContextFound: 'No default context found'
} as const;

export type ContextGetDefault404ResponseMessageEnum = typeof ContextGetDefault404ResponseMessageEnum[keyof typeof ContextGetDefault404ResponseMessageEnum];

/**
 * 
 * @export
 * @interface ContextIndex200Response
 */
export interface ContextIndex200Response {
    /**
     * 
     * @type {Array<ContextResource>}
     * @memberof ContextIndex200Response
     */
    'data': Array<ContextResource>;
}
/**
 * 
 * @export
 * @interface ContextResource
 */
export interface ContextResource {
    /**
     * The unique identifier of the context (GUID)
     * @type {string}
     * @memberof ContextResource
     */
    'id': string;
    /**
     * The name of the context, it shall only be used internally
     * @type {string}
     * @memberof ContextResource
     */
    'internal_name': string;
    /**
     * The legacy Id when this context corresponds to a legacy context from the MWNF3 database, nullable
     * @type {string}
     * @memberof ContextResource
     */
    'backward_compatibility': string | null;
    /**
     * Indicates if this context is the default one. There is one single default context for the entire database.
     * @type {boolean}
     * @memberof ContextResource
     */
    'is_default': boolean;
    /**
     * Date of creation
     * @type {string}
     * @memberof ContextResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof ContextResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ContextSetDefault200Response
 */
export interface ContextSetDefault200Response {
    /**
     * 
     * @type {ContextResource}
     * @memberof ContextSetDefault200Response
     */
    'data': ContextResource;
}
/**
 * 
 * @export
 * @interface ContextSetDefaultRequest
 */
export interface ContextSetDefaultRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ContextSetDefaultRequest
     */
    'is_default': boolean;
}
/**
 * 
 * @export
 * @interface ContextStoreRequest
 */
export interface ContextStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ContextStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ContextStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ContextStoreRequest
     */
    'is_default'?: boolean;
}
/**
 * 
 * @export
 * @interface CountryIndex200Response
 */
export interface CountryIndex200Response {
    /**
     * 
     * @type {Array<CountryResource>}
     * @memberof CountryIndex200Response
     */
    'data': Array<CountryResource>;
}
/**
 * 
 * @export
 * @interface CountryResource
 */
export interface CountryResource {
    /**
     * The unique identifier of the country (ISO 3166-1 alpha-3 code)
     * @type {string}
     * @memberof CountryResource
     */
    'id': string;
    /**
     * The name of the country, it shall only be used internally
     * @type {string}
     * @memberof CountryResource
     */
    'internal_name': string;
    /**
     * The legacy Id when this country corresponds to a legacy country from the MWNF3 database, nullable
     * @type {string}
     * @memberof CountryResource
     */
    'backward_compatibility': string | null;
    /**
     * Date of creation
     * @type {string}
     * @memberof CountryResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof CountryResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface CountryStore200Response
 */
export interface CountryStore200Response {
    /**
     * 
     * @type {CountryResource}
     * @memberof CountryStore200Response
     */
    'data': CountryResource;
}
/**
 * 
 * @export
 * @interface CountryStoreRequest
 */
export interface CountryStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof CountryStoreRequest
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CountryStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof CountryStoreRequest
     */
    'backward_compatibility'?: string | null;
}
/**
 * 
 * @export
 * @interface CountryUpdateRequest
 */
export interface CountryUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof CountryUpdateRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof CountryUpdateRequest
     */
    'backward_compatibility'?: string | null;
}
/**
 * 
 * @export
 * @interface DetailIndex200Response
 */
export interface DetailIndex200Response {
    /**
     * 
     * @type {Array<DetailResource>}
     * @memberof DetailIndex200Response
     */
    'data': Array<DetailResource>;
}
/**
 * 
 * @export
 * @interface DetailResource
 */
export interface DetailResource {
    /**
     * The unique identifier of the item (GUID)
     * @type {string}
     * @memberof DetailResource
     */
    'id': string;
    /**
     * The name of the item, it shall only be used internally
     * @type {string}
     * @memberof DetailResource
     */
    'internal_name': string;
    /**
     * The item this detail belongs to
     * @type {ItemResource}
     * @memberof DetailResource
     */
    'item'?: ItemResource;
    /**
     * The legacy Id when this item corresponds to a legacy item from the MWNF3 database, nullable
     * @type {string}
     * @memberof DetailResource
     */
    'backward_compatibility': string | null;
    /**
     * Translations for this detail (internationalization and contextualization)
     * @type {Array<DetailTranslationResource>}
     * @memberof DetailResource
     */
    'translations'?: Array<DetailTranslationResource>;
    /**
     * Date of creation
     * @type {string}
     * @memberof DetailResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof DetailResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface DetailStore200Response
 */
export interface DetailStore200Response {
    /**
     * 
     * @type {DetailResource}
     * @memberof DetailStore200Response
     */
    'data': DetailResource;
}
/**
 * 
 * @export
 * @interface DetailStoreRequest
 */
export interface DetailStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof DetailStoreRequest
     */
    'item_id': string;
    /**
     * 
     * @type {string}
     * @memberof DetailStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof DetailStoreRequest
     */
    'backward_compatibility'?: string | null;
}
/**
 * 
 * @export
 * @interface DetailTranslationResource
 */
export interface DetailTranslationResource {
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'detail_id': string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'context_id': string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'alternate_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'author_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'text_copy_editor_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'translator_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'translation_copy_editor_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'backward_compatibility': string | null;
    /**
     * 
     * @type {Array<any>}
     * @memberof DetailTranslationResource
     */
    'extra': Array<any> | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'updated_at': string | null;
    /**
     * Relationship data
     * @type {DetailResource}
     * @memberof DetailTranslationResource
     */
    'detail'?: DetailResource;
    /**
     * 
     * @type {LanguageResource}
     * @memberof DetailTranslationResource
     */
    'language'?: LanguageResource;
    /**
     * 
     * @type {ContextResource}
     * @memberof DetailTranslationResource
     */
    'context'?: ContextResource;
    /**
     * 
     * @type {AuthorResource}
     * @memberof DetailTranslationResource
     */
    'author'?: AuthorResource;
    /**
     * 
     * @type {AuthorResource}
     * @memberof DetailTranslationResource
     */
    'text_copy_editor'?: AuthorResource;
    /**
     * 
     * @type {AuthorResource}
     * @memberof DetailTranslationResource
     */
    'translator'?: AuthorResource;
    /**
     * 
     * @type {AuthorResource}
     * @memberof DetailTranslationResource
     */
    'translation_copy_editor'?: AuthorResource;
}
/**
 * 
 * @export
 * @interface DetailTranslationShow200Response
 */
export interface DetailTranslationShow200Response {
    /**
     * 
     * @type {DetailTranslationResource}
     * @memberof DetailTranslationShow200Response
     */
    'data': DetailTranslationResource;
}
/**
 * 
 * @export
 * @interface DetailTranslationStoreRequest
 */
export interface DetailTranslationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationStoreRequest
     */
    'detail_id': string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationStoreRequest
     */
    'context_id': string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationStoreRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationStoreRequest
     */
    'alternate_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationStoreRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationStoreRequest
     */
    'author_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationStoreRequest
     */
    'text_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationStoreRequest
     */
    'translator_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationStoreRequest
     */
    'translation_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof DetailTranslationStoreRequest
     */
    'extra'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface DetailTranslationUpdateRequest
 */
export interface DetailTranslationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationUpdateRequest
     */
    'detail_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationUpdateRequest
     */
    'context_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationUpdateRequest
     */
    'alternate_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationUpdateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationUpdateRequest
     */
    'author_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationUpdateRequest
     */
    'text_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationUpdateRequest
     */
    'translator_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationUpdateRequest
     */
    'translation_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationUpdateRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof DetailTranslationUpdateRequest
     */
    'extra'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface ExhibitionIndex200Response
 */
export interface ExhibitionIndex200Response {
    /**
     * 
     * @type {Array<ExhibitionResource>}
     * @memberof ExhibitionIndex200Response
     */
    'data': Array<ExhibitionResource>;
    /**
     * 
     * @type {ExhibitionIndex200ResponseMeta}
     * @memberof ExhibitionIndex200Response
     */
    'meta': ExhibitionIndex200ResponseMeta;
    /**
     * 
     * @type {ExhibitionIndex200ResponseLinks}
     * @memberof ExhibitionIndex200Response
     */
    'links': ExhibitionIndex200ResponseLinks;
}
/**
 * 
 * @export
 * @interface ExhibitionIndex200ResponseLinks
 */
export interface ExhibitionIndex200ResponseLinks {
    /**
     * 
     * @type {string}
     * @memberof ExhibitionIndex200ResponseLinks
     */
    'first': string | null;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionIndex200ResponseLinks
     */
    'last': string | null;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionIndex200ResponseLinks
     */
    'prev': string | null;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionIndex200ResponseLinks
     */
    'next': string | null;
}
/**
 * 
 * @export
 * @interface ExhibitionIndex200ResponseMeta
 */
export interface ExhibitionIndex200ResponseMeta {
    /**
     * 
     * @type {number}
     * @memberof ExhibitionIndex200ResponseMeta
     */
    'current_page': number;
    /**
     * 
     * @type {number}
     * @memberof ExhibitionIndex200ResponseMeta
     */
    'from': number | null;
    /**
     * 
     * @type {number}
     * @memberof ExhibitionIndex200ResponseMeta
     */
    'last_page': number;
    /**
     * Generated paginator links.
     * @type {Array<ExhibitionIndex200ResponseMetaLinksInner>}
     * @memberof ExhibitionIndex200ResponseMeta
     */
    'links': Array<ExhibitionIndex200ResponseMetaLinksInner>;
    /**
     * Base path for paginator generated URLs.
     * @type {string}
     * @memberof ExhibitionIndex200ResponseMeta
     */
    'path': string | null;
    /**
     * Number of items shown per page.
     * @type {number}
     * @memberof ExhibitionIndex200ResponseMeta
     */
    'per_page': number;
    /**
     * Number of the last item in the slice.
     * @type {number}
     * @memberof ExhibitionIndex200ResponseMeta
     */
    'to': number | null;
    /**
     * Total number of items being paginated.
     * @type {number}
     * @memberof ExhibitionIndex200ResponseMeta
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ExhibitionIndex200ResponseMetaLinksInner
 */
export interface ExhibitionIndex200ResponseMetaLinksInner {
    /**
     * 
     * @type {string}
     * @memberof ExhibitionIndex200ResponseMetaLinksInner
     */
    'url': string | null;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionIndex200ResponseMetaLinksInner
     */
    'label': string;
    /**
     * 
     * @type {boolean}
     * @memberof ExhibitionIndex200ResponseMetaLinksInner
     */
    'active': boolean;
}
/**
 * 
 * @export
 * @interface ExhibitionResource
 */
export interface ExhibitionResource {
    /**
     * 
     * @type {string}
     * @memberof ExhibitionResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionResource
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionResource
     */
    'backward_compatibility': string | null;
    /**
     * 
     * @type {Array<ExhibitionTranslationResource>}
     * @memberof ExhibitionResource
     */
    'translations'?: Array<ExhibitionTranslationResource>;
    /**
     * 
     * @type {Array<PartnerResource>}
     * @memberof ExhibitionResource
     */
    'partners'?: Array<PartnerResource>;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ExhibitionStore200Response
 */
export interface ExhibitionStore200Response {
    /**
     * 
     * @type {ExhibitionResource}
     * @memberof ExhibitionStore200Response
     */
    'data': ExhibitionResource;
}
/**
 * 
 * @export
 * @interface ExhibitionStoreRequest
 */
export interface ExhibitionStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ExhibitionStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionStoreRequest
     */
    'backward_compatibility'?: string | null;
}
/**
 * 
 * @export
 * @interface ExhibitionTranslationResource
 */
export interface ExhibitionTranslationResource {
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationResource
     */
    'exhibition_id': string;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationResource
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationResource
     */
    'context_id': string;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationResource
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationResource
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationResource
     */
    'url': string | null;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationResource
     */
    'backward_compatibility': string | null;
    /**
     * 
     * @type {Array<any>}
     * @memberof ExhibitionTranslationResource
     */
    'extra': Array<any> | null;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ExhibitionTranslationStore200Response
 */
export interface ExhibitionTranslationStore200Response {
    /**
     * 
     * @type {ExhibitionTranslationResource}
     * @memberof ExhibitionTranslationStore200Response
     */
    'data': ExhibitionTranslationResource;
}
/**
 * 
 * @export
 * @interface ExhibitionTranslationStoreRequest
 */
export interface ExhibitionTranslationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationStoreRequest
     */
    'exhibition_id': string;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationStoreRequest
     */
    'context_id': string;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationStoreRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationStoreRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationStoreRequest
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExhibitionTranslationStoreRequest
     */
    'extra'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface ExhibitionTranslationUpdateRequest
 */
export interface ExhibitionTranslationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationUpdateRequest
     */
    'exhibition_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationUpdateRequest
     */
    'context_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationUpdateRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationUpdateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationUpdateRequest
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionTranslationUpdateRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExhibitionTranslationUpdateRequest
     */
    'extra'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface ExhibitionUpdateRequest
 */
export interface ExhibitionUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ExhibitionUpdateRequest
     */
    'internal_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExhibitionUpdateRequest
     */
    'backward_compatibility'?: string | null;
}
/**
 * 
 * @export
 * @interface GalleryIndex200Response
 */
export interface GalleryIndex200Response {
    /**
     * 
     * @type {Array<GalleryResource>}
     * @memberof GalleryIndex200Response
     */
    'data': Array<GalleryResource>;
}
/**
 * 
 * @export
 * @interface GalleryResource
 */
export interface GalleryResource {
    /**
     * 
     * @type {string}
     * @memberof GalleryResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GalleryResource
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof GalleryResource
     */
    'backward_compatibility': string | null;
    /**
     * 
     * @type {string}
     * @memberof GalleryResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof GalleryResource
     */
    'updated_at': string | null;
    /**
     * Relationships
     * @type {Array<GalleryTranslationResource>}
     * @memberof GalleryResource
     */
    'translations'?: Array<GalleryTranslationResource>;
    /**
     * 
     * @type {Array<PartnerResource>}
     * @memberof GalleryResource
     */
    'partners'?: Array<PartnerResource>;
    /**
     * 
     * @type {Array<ItemResource>}
     * @memberof GalleryResource
     */
    'items'?: Array<ItemResource>;
    /**
     * 
     * @type {Array<DetailResource>}
     * @memberof GalleryResource
     */
    'details'?: Array<DetailResource>;
    /**
     * Computed attributes
     * @type {string}
     * @memberof GalleryResource
     */
    'items_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof GalleryResource
     */
    'details_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof GalleryResource
     */
    'total_content_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof GalleryResource
     */
    'partners_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof GalleryResource
     */
    'translations_count'?: string;
}
/**
 * 
 * @export
 * @interface GalleryStore200Response
 */
export interface GalleryStore200Response {
    /**
     * 
     * @type {GalleryResource}
     * @memberof GalleryStore200Response
     */
    'data': GalleryResource;
}
/**
 * 
 * @export
 * @interface GalleryStoreRequest
 */
export interface GalleryStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof GalleryStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof GalleryStoreRequest
     */
    'backward_compatibility'?: string | null;
}
/**
 * 
 * @export
 * @interface GalleryTranslationResource
 */
export interface GalleryTranslationResource {
    /**
     * 
     * @type {string}
     * @memberof GalleryTranslationResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GalleryTranslationResource
     */
    'gallery_id': string;
    /**
     * 
     * @type {string}
     * @memberof GalleryTranslationResource
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof GalleryTranslationResource
     */
    'context_id': string;
    /**
     * 
     * @type {string}
     * @memberof GalleryTranslationResource
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof GalleryTranslationResource
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof GalleryTranslationResource
     */
    'url': string | null;
    /**
     * 
     * @type {string}
     * @memberof GalleryTranslationResource
     */
    'backward_compatibility': string | null;
    /**
     * 
     * @type {Array<any>}
     * @memberof GalleryTranslationResource
     */
    'extra': Array<any> | null;
    /**
     * 
     * @type {string}
     * @memberof GalleryTranslationResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof GalleryTranslationResource
     */
    'updated_at': string | null;
    /**
     * Relationships
     * @type {GalleryResource}
     * @memberof GalleryTranslationResource
     */
    'gallery'?: GalleryResource;
    /**
     * 
     * @type {LanguageResource}
     * @memberof GalleryTranslationResource
     */
    'language'?: LanguageResource;
    /**
     * 
     * @type {ContextResource}
     * @memberof GalleryTranslationResource
     */
    'context'?: ContextResource;
}
/**
 * 
 * @export
 * @interface GalleryUpdateRequest
 */
export interface GalleryUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof GalleryUpdateRequest
     */
    'internal_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GalleryUpdateRequest
     */
    'backward_compatibility'?: string | null;
}
/**
 * 
 * @export
 * @interface ImageUploadIndex200Response
 */
export interface ImageUploadIndex200Response {
    /**
     * 
     * @type {Array<ImageUploadResource>}
     * @memberof ImageUploadIndex200Response
     */
    'data': Array<ImageUploadResource>;
}
/**
 * 
 * @export
 * @interface ImageUploadResource
 */
export interface ImageUploadResource {
    /**
     * The unique identifier of the picture (GUID)
     * @type {string}
     * @memberof ImageUploadResource
     */
    'id': string;
    /**
     * The path to the picture file
     * @type {string}
     * @memberof ImageUploadResource
     */
    'path': string | null;
    /**
     * The original name of the uploaded file
     * @type {string}
     * @memberof ImageUploadResource
     */
    'name': string | null;
    /**
     * The file extension of the uploaded file
     * @type {string}
     * @memberof ImageUploadResource
     */
    'extension': string | null;
    /**
     * The MIME type of the uploaded file
     * @type {string}
     * @memberof ImageUploadResource
     */
    'mime_type': string | null;
    /**
     * The size of the uploaded file in bytes
     * @type {number}
     * @memberof ImageUploadResource
     */
    'size': number | null;
    /**
     * Date of creation
     * @type {string}
     * @memberof ImageUploadResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof ImageUploadResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ImageUploadStatus200Response
 */
export interface ImageUploadStatus200Response {
    /**
     * 
     * @type {string}
     * @memberof ImageUploadStatus200Response
     */
    'status': ImageUploadStatus200ResponseStatusEnum;
    /**
     * 
     * @type {any}
     * @memberof ImageUploadStatus200Response
     */
    'available_image': any | null;
}

export const ImageUploadStatus200ResponseStatusEnum = {
    Processing: 'processing'
} as const;

export type ImageUploadStatus200ResponseStatusEnum = typeof ImageUploadStatus200ResponseStatusEnum[keyof typeof ImageUploadStatus200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface ImageUploadStatus200ResponseAnyOf
 */
export interface ImageUploadStatus200ResponseAnyOf {
    /**
     * 
     * @type {string}
     * @memberof ImageUploadStatus200ResponseAnyOf
     */
    'status': ImageUploadStatus200ResponseAnyOfStatusEnum;
    /**
     * 
     * @type {AvailableImageResource}
     * @memberof ImageUploadStatus200ResponseAnyOf
     */
    'available_image': AvailableImageResource;
}

export const ImageUploadStatus200ResponseAnyOfStatusEnum = {
    Processed: 'processed'
} as const;

export type ImageUploadStatus200ResponseAnyOfStatusEnum = typeof ImageUploadStatus200ResponseAnyOfStatusEnum[keyof typeof ImageUploadStatus200ResponseAnyOfStatusEnum];

/**
 * 
 * @export
 * @interface ImageUploadStatus200ResponseAnyOf1
 */
export interface ImageUploadStatus200ResponseAnyOf1 {
    /**
     * 
     * @type {string}
     * @memberof ImageUploadStatus200ResponseAnyOf1
     */
    'status': ImageUploadStatus200ResponseAnyOf1StatusEnum;
    /**
     * 
     * @type {any}
     * @memberof ImageUploadStatus200ResponseAnyOf1
     */
    'available_image': any | null;
}

export const ImageUploadStatus200ResponseAnyOf1StatusEnum = {
    Processing: 'processing'
} as const;

export type ImageUploadStatus200ResponseAnyOf1StatusEnum = typeof ImageUploadStatus200ResponseAnyOf1StatusEnum[keyof typeof ImageUploadStatus200ResponseAnyOf1StatusEnum];

/**
 * 
 * @export
 * @interface ImageUploadStatus404Response
 */
export interface ImageUploadStatus404Response {
    /**
     * 
     * @type {string}
     * @memberof ImageUploadStatus404Response
     */
    'status': ImageUploadStatus404ResponseStatusEnum;
    /**
     * 
     * @type {any}
     * @memberof ImageUploadStatus404Response
     */
    'available_image': any | null;
}

export const ImageUploadStatus404ResponseStatusEnum = {
    NotFound: 'not_found'
} as const;

export type ImageUploadStatus404ResponseStatusEnum = typeof ImageUploadStatus404ResponseStatusEnum[keyof typeof ImageUploadStatus404ResponseStatusEnum];

/**
 * 
 * @export
 * @interface ImageUploadStore200Response
 */
export interface ImageUploadStore200Response {
    /**
     * 
     * @type {ImageUploadResource}
     * @memberof ImageUploadStore200Response
     */
    'data': ImageUploadResource;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * Errors overview.
     * @type {string}
     * @memberof InlineObject
     */
    'message': string;
    /**
     * A detailed description of each field that failed validation.
     * @type {{ [key: string]: Array<string>; }}
     * @memberof InlineObject
     */
    'errors': { [key: string]: Array<string>; };
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * Error overview.
     * @type {string}
     * @memberof InlineObject1
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ItemIndex200Response
 */
export interface ItemIndex200Response {
    /**
     * 
     * @type {Array<ItemResource>}
     * @memberof ItemIndex200Response
     */
    'data': Array<ItemResource>;
}
/**
 * 
 * @export
 * @interface ItemResource
 */
export interface ItemResource {
    /**
     * The unique identifier of the item (GUID)
     * @type {string}
     * @memberof ItemResource
     */
    'id': string;
    /**
     * The name of the item, it shall only be used internally
     * @type {string}
     * @memberof ItemResource
     */
    'internal_name': string;
    /**
     * The legacy Id when this item corresponds to a legacy item from the MWNF3 database, nullable
     * @type {string}
     * @memberof ItemResource
     */
    'backward_compatibility': string | null;
    /**
     * The type of the item, either \'object\' or \'monument\'
     * @type {string}
     * @memberof ItemResource
     */
    'type': string;
    /**
     * Owner\'s reference number for the item
     * @type {string}
     * @memberof ItemResource
     */
    'owner_reference': string | null;
    /**
     * MWNF reference number for the item
     * @type {string}
     * @memberof ItemResource
     */
    'mwnf_reference': string | null;
    /**
     * The partner owning the item
     * @type {PartnerResource}
     * @memberof ItemResource
     */
    'partner'?: PartnerResource;
    /**
     * The project this item belongs to, nullable
     * @type {ProjectResource}
     * @memberof ItemResource
     */
    'project'?: ProjectResource;
    /**
     * The country this item is associated with, nullable
     * @type {CountryResource}
     * @memberof ItemResource
     */
    'country'?: CountryResource;
    /**
     * Artists associated with this item
     * @type {Array<ArtistResource>}
     * @memberof ItemResource
     */
    'artists': Array<ArtistResource>;
    /**
     * Workshops associated with this item
     * @type {Array<WorkshopResource>}
     * @memberof ItemResource
     */
    'workshops': Array<WorkshopResource>;
    /**
     * Tags associated with this item
     * @type {Array<TagResource>}
     * @memberof ItemResource
     */
    'tags'?: Array<TagResource>;
    /**
     * Translations for this item (internationalization and contextualization)
     * @type {Array<ItemTranslationResource>}
     * @memberof ItemResource
     */
    'translations'?: Array<ItemTranslationResource>;
    /**
     * Date of creation
     * @type {string}
     * @memberof ItemResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof ItemResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ItemStore200Response
 */
export interface ItemStore200Response {
    /**
     * 
     * @type {ItemResource}
     * @memberof ItemStore200Response
     */
    'data': ItemResource;
}
/**
 * 
 * @export
 * @interface ItemStoreRequest
 */
export interface ItemStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemStoreRequest
     */
    'partner_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ItemStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemStoreRequest
     */
    'type': ItemStoreRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ItemStoreRequest
     */
    'country_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemStoreRequest
     */
    'project_id'?: string | null;
}

export const ItemStoreRequestTypeEnum = {
    Object: 'object',
    Monument: 'monument'
} as const;

export type ItemStoreRequestTypeEnum = typeof ItemStoreRequestTypeEnum[keyof typeof ItemStoreRequestTypeEnum];

/**
 * 
 * @export
 * @interface ItemTranslationResource
 */
export interface ItemTranslationResource {
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'item_id': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'context_id': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'alternate_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'type': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'holder': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'owner': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'initial_owner': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'dates': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'location': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'dimensions': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'place_of_production': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'method_for_datation': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'method_for_provenance': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'obtention': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'bibliography': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'author_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'text_copy_editor_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'translator_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'translation_copy_editor_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'backward_compatibility': string | null;
    /**
     * 
     * @type {Array<any>}
     * @memberof ItemTranslationResource
     */
    'extra': Array<any> | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'updated_at': string | null;
    /**
     * Relationship data
     * @type {ItemResource}
     * @memberof ItemTranslationResource
     */
    'item'?: ItemResource;
    /**
     * 
     * @type {LanguageResource}
     * @memberof ItemTranslationResource
     */
    'language'?: LanguageResource;
    /**
     * 
     * @type {ContextResource}
     * @memberof ItemTranslationResource
     */
    'context'?: ContextResource;
    /**
     * 
     * @type {AuthorResource}
     * @memberof ItemTranslationResource
     */
    'author'?: AuthorResource;
    /**
     * 
     * @type {AuthorResource}
     * @memberof ItemTranslationResource
     */
    'text_copy_editor'?: AuthorResource;
    /**
     * 
     * @type {AuthorResource}
     * @memberof ItemTranslationResource
     */
    'translator'?: AuthorResource;
    /**
     * 
     * @type {AuthorResource}
     * @memberof ItemTranslationResource
     */
    'translation_copy_editor'?: AuthorResource;
}
/**
 * 
 * @export
 * @interface ItemTranslationShow200Response
 */
export interface ItemTranslationShow200Response {
    /**
     * 
     * @type {ItemTranslationResource}
     * @memberof ItemTranslationShow200Response
     */
    'data': ItemTranslationResource;
}
/**
 * 
 * @export
 * @interface ItemTranslationStoreRequest
 */
export interface ItemTranslationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'item_id': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'context_id': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'alternate_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'holder'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'owner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'initial_owner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'dates'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'location'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'dimensions'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'place_of_production'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'method_for_datation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'method_for_provenance'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'obtention'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'bibliography'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'author_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'text_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'translator_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'translation_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemTranslationStoreRequest
     */
    'extra'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface ItemTranslationUpdateRequest
 */
export interface ItemTranslationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'item_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'context_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'alternate_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'holder'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'owner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'initial_owner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'dates'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'location'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'dimensions'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'place_of_production'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'method_for_datation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'method_for_provenance'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'obtention'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'bibliography'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'author_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'text_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'translator_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'translation_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemTranslationUpdateRequest
     */
    'extra'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface ItemUpdateTagsRequest
 */
export interface ItemUpdateTagsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemUpdateTagsRequest
     */
    'attach'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemUpdateTagsRequest
     */
    'detach'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ItemWithAllTagsRequest
 */
export interface ItemWithAllTagsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemWithAllTagsRequest
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface LanguageGetDefault404Response
 */
export interface LanguageGetDefault404Response {
    /**
     * 
     * @type {string}
     * @memberof LanguageGetDefault404Response
     */
    'message': LanguageGetDefault404ResponseMessageEnum;
}

export const LanguageGetDefault404ResponseMessageEnum = {
    NoDefaultLanguageFound: 'No default language found'
} as const;

export type LanguageGetDefault404ResponseMessageEnum = typeof LanguageGetDefault404ResponseMessageEnum[keyof typeof LanguageGetDefault404ResponseMessageEnum];

/**
 * 
 * @export
 * @interface LanguageGetEnglish404Response
 */
export interface LanguageGetEnglish404Response {
    /**
     * 
     * @type {string}
     * @memberof LanguageGetEnglish404Response
     */
    'message': LanguageGetEnglish404ResponseMessageEnum;
}

export const LanguageGetEnglish404ResponseMessageEnum = {
    NoEnglishLanguageFound: 'No English language found'
} as const;

export type LanguageGetEnglish404ResponseMessageEnum = typeof LanguageGetEnglish404ResponseMessageEnum[keyof typeof LanguageGetEnglish404ResponseMessageEnum];

/**
 * 
 * @export
 * @interface LanguageIndex200Response
 */
export interface LanguageIndex200Response {
    /**
     * 
     * @type {Array<LanguageResource>}
     * @memberof LanguageIndex200Response
     */
    'data': Array<LanguageResource>;
}
/**
 * 
 * @export
 * @interface LanguageResource
 */
export interface LanguageResource {
    /**
     * The unique identifier of the language (ISO 639-1 code)
     * @type {string}
     * @memberof LanguageResource
     */
    'id': string;
    /**
     * The name of the language, it shall only be used internally
     * @type {string}
     * @memberof LanguageResource
     */
    'internal_name': string;
    /**
     * The legacy Id when this language corresponds to a legacy language from the MWNF3 database, nullable
     * @type {string}
     * @memberof LanguageResource
     */
    'backward_compatibility': string | null;
    /**
     * Indicates if this language is the default one. There is one single default language for the entire database.
     * @type {boolean}
     * @memberof LanguageResource
     */
    'is_default': boolean;
    /**
     * Date of creation
     * @type {string}
     * @memberof LanguageResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof LanguageResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface LanguageSetDefault200Response
 */
export interface LanguageSetDefault200Response {
    /**
     * 
     * @type {LanguageResource}
     * @memberof LanguageSetDefault200Response
     */
    'data': LanguageResource;
}
/**
 * 
 * @export
 * @interface LanguageStoreRequest
 */
export interface LanguageStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof LanguageStoreRequest
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LanguageStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof LanguageStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof LanguageStoreRequest
     */
    'is_default'?: boolean;
}
/**
 * 
 * @export
 * @interface LanguageUpdateRequest
 */
export interface LanguageUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof LanguageUpdateRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof LanguageUpdateRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof LanguageUpdateRequest
     */
    'is_default'?: boolean;
}
/**
 * 
 * @export
 * @interface LocationIndex200Response
 */
export interface LocationIndex200Response {
    /**
     * 
     * @type {Array<LocationResource>}
     * @memberof LocationIndex200Response
     */
    'data': Array<LocationResource>;
}
/**
 * 
 * @export
 * @interface LocationResource
 */
export interface LocationResource {
    /**
     * 
     * @type {string}
     * @memberof LocationResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LocationResource
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof LocationResource
     */
    'country_id': string;
    /**
     * 
     * @type {Array<LocationTranslationResource>}
     * @memberof LocationResource
     */
    'translations'?: Array<LocationTranslationResource>;
    /**
     * 
     * @type {string}
     * @memberof LocationResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof LocationResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface LocationStore201Response
 */
export interface LocationStore201Response {
    /**
     * 
     * @type {LocationResource}
     * @memberof LocationStore201Response
     */
    'data': LocationResource;
}
/**
 * 
 * @export
 * @interface LocationStoreRequest
 */
export interface LocationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof LocationStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {number}
     * @memberof LocationStoreRequest
     */
    'country_id': number;
    /**
     * 
     * @type {Array<LocationStoreRequestTranslationsInner>}
     * @memberof LocationStoreRequest
     */
    'translations': Array<LocationStoreRequestTranslationsInner>;
}
/**
 * 
 * @export
 * @interface LocationStoreRequestTranslationsInner
 */
export interface LocationStoreRequestTranslationsInner {
    /**
     * 
     * @type {number}
     * @memberof LocationStoreRequestTranslationsInner
     */
    'language_id': number;
    /**
     * 
     * @type {string}
     * @memberof LocationStoreRequestTranslationsInner
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface LocationTranslationIndex200Response
 */
export interface LocationTranslationIndex200Response {
    /**
     * 
     * @type {Array<LocationTranslationResource>}
     * @memberof LocationTranslationIndex200Response
     */
    'data': Array<LocationTranslationResource>;
}
/**
 * 
 * @export
 * @interface LocationTranslationResource
 */
export interface LocationTranslationResource {
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationResource
     */
    'location_id': string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationResource
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationResource
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface LocationTranslationStore200Response
 */
export interface LocationTranslationStore200Response {
    /**
     * 
     * @type {LocationTranslationResource}
     * @memberof LocationTranslationStore200Response
     */
    'data': LocationTranslationResource;
}
/**
 * 
 * @export
 * @interface LocationTranslationStoreRequest
 */
export interface LocationTranslationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationStoreRequest
     */
    'location_id': string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationStoreRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationStoreRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface LocationTranslationUpdateRequest
 */
export interface LocationTranslationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationUpdateRequest
     */
    'location_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationUpdateRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface LocationUpdateRequest
 */
export interface LocationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof LocationUpdateRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {number}
     * @memberof LocationUpdateRequest
     */
    'country_id': number;
    /**
     * 
     * @type {Array<LocationUpdateRequestTranslationsInner>}
     * @memberof LocationUpdateRequest
     */
    'translations'?: Array<LocationUpdateRequestTranslationsInner>;
}
/**
 * 
 * @export
 * @interface LocationUpdateRequestTranslationsInner
 */
export interface LocationUpdateRequestTranslationsInner {
    /**
     * 
     * @type {number}
     * @memberof LocationUpdateRequestTranslationsInner
     */
    'language_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof LocationUpdateRequestTranslationsInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface MarkdownFromHtmlRequest
 */
export interface MarkdownFromHtmlRequest {
    /**
     * 
     * @type {string}
     * @memberof MarkdownFromHtmlRequest
     */
    'html': string;
}
/**
 * 
 * @export
 * @interface MarkdownIsMarkdownRequest
 */
export interface MarkdownIsMarkdownRequest {
    /**
     * 
     * @type {string}
     * @memberof MarkdownIsMarkdownRequest
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface MarkdownPreview200Response
 */
export interface MarkdownPreview200Response {
    /**
     * 
     * @type {boolean}
     * @memberof MarkdownPreview200Response
     */
    'success': boolean;
    /**
     * 
     * @type {MarkdownPreview200ResponseData}
     * @memberof MarkdownPreview200Response
     */
    'data': MarkdownPreview200ResponseData;
}
/**
 * 
 * @export
 * @interface MarkdownPreview200ResponseData
 */
export interface MarkdownPreview200ResponseData {
    /**
     * 
     * @type {string}
     * @memberof MarkdownPreview200ResponseData
     */
    'html': string;
}
/**
 * 
 * @export
 * @interface MarkdownPreview422Response
 */
export interface MarkdownPreview422Response {
    /**
     * 
     * @type {boolean}
     * @memberof MarkdownPreview422Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof MarkdownPreview422Response
     */
    'message': MarkdownPreview422ResponseMessageEnum;
    /**
     * 
     * @type {string}
     * @memberof MarkdownPreview422Response
     */
    'errors': string;
}

export const MarkdownPreview422ResponseMessageEnum = {
    ValidationFailed: 'Validation failed'
} as const;

export type MarkdownPreview422ResponseMessageEnum = typeof MarkdownPreview422ResponseMessageEnum[keyof typeof MarkdownPreview422ResponseMessageEnum];

/**
 * 
 * @export
 * @interface MarkdownPreview500Response
 */
export interface MarkdownPreview500Response {
    /**
     * 
     * @type {boolean}
     * @memberof MarkdownPreview500Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof MarkdownPreview500Response
     */
    'message': MarkdownPreview500ResponseMessageEnum;
    /**
     * 
     * @type {string}
     * @memberof MarkdownPreview500Response
     */
    'error': string;
}

export const MarkdownPreview500ResponseMessageEnum = {
    FailedToConvertMarkdownToHtml: 'Failed to convert markdown to HTML'
} as const;

export type MarkdownPreview500ResponseMessageEnum = typeof MarkdownPreview500ResponseMessageEnum[keyof typeof MarkdownPreview500ResponseMessageEnum];

/**
 * 
 * @export
 * @interface MarkdownToHtmlRequest
 */
export interface MarkdownToHtmlRequest {
    /**
     * 
     * @type {string}
     * @memberof MarkdownToHtmlRequest
     */
    'markdown': string;
}
/**
 * 
 * @export
 * @interface PartnerIndex200Response
 */
export interface PartnerIndex200Response {
    /**
     * 
     * @type {Array<PartnerResource>}
     * @memberof PartnerIndex200Response
     */
    'data': Array<PartnerResource>;
}
/**
 * 
 * @export
 * @interface PartnerResource
 */
export interface PartnerResource {
    /**
     * The unique identifier of the partner (GUID)
     * @type {string}
     * @memberof PartnerResource
     */
    'id': string;
    /**
     * The name of the partner, it shall only be used internally
     * @type {string}
     * @memberof PartnerResource
     */
    'internal_name': string;
    /**
     * The legacy Id when this partner corresponds to a legacy partner from the MWNF3 database, nullable
     * @type {string}
     * @memberof PartnerResource
     */
    'backward_compatibility': string | null;
    /**
     * The type of the partner, either \'museum\',  \'institution\' or \'individual\'
     * @type {string}
     * @memberof PartnerResource
     */
    'type': string;
    /**
     * The country this partner is associated with, nullable
     * @type {CountryResource}
     * @memberof PartnerResource
     */
    'country'?: CountryResource;
    /**
     * Date of creation
     * @type {string}
     * @memberof PartnerResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof PartnerResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface PartnerStore200Response
 */
export interface PartnerStore200Response {
    /**
     * 
     * @type {PartnerResource}
     * @memberof PartnerStore200Response
     */
    'data': PartnerResource;
}
/**
 * 
 * @export
 * @interface PartnerStoreRequest
 */
export interface PartnerStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof PartnerStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof PartnerStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartnerStoreRequest
     */
    'type': PartnerStoreRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PartnerStoreRequest
     */
    'country_id'?: string | null;
}

export const PartnerStoreRequestTypeEnum = {
    Museum: 'museum',
    Institution: 'institution',
    Individual: 'individual'
} as const;

export type PartnerStoreRequestTypeEnum = typeof PartnerStoreRequestTypeEnum[keyof typeof PartnerStoreRequestTypeEnum];

/**
 * 
 * @export
 * @interface PictureDetachFromItem422Response
 */
export interface PictureDetachFromItem422Response {
    /**
     * 
     * @type {string}
     * @memberof PictureDetachFromItem422Response
     */
    'error': PictureDetachFromItem422ResponseErrorEnum;
}

export const PictureDetachFromItem422ResponseErrorEnum = {
    PictureDoesNotBelongToThisModel: 'Picture does not belong to this model'
} as const;

export type PictureDetachFromItem422ResponseErrorEnum = typeof PictureDetachFromItem422ResponseErrorEnum[keyof typeof PictureDetachFromItem422ResponseErrorEnum];

/**
 * 
 * @export
 * @interface PictureIndex200Response
 */
export interface PictureIndex200Response {
    /**
     * 
     * @type {Array<PictureResource>}
     * @memberof PictureIndex200Response
     */
    'data': Array<PictureResource>;
}
/**
 * 
 * @export
 * @interface PictureResource
 */
export interface PictureResource {
    /**
     * The unique identifier of the picture (UUID)
     * @type {string}
     * @memberof PictureResource
     */
    'id': string;
    /**
     * The internal name of the picture
     * @type {string}
     * @memberof PictureResource
     */
    'internal_name': string;
    /**
     * The legacy ID when this picture corresponds to a legacy image from the MWNF3 database, nullable
     * @type {string}
     * @memberof PictureResource
     */
    'backward_compatibility': string | null;
    /**
     * The path to the picture file
     * @type {string}
     * @memberof PictureResource
     */
    'path': string;
    /**
     * The copyright text associated with the picture
     * @type {string}
     * @memberof PictureResource
     */
    'copyright_text': string | null;
    /**
     * The URL for the copyright information
     * @type {string}
     * @memberof PictureResource
     */
    'copyright_url': string | null;
    /**
     * The original name of the uploaded file
     * @type {string}
     * @memberof PictureResource
     */
    'upload_name': string;
    /**
     * The file extension of the uploaded file
     * @type {string}
     * @memberof PictureResource
     */
    'upload_extension': string;
    /**
     * The MIME type of the uploaded file
     * @type {string}
     * @memberof PictureResource
     */
    'upload_mime_type': string;
    /**
     * The size of the uploaded file in bytes
     * @type {number}
     * @memberof PictureResource
     */
    'upload_size': number;
    /**
     * The type of the parent model (Item, Detail, Partner)
     * @type {string}
     * @memberof PictureResource
     */
    'pictureable_type': string;
    /**
     * The ID of the parent model
     * @type {string}
     * @memberof PictureResource
     */
    'pictureable_id': string;
    /**
     * Date of creation
     * @type {string}
     * @memberof PictureResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof PictureResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface PictureShow200Response
 */
export interface PictureShow200Response {
    /**
     * 
     * @type {PictureResource}
     * @memberof PictureShow200Response
     */
    'data': PictureResource;
}
/**
 * 
 * @export
 * @interface PictureTranslationIndex200Response
 */
export interface PictureTranslationIndex200Response {
    /**
     * 
     * @type {Array<PictureTranslationResource>}
     * @memberof PictureTranslationIndex200Response
     */
    'data': Array<PictureTranslationResource>;
    /**
     * 
     * @type {ExhibitionIndex200ResponseMeta}
     * @memberof PictureTranslationIndex200Response
     */
    'meta': ExhibitionIndex200ResponseMeta;
    /**
     * 
     * @type {ExhibitionIndex200ResponseLinks}
     * @memberof PictureTranslationIndex200Response
     */
    'links': ExhibitionIndex200ResponseLinks;
}
/**
 * 
 * @export
 * @interface PictureTranslationResource
 */
export interface PictureTranslationResource {
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationResource
     */
    'picture_id': string;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationResource
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationResource
     */
    'context_id': string;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationResource
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationResource
     */
    'caption': string;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationResource
     */
    'author_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationResource
     */
    'text_copy_editor_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationResource
     */
    'translator_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationResource
     */
    'translation_copy_editor_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationResource
     */
    'backward_compatibility': string | null;
    /**
     * 
     * @type {Array<any>}
     * @memberof PictureTranslationResource
     */
    'extra': Array<any> | null;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface PictureTranslationStore200Response
 */
export interface PictureTranslationStore200Response {
    /**
     * 
     * @type {PictureTranslationResource}
     * @memberof PictureTranslationStore200Response
     */
    'data': PictureTranslationResource;
}
/**
 * 
 * @export
 * @interface PictureTranslationStoreRequest
 */
export interface PictureTranslationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationStoreRequest
     */
    'picture_id': string;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationStoreRequest
     */
    'context_id': string;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationStoreRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationStoreRequest
     */
    'caption': string;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationStoreRequest
     */
    'author_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationStoreRequest
     */
    'text_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationStoreRequest
     */
    'translator_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationStoreRequest
     */
    'translation_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PictureTranslationStoreRequest
     */
    'extra'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface PictureTranslationUpdateRequest
 */
export interface PictureTranslationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationUpdateRequest
     */
    'picture_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationUpdateRequest
     */
    'context_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationUpdateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationUpdateRequest
     */
    'caption'?: string;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationUpdateRequest
     */
    'author_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationUpdateRequest
     */
    'text_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationUpdateRequest
     */
    'translator_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationUpdateRequest
     */
    'translation_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PictureTranslationUpdateRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PictureTranslationUpdateRequest
     */
    'extra'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface PictureUpdateRequest
 */
export interface PictureUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof PictureUpdateRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof PictureUpdateRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PictureUpdateRequest
     */
    'copyright_text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PictureUpdateRequest
     */
    'copyright_url'?: string | null;
}
/**
 * 
 * @export
 * @interface ProjectEnabled200Response
 */
export interface ProjectEnabled200Response {
    /**
     * 
     * @type {Array<ProjectResource>}
     * @memberof ProjectEnabled200Response
     */
    'data': Array<ProjectResource>;
}
/**
 * 
 * @export
 * @interface ProjectResource
 */
export interface ProjectResource {
    /**
     * The unique identifier of the project (GUID)
     * @type {string}
     * @memberof ProjectResource
     */
    'id': string;
    /**
     * The name of the project, it shall only be used internally
     * @type {string}
     * @memberof ProjectResource
     */
    'internal_name': string;
    /**
     * The legacy Id when this project corresponds to a legacy project from the MWNF3 database, nullable
     * @type {string}
     * @memberof ProjectResource
     */
    'backward_compatibility': string | null;
    /**
     * Launch date of the project, nullable
     * @type {string}
     * @memberof ProjectResource
     */
    'launch_date': string | null;
    /**
     * Indicates if the project has been launched already
     * @type {boolean}
     * @memberof ProjectResource
     */
    'is_launched': boolean;
    /**
     * Indicates if the project is enabled (active)
     * @type {boolean}
     * @memberof ProjectResource
     */
    'is_enabled': boolean;
    /**
     * The default context used within the project
     * @type {ContextResource}
     * @memberof ProjectResource
     */
    'context'?: ContextResource;
    /**
     * The default language used within the project
     * @type {LanguageResource}
     * @memberof ProjectResource
     */
    'language'?: LanguageResource;
    /**
     * Date of creation
     * @type {string}
     * @memberof ProjectResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof ProjectResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ProjectSetEnabledRequest
 */
export interface ProjectSetEnabledRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ProjectSetEnabledRequest
     */
    'is_enabled': boolean;
}
/**
 * 
 * @export
 * @interface ProjectSetLaunched200Response
 */
export interface ProjectSetLaunched200Response {
    /**
     * 
     * @type {ProjectResource}
     * @memberof ProjectSetLaunched200Response
     */
    'data': ProjectResource;
}
/**
 * 
 * @export
 * @interface ProjectSetLaunchedRequest
 */
export interface ProjectSetLaunchedRequest {
    /**
     * 
     * @type {string}
     * @memberof ProjectSetLaunchedRequest
     */
    'launch_date'?: string | null;
}
/**
 * 
 * @export
 * @interface ProjectStoreRequest
 */
export interface ProjectStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ProjectStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProjectStoreRequest
     */
    'launch_date'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectStoreRequest
     */
    'is_launched'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectStoreRequest
     */
    'is_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectStoreRequest
     */
    'context_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProjectStoreRequest
     */
    'language_id'?: string | null;
}
/**
 * 
 * @export
 * @interface ProvinceIndex200Response
 */
export interface ProvinceIndex200Response {
    /**
     * 
     * @type {Array<ProvinceResource>}
     * @memberof ProvinceIndex200Response
     */
    'data': Array<ProvinceResource>;
}
/**
 * 
 * @export
 * @interface ProvinceResource
 */
export interface ProvinceResource {
    /**
     * 
     * @type {string}
     * @memberof ProvinceResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceResource
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceResource
     */
    'country_id': string;
    /**
     * 
     * @type {Array<ProvinceTranslationResource>}
     * @memberof ProvinceResource
     */
    'translations'?: Array<ProvinceTranslationResource>;
    /**
     * 
     * @type {string}
     * @memberof ProvinceResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof ProvinceResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ProvinceStore201Response
 */
export interface ProvinceStore201Response {
    /**
     * 
     * @type {ProvinceResource}
     * @memberof ProvinceStore201Response
     */
    'data': ProvinceResource;
}
/**
 * 
 * @export
 * @interface ProvinceTranslationIndex200Response
 */
export interface ProvinceTranslationIndex200Response {
    /**
     * 
     * @type {Array<ProvinceTranslationResource>}
     * @memberof ProvinceTranslationIndex200Response
     */
    'data': Array<ProvinceTranslationResource>;
}
/**
 * 
 * @export
 * @interface ProvinceTranslationResource
 */
export interface ProvinceTranslationResource {
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationResource
     */
    'province_id': string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationResource
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationResource
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ProvinceTranslationStore200Response
 */
export interface ProvinceTranslationStore200Response {
    /**
     * 
     * @type {ProvinceTranslationResource}
     * @memberof ProvinceTranslationStore200Response
     */
    'data': ProvinceTranslationResource;
}
/**
 * 
 * @export
 * @interface ProvinceTranslationStoreRequest
 */
export interface ProvinceTranslationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationStoreRequest
     */
    'province_id': string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationStoreRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationStoreRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface ProvinceTranslationUpdateRequest
 */
export interface ProvinceTranslationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationUpdateRequest
     */
    'province_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationUpdateRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface TagIndex200Response
 */
export interface TagIndex200Response {
    /**
     * 
     * @type {Array<TagResource>}
     * @memberof TagIndex200Response
     */
    'data': Array<TagResource>;
}
/**
 * 
 * @export
 * @interface TagResource
 */
export interface TagResource {
    /**
     * The unique identifier of the tag (GUID)
     * @type {string}
     * @memberof TagResource
     */
    'id': string;
    /**
     * The name of the tag, it shall only be used internally
     * @type {string}
     * @memberof TagResource
     */
    'internal_name': string;
    /**
     * The legacy Id when this tag corresponds to a legacy tag from the previous database, nullable
     * @type {string}
     * @memberof TagResource
     */
    'backward_compatibility': string | null;
    /**
     * The description of the tag
     * @type {string}
     * @memberof TagResource
     */
    'description': string;
    /**
     * Date of creation
     * @type {string}
     * @memberof TagResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof TagResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface TagStore200Response
 */
export interface TagStore200Response {
    /**
     * 
     * @type {TagResource}
     * @memberof TagStore200Response
     */
    'data': TagResource;
}
/**
 * 
 * @export
 * @interface TagStoreRequest
 */
export interface TagStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof TagStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof TagStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TagStoreRequest
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface ThemeIndex200Response
 */
export interface ThemeIndex200Response {
    /**
     * 
     * @type {Array<ThemeResource>}
     * @memberof ThemeIndex200Response
     */
    'data': Array<ThemeResource>;
    /**
     * 
     * @type {ExhibitionIndex200ResponseMeta}
     * @memberof ThemeIndex200Response
     */
    'meta': ExhibitionIndex200ResponseMeta;
    /**
     * 
     * @type {ExhibitionIndex200ResponseLinks}
     * @memberof ThemeIndex200Response
     */
    'links': ExhibitionIndex200ResponseLinks;
}
/**
 * 
 * @export
 * @interface ThemeResource
 */
export interface ThemeResource {
    /**
     * 
     * @type {string}
     * @memberof ThemeResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeResource
     */
    'exhibition_id': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeResource
     */
    'parent_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ThemeResource
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeResource
     */
    'backward_compatibility': string | null;
    /**
     * 
     * @type {Array<ThemeTranslationResource>}
     * @memberof ThemeResource
     */
    'translations'?: Array<ThemeTranslationResource>;
    /**
     * 
     * @type {Array<ThemeResource>}
     * @memberof ThemeResource
     */
    'subthemes'?: Array<ThemeResource>;
    /**
     * 
     * @type {string}
     * @memberof ThemeResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof ThemeResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ThemeStore200Response
 */
export interface ThemeStore200Response {
    /**
     * 
     * @type {ThemeResource}
     * @memberof ThemeStore200Response
     */
    'data': ThemeResource;
}
/**
 * 
 * @export
 * @interface ThemeStoreRequest
 */
export interface ThemeStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ThemeStoreRequest
     */
    'exhibition_id': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeStoreRequest
     */
    'parent_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ThemeStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeStoreRequest
     */
    'backward_compatibility'?: string | null;
}
/**
 * 
 * @export
 * @interface ThemeTranslationResource
 */
export interface ThemeTranslationResource {
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationResource
     */
    'theme_id': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationResource
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationResource
     */
    'context_id': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationResource
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationResource
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationResource
     */
    'introduction': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationResource
     */
    'backward_compatibility': string | null;
    /**
     * 
     * @type {Array<any>}
     * @memberof ThemeTranslationResource
     */
    'extra': Array<any> | null;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ThemeTranslationStore200Response
 */
export interface ThemeTranslationStore200Response {
    /**
     * 
     * @type {ThemeTranslationResource}
     * @memberof ThemeTranslationStore200Response
     */
    'data': ThemeTranslationResource;
}
/**
 * 
 * @export
 * @interface ThemeTranslationStoreRequest
 */
export interface ThemeTranslationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationStoreRequest
     */
    'theme_id': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationStoreRequest
     */
    'context_id': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationStoreRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationStoreRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationStoreRequest
     */
    'introduction': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ThemeTranslationStoreRequest
     */
    'extra'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface ThemeTranslationUpdateRequest
 */
export interface ThemeTranslationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationUpdateRequest
     */
    'theme_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationUpdateRequest
     */
    'context_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationUpdateRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationUpdateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationUpdateRequest
     */
    'introduction'?: string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationUpdateRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ThemeTranslationUpdateRequest
     */
    'extra'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface TokenAcquireRequest
 */
export interface TokenAcquireRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenAcquireRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TokenAcquireRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof TokenAcquireRequest
     */
    'device_name': string;
    /**
     * 
     * @type {boolean}
     * @memberof TokenAcquireRequest
     */
    'wipe_tokens'?: boolean;
}
/**
 * 
 * @export
 * @interface WorkshopResource
 */
export interface WorkshopResource {
    /**
     * 
     * @type {string}
     * @memberof WorkshopResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopResource
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopResource
     */
    'backward_compatibility': string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkshopResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkshopResource
     */
    'updated_at': string | null;
    /**
     * 
     * @type {Array<ItemResource>}
     * @memberof WorkshopResource
     */
    'items'?: Array<ItemResource>;
}

/**
 * AddressApi - axios parameter creator
 * @export
 */
export const AddressApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified address
         * @param {string} address The address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressDestroy: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addressDestroy', 'address', address)
            const localVarPath = `/address/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified address
         * @param {string} address The address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressShow: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addressShow', 'address', address)
            const localVarPath = `/address/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created address
         * @param {AddressStoreRequest} addressStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressStore: async (addressStoreRequest: AddressStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressStoreRequest' is not null or undefined
            assertParamExists('addressStore', 'addressStoreRequest', addressStoreRequest)
            const localVarPath = `/address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified address
         * @param {string} address The address ID
         * @param {AddressUpdateRequest} addressUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUpdate: async (address: string, addressUpdateRequest: AddressUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addressUpdate', 'address', address)
            // verify required parameter 'addressUpdateRequest' is not null or undefined
            assertParamExists('addressUpdate', 'addressUpdateRequest', addressUpdateRequest)
            const localVarPath = `/address/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressApi - functional programming interface
 * @export
 */
export const AddressApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified address
         * @param {string} address The address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressDestroy(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressDestroy(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.addressDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.addressIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified address
         * @param {string} address The address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressShow(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressShow(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.addressShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created address
         * @param {AddressStoreRequest} addressStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressStore(addressStoreRequest: AddressStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressStore(addressStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.addressStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified address
         * @param {string} address The address ID
         * @param {AddressUpdateRequest} addressUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressUpdate(address: string, addressUpdateRequest: AddressUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressUpdate(address, addressUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.addressUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AddressApi - factory interface
 * @export
 */
export const AddressApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified address
         * @param {string} address The address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressDestroy(address: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addressDestroy(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressIndex(options?: RawAxiosRequestConfig): AxiosPromise<AddressIndex200Response> {
            return localVarFp.addressIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified address
         * @param {string} address The address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressShow(address: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressStore201Response> {
            return localVarFp.addressShow(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created address
         * @param {AddressStoreRequest} addressStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressStore(addressStoreRequest: AddressStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddressStore201Response> {
            return localVarFp.addressStore(addressStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified address
         * @param {string} address The address ID
         * @param {AddressUpdateRequest} addressUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUpdate(address: string, addressUpdateRequest: AddressUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddressStore201Response> {
            return localVarFp.addressUpdate(address, addressUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressApi - object-oriented interface
 * @export
 * @class AddressApi
 * @extends {BaseAPI}
 */
export class AddressApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified address
     * @param {string} address The address ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressDestroy(address: string, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).addressDestroy(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressIndex(options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).addressIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified address
     * @param {string} address The address ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressShow(address: string, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).addressShow(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created address
     * @param {AddressStoreRequest} addressStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressStore(addressStoreRequest: AddressStoreRequest, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).addressStore(addressStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified address
     * @param {string} address The address ID
     * @param {AddressUpdateRequest} addressUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressUpdate(address: string, addressUpdateRequest: AddressUpdateRequest, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).addressUpdate(address, addressUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AddressTranslationApi - axios parameter creator
 * @export
 */
export const AddressTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationDestroy: async (addressTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressTranslation' is not null or undefined
            assertParamExists('addressTranslationDestroy', 'addressTranslation', addressTranslation)
            const localVarPath = `/address-translation/{addressTranslation}`
                .replace(`{${"addressTranslation"}}`, encodeURIComponent(String(addressTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/address-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationShow: async (addressTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressTranslation' is not null or undefined
            assertParamExists('addressTranslationShow', 'addressTranslation', addressTranslation)
            const localVarPath = `/address-translation/{addressTranslation}`
                .replace(`{${"addressTranslation"}}`, encodeURIComponent(String(addressTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {AddressTranslationStoreRequest} addressTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationStore: async (addressTranslationStoreRequest: AddressTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressTranslationStoreRequest' is not null or undefined
            assertParamExists('addressTranslationStore', 'addressTranslationStoreRequest', addressTranslationStoreRequest)
            const localVarPath = `/address-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} addressTranslation The address translation ID
         * @param {AddressTranslationUpdateRequest} [addressTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationUpdate: async (addressTranslation: string, addressTranslationUpdateRequest?: AddressTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressTranslation' is not null or undefined
            assertParamExists('addressTranslationUpdate', 'addressTranslation', addressTranslation)
            const localVarPath = `/address-translation/{addressTranslation}`
                .replace(`{${"addressTranslation"}}`, encodeURIComponent(String(addressTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressTranslationApi - functional programming interface
 * @export
 */
export const AddressTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressTranslationDestroy(addressTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressTranslationDestroy(addressTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressTranslationApi.addressTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressTranslationApi.addressTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressTranslationShow(addressTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressTranslationShow(addressTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressTranslationApi.addressTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {AddressTranslationStoreRequest} addressTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressTranslationStore(addressTranslationStoreRequest: AddressTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressTranslationStore(addressTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressTranslationApi.addressTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} addressTranslation The address translation ID
         * @param {AddressTranslationUpdateRequest} [addressTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressTranslationUpdate(addressTranslation: string, addressTranslationUpdateRequest?: AddressTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressTranslationUpdate(addressTranslation, addressTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressTranslationApi.addressTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AddressTranslationApi - factory interface
 * @export
 */
export const AddressTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationDestroy(addressTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addressTranslationDestroy(addressTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<AddressTranslationIndex200Response> {
            return localVarFp.addressTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationShow(addressTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressTranslationStore200Response> {
            return localVarFp.addressTranslationShow(addressTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {AddressTranslationStoreRequest} addressTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationStore(addressTranslationStoreRequest: AddressTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddressTranslationStore200Response> {
            return localVarFp.addressTranslationStore(addressTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} addressTranslation The address translation ID
         * @param {AddressTranslationUpdateRequest} [addressTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationUpdate(addressTranslation: string, addressTranslationUpdateRequest?: AddressTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddressTranslationStore200Response> {
            return localVarFp.addressTranslationUpdate(addressTranslation, addressTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressTranslationApi - object-oriented interface
 * @export
 * @class AddressTranslationApi
 * @extends {BaseAPI}
 */
export class AddressTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} addressTranslation The address translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressTranslationApi
     */
    public addressTranslationDestroy(addressTranslation: string, options?: RawAxiosRequestConfig) {
        return AddressTranslationApiFp(this.configuration).addressTranslationDestroy(addressTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressTranslationApi
     */
    public addressTranslationIndex(options?: RawAxiosRequestConfig) {
        return AddressTranslationApiFp(this.configuration).addressTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} addressTranslation The address translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressTranslationApi
     */
    public addressTranslationShow(addressTranslation: string, options?: RawAxiosRequestConfig) {
        return AddressTranslationApiFp(this.configuration).addressTranslationShow(addressTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {AddressTranslationStoreRequest} addressTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressTranslationApi
     */
    public addressTranslationStore(addressTranslationStoreRequest: AddressTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return AddressTranslationApiFp(this.configuration).addressTranslationStore(addressTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} addressTranslation The address translation ID
     * @param {AddressTranslationUpdateRequest} [addressTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressTranslationApi
     */
    public addressTranslationUpdate(addressTranslation: string, addressTranslationUpdateRequest?: AddressTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return AddressTranslationApiFp(this.configuration).addressTranslationUpdate(addressTranslation, addressTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AvailableImageApi - axios parameter creator
 * @export
 */
export const AvailableImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageDestroy: async (availableImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageDestroy', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageDownload: async (availableImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageDownload', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}/download`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/available-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageShow: async (availableImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageShow', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} availableImage The available image ID
         * @param {AvailableImageUpdateRequest} [availableImageUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageUpdate: async (availableImage: string, availableImageUpdateRequest?: AvailableImageUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageUpdate', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(availableImageUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageView: async (availableImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageView', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}/view`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AvailableImageApi - functional programming interface
 * @export
 */
export const AvailableImageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AvailableImageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageDestroy(availableImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageDestroy(availableImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageDownload(availableImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageDownload(availableImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageDownload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableImageIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageShow(availableImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageShow(availableImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} availableImage The available image ID
         * @param {AvailableImageUpdateRequest} [availableImageUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageUpdate(availableImage: string, availableImageUpdateRequest?: AvailableImageUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageUpdate(availableImage, availableImageUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageView(availableImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageView(availableImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AvailableImageApi - factory interface
 * @export
 */
export const AvailableImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AvailableImageApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageDestroy(availableImage: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.availableImageDestroy(availableImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageDownload(availableImage: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.availableImageDownload(availableImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageIndex(options?: RawAxiosRequestConfig): AxiosPromise<AvailableImageIndex200Response> {
            return localVarFp.availableImageIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageShow(availableImage: string, options?: RawAxiosRequestConfig): AxiosPromise<AvailableImageShow200Response> {
            return localVarFp.availableImageShow(availableImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} availableImage The available image ID
         * @param {AvailableImageUpdateRequest} [availableImageUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageUpdate(availableImage: string, availableImageUpdateRequest?: AvailableImageUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AvailableImageShow200Response> {
            return localVarFp.availableImageUpdate(availableImage, availableImageUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageView(availableImage: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.availableImageView(availableImage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AvailableImageApi - object-oriented interface
 * @export
 * @class AvailableImageApi
 * @extends {BaseAPI}
 */
export class AvailableImageApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} availableImage The available image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableImageApi
     */
    public availableImageDestroy(availableImage: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageDestroy(availableImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the file to the caller
     * @param {string} availableImage The available image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableImageApi
     */
    public availableImageDownload(availableImage: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageDownload(availableImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableImageApi
     */
    public availableImageIndex(options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} availableImage The available image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableImageApi
     */
    public availableImageShow(availableImage: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageShow(availableImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} availableImage The available image ID
     * @param {AvailableImageUpdateRequest} [availableImageUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableImageApi
     */
    public availableImageUpdate(availableImage: string, availableImageUpdateRequest?: AvailableImageUpdateRequest, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageUpdate(availableImage, availableImageUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
     * @param {string} availableImage The available image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableImageApi
     */
    public availableImageView(availableImage: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageView(availableImage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CollectionApi - axios parameter creator
 * @export
 */
export const CollectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified collection from storage
         * @param {string} collection The collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionDestroy: async (collection: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionDestroy', 'collection', collection)
            const localVarPath = `/collection/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified collection
         * @param {string} collection The collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionShow: async (collection: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionShow', 'collection', collection)
            const localVarPath = `/collection/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created collection in storage
         * @param {CollectionStoreRequest} collectionStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionStore: async (collectionStoreRequest: CollectionStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionStoreRequest' is not null or undefined
            assertParamExists('collectionStore', 'collectionStoreRequest', collectionStoreRequest)
            const localVarPath = `/collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified collection in storage
         * @param {string} collection The collection ID
         * @param {CollectionUpdateRequest} [collectionUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionUpdate: async (collection: string, collectionUpdateRequest?: CollectionUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionUpdate', 'collection', collection)
            const localVarPath = `/collection/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionApi - functional programming interface
 * @export
 */
export const CollectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified collection from storage
         * @param {string} collection The collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionDestroy(collection: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionDestroy(collection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified collection
         * @param {string} collection The collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionShow(collection: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionShow(collection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created collection in storage
         * @param {CollectionStoreRequest} collectionStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionStore(collectionStoreRequest: CollectionStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionStore(collectionStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified collection in storage
         * @param {string} collection The collection ID
         * @param {CollectionUpdateRequest} [collectionUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionUpdate(collection: string, collectionUpdateRequest?: CollectionUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionUpdate(collection, collectionUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CollectionApi - factory interface
 * @export
 */
export const CollectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified collection from storage
         * @param {string} collection The collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionDestroy(collection: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.collectionDestroy(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionIndex(options?: RawAxiosRequestConfig): AxiosPromise<CollectionIndex200Response> {
            return localVarFp.collectionIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified collection
         * @param {string} collection The collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionShow(collection: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionStore200Response> {
            return localVarFp.collectionShow(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created collection in storage
         * @param {CollectionStoreRequest} collectionStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionStore(collectionStoreRequest: CollectionStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionStore200Response> {
            return localVarFp.collectionStore(collectionStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified collection in storage
         * @param {string} collection The collection ID
         * @param {CollectionUpdateRequest} [collectionUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionUpdate(collection: string, collectionUpdateRequest?: CollectionUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionStore200Response> {
            return localVarFp.collectionUpdate(collection, collectionUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionApi - object-oriented interface
 * @export
 * @class CollectionApi
 * @extends {BaseAPI}
 */
export class CollectionApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified collection from storage
     * @param {string} collection The collection ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public collectionDestroy(collection: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionDestroy(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the collections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public collectionIndex(options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified collection
     * @param {string} collection The collection ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public collectionShow(collection: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionShow(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created collection in storage
     * @param {CollectionStoreRequest} collectionStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public collectionStore(collectionStoreRequest: CollectionStoreRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionStore(collectionStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified collection in storage
     * @param {string} collection The collection ID
     * @param {CollectionUpdateRequest} [collectionUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public collectionUpdate(collection: string, collectionUpdateRequest?: CollectionUpdateRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionUpdate(collection, collectionUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContactApi - axios parameter creator
 * @export
 */
export const ContactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified contact
         * @param {string} contact The contact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactDestroy: async (contact: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('contactDestroy', 'contact', contact)
            const localVarPath = `/contact/{contact}`
                .replace(`{${"contact"}}`, encodeURIComponent(String(contact)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified contact
         * @param {string} contact The contact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactShow: async (contact: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('contactShow', 'contact', contact)
            const localVarPath = `/contact/{contact}`
                .replace(`{${"contact"}}`, encodeURIComponent(String(contact)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created contact
         * @param {ContactStoreRequest} contactStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactStore: async (contactStoreRequest: ContactStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactStoreRequest' is not null or undefined
            assertParamExists('contactStore', 'contactStoreRequest', contactStoreRequest)
            const localVarPath = `/contact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified contact
         * @param {string} contact The contact ID
         * @param {ContactUpdateRequest} contactUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactUpdate: async (contact: string, contactUpdateRequest: ContactUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('contactUpdate', 'contact', contact)
            // verify required parameter 'contactUpdateRequest' is not null or undefined
            assertParamExists('contactUpdate', 'contactUpdateRequest', contactUpdateRequest)
            const localVarPath = `/contact/{contact}`
                .replace(`{${"contact"}}`, encodeURIComponent(String(contact)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactApi - functional programming interface
 * @export
 */
export const ContactApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified contact
         * @param {string} contact The contact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactDestroy(contact: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactDestroy(contact, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.contactDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.contactIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified contact
         * @param {string} contact The contact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactShow(contact: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactShow(contact, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.contactShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created contact
         * @param {ContactStoreRequest} contactStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactStore(contactStoreRequest: ContactStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactStore(contactStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.contactStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified contact
         * @param {string} contact The contact ID
         * @param {ContactUpdateRequest} contactUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactUpdate(contact: string, contactUpdateRequest: ContactUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactUpdate(contact, contactUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.contactUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactApi - factory interface
 * @export
 */
export const ContactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified contact
         * @param {string} contact The contact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactDestroy(contact: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.contactDestroy(contact, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactIndex(options?: RawAxiosRequestConfig): AxiosPromise<ContactIndex200Response> {
            return localVarFp.contactIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified contact
         * @param {string} contact The contact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactShow(contact: string, options?: RawAxiosRequestConfig): AxiosPromise<ContactStore201Response> {
            return localVarFp.contactShow(contact, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created contact
         * @param {ContactStoreRequest} contactStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactStore(contactStoreRequest: ContactStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContactStore201Response> {
            return localVarFp.contactStore(contactStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified contact
         * @param {string} contact The contact ID
         * @param {ContactUpdateRequest} contactUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactUpdate(contact: string, contactUpdateRequest: ContactUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContactStore201Response> {
            return localVarFp.contactUpdate(contact, contactUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactApi - object-oriented interface
 * @export
 * @class ContactApi
 * @extends {BaseAPI}
 */
export class ContactApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified contact
     * @param {string} contact The contact ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactDestroy(contact: string, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactDestroy(contact, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of contacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactIndex(options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified contact
     * @param {string} contact The contact ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactShow(contact: string, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactShow(contact, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created contact
     * @param {ContactStoreRequest} contactStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactStore(contactStoreRequest: ContactStoreRequest, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactStore(contactStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified contact
     * @param {string} contact The contact ID
     * @param {ContactUpdateRequest} contactUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactUpdate(contact: string, contactUpdateRequest: ContactUpdateRequest, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactUpdate(contact, contactUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContactTranslationApi - axios parameter creator
 * @export
 */
export const ContactTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationDestroy: async (contactTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactTranslation' is not null or undefined
            assertParamExists('contactTranslationDestroy', 'contactTranslation', contactTranslation)
            const localVarPath = `/contact-translation/{contactTranslation}`
                .replace(`{${"contactTranslation"}}`, encodeURIComponent(String(contactTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contact-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationShow: async (contactTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactTranslation' is not null or undefined
            assertParamExists('contactTranslationShow', 'contactTranslation', contactTranslation)
            const localVarPath = `/contact-translation/{contactTranslation}`
                .replace(`{${"contactTranslation"}}`, encodeURIComponent(String(contactTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ContactTranslationStoreRequest} contactTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationStore: async (contactTranslationStoreRequest: ContactTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactTranslationStoreRequest' is not null or undefined
            assertParamExists('contactTranslationStore', 'contactTranslationStoreRequest', contactTranslationStoreRequest)
            const localVarPath = `/contact-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} contactTranslation The contact translation ID
         * @param {ContactTranslationUpdateRequest} [contactTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationUpdate: async (contactTranslation: string, contactTranslationUpdateRequest?: ContactTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactTranslation' is not null or undefined
            assertParamExists('contactTranslationUpdate', 'contactTranslation', contactTranslation)
            const localVarPath = `/contact-translation/{contactTranslation}`
                .replace(`{${"contactTranslation"}}`, encodeURIComponent(String(contactTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactTranslationApi - functional programming interface
 * @export
 */
export const ContactTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactTranslationDestroy(contactTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactTranslationDestroy(contactTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactTranslationApi.contactTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactTranslationApi.contactTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactTranslationShow(contactTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactTranslationShow(contactTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactTranslationApi.contactTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ContactTranslationStoreRequest} contactTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactTranslationStore(contactTranslationStoreRequest: ContactTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactTranslationStore(contactTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactTranslationApi.contactTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} contactTranslation The contact translation ID
         * @param {ContactTranslationUpdateRequest} [contactTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactTranslationUpdate(contactTranslation: string, contactTranslationUpdateRequest?: ContactTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactTranslationUpdate(contactTranslation, contactTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactTranslationApi.contactTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactTranslationApi - factory interface
 * @export
 */
export const ContactTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationDestroy(contactTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.contactTranslationDestroy(contactTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<ContactTranslationIndex200Response> {
            return localVarFp.contactTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationShow(contactTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ContactTranslationStore200Response> {
            return localVarFp.contactTranslationShow(contactTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ContactTranslationStoreRequest} contactTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationStore(contactTranslationStoreRequest: ContactTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContactTranslationStore200Response> {
            return localVarFp.contactTranslationStore(contactTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} contactTranslation The contact translation ID
         * @param {ContactTranslationUpdateRequest} [contactTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationUpdate(contactTranslation: string, contactTranslationUpdateRequest?: ContactTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContactTranslationStore200Response> {
            return localVarFp.contactTranslationUpdate(contactTranslation, contactTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactTranslationApi - object-oriented interface
 * @export
 * @class ContactTranslationApi
 * @extends {BaseAPI}
 */
export class ContactTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} contactTranslation The contact translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactTranslationApi
     */
    public contactTranslationDestroy(contactTranslation: string, options?: RawAxiosRequestConfig) {
        return ContactTranslationApiFp(this.configuration).contactTranslationDestroy(contactTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactTranslationApi
     */
    public contactTranslationIndex(options?: RawAxiosRequestConfig) {
        return ContactTranslationApiFp(this.configuration).contactTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} contactTranslation The contact translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactTranslationApi
     */
    public contactTranslationShow(contactTranslation: string, options?: RawAxiosRequestConfig) {
        return ContactTranslationApiFp(this.configuration).contactTranslationShow(contactTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {ContactTranslationStoreRequest} contactTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactTranslationApi
     */
    public contactTranslationStore(contactTranslationStoreRequest: ContactTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return ContactTranslationApiFp(this.configuration).contactTranslationStore(contactTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} contactTranslation The contact translation ID
     * @param {ContactTranslationUpdateRequest} [contactTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactTranslationApi
     */
    public contactTranslationUpdate(contactTranslation: string, contactTranslationUpdateRequest?: ContactTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return ContactTranslationApiFp(this.configuration).contactTranslationUpdate(contactTranslation, contactTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContextApi - axios parameter creator
 * @export
 */
export const ContextApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} context The context ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDestroy: async (context: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('contextDestroy', 'context', context)
            const localVarPath = `/context/{context}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the default context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextGetDefault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/context/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set a context as the default one
         * @param {string} context The context ID
         * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextSetDefault: async (context: string, contextSetDefaultRequest: ContextSetDefaultRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('contextSetDefault', 'context', context)
            // verify required parameter 'contextSetDefaultRequest' is not null or undefined
            assertParamExists('contextSetDefault', 'contextSetDefaultRequest', contextSetDefaultRequest)
            const localVarPath = `/context/{context}/default`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextSetDefaultRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} context The context ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextShow: async (context: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('contextShow', 'context', context)
            const localVarPath = `/context/{context}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ContextStoreRequest} contextStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextStore: async (contextStoreRequest: ContextStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contextStoreRequest' is not null or undefined
            assertParamExists('contextStore', 'contextStoreRequest', contextStoreRequest)
            const localVarPath = `/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} context The context ID
         * @param {ContextStoreRequest} contextStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextUpdate: async (context: string, contextStoreRequest: ContextStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('contextUpdate', 'context', context)
            // verify required parameter 'contextStoreRequest' is not null or undefined
            assertParamExists('contextUpdate', 'contextStoreRequest', contextStoreRequest)
            const localVarPath = `/context/{context}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContextApi - functional programming interface
 * @export
 */
export const ContextApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContextApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} context The context ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextDestroy(context: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextDestroy(context, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the default context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextGetDefault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextGetDefault(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextGetDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set a context as the default one
         * @param {string} context The context ID
         * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextSetDefault(context: string, contextSetDefaultRequest: ContextSetDefaultRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextSetDefault(context, contextSetDefaultRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextSetDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} context The context ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextShow(context: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextShow(context, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ContextStoreRequest} contextStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextStore(contextStoreRequest: ContextStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextStore(contextStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} context The context ID
         * @param {ContextStoreRequest} contextStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextUpdate(context: string, contextStoreRequest: ContextStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextUpdate(context, contextStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContextApi - factory interface
 * @export
 */
export const ContextApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContextApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} context The context ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDestroy(context: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.contextDestroy(context, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the default context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextGetDefault(options?: RawAxiosRequestConfig): AxiosPromise<ContextSetDefault200Response> {
            return localVarFp.contextGetDefault(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextIndex(options?: RawAxiosRequestConfig): AxiosPromise<ContextIndex200Response> {
            return localVarFp.contextIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set a context as the default one
         * @param {string} context The context ID
         * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextSetDefault(context: string, contextSetDefaultRequest: ContextSetDefaultRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContextSetDefault200Response> {
            return localVarFp.contextSetDefault(context, contextSetDefaultRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} context The context ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextShow(context: string, options?: RawAxiosRequestConfig): AxiosPromise<ContextSetDefault200Response> {
            return localVarFp.contextShow(context, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ContextStoreRequest} contextStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextStore(contextStoreRequest: ContextStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContextSetDefault200Response> {
            return localVarFp.contextStore(contextStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} context The context ID
         * @param {ContextStoreRequest} contextStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextUpdate(context: string, contextStoreRequest: ContextStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContextSetDefault200Response> {
            return localVarFp.contextUpdate(context, contextStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContextApi - object-oriented interface
 * @export
 * @class ContextApi
 * @extends {BaseAPI}
 */
export class ContextApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} context The context ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public contextDestroy(context: string, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextDestroy(context, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the default context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public contextGetDefault(options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextGetDefault(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public contextIndex(options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set a context as the default one
     * @param {string} context The context ID
     * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public contextSetDefault(context: string, contextSetDefaultRequest: ContextSetDefaultRequest, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextSetDefault(context, contextSetDefaultRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} context The context ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public contextShow(context: string, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextShow(context, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {ContextStoreRequest} contextStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public contextStore(contextStoreRequest: ContextStoreRequest, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextStore(contextStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} context The context ID
     * @param {ContextStoreRequest} contextStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public contextUpdate(context: string, contextStoreRequest: ContextStoreRequest, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextUpdate(context, contextStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CountryApi - axios parameter creator
 * @export
 */
export const CountryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} country The country ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryDestroy: async (country: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('countryDestroy', 'country', country)
            const localVarPath = `/country/{country}`
                .replace(`{${"country"}}`, encodeURIComponent(String(country)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/country`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} country The country ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryShow: async (country: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('countryShow', 'country', country)
            const localVarPath = `/country/{country}`
                .replace(`{${"country"}}`, encodeURIComponent(String(country)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {CountryStoreRequest} countryStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryStore: async (countryStoreRequest: CountryStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryStoreRequest' is not null or undefined
            assertParamExists('countryStore', 'countryStoreRequest', countryStoreRequest)
            const localVarPath = `/country`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(countryStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} country The country ID
         * @param {CountryUpdateRequest} countryUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryUpdate: async (country: string, countryUpdateRequest: CountryUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('countryUpdate', 'country', country)
            // verify required parameter 'countryUpdateRequest' is not null or undefined
            assertParamExists('countryUpdate', 'countryUpdateRequest', countryUpdateRequest)
            const localVarPath = `/country/{country}`
                .replace(`{${"country"}}`, encodeURIComponent(String(country)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(countryUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountryApi - functional programming interface
 * @export
 */
export const CountryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CountryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} country The country ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryDestroy(country: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryDestroy(country, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} country The country ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryShow(country: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryShow(country, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {CountryStoreRequest} countryStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryStore(countryStoreRequest: CountryStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryStore(countryStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} country The country ID
         * @param {CountryUpdateRequest} countryUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryUpdate(country: string, countryUpdateRequest: CountryUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryUpdate(country, countryUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CountryApi - factory interface
 * @export
 */
export const CountryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CountryApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} country The country ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryDestroy(country: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.countryDestroy(country, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryIndex(options?: RawAxiosRequestConfig): AxiosPromise<CountryIndex200Response> {
            return localVarFp.countryIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} country The country ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryShow(country: string, options?: RawAxiosRequestConfig): AxiosPromise<CountryStore200Response> {
            return localVarFp.countryShow(country, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {CountryStoreRequest} countryStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryStore(countryStoreRequest: CountryStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<CountryStore200Response> {
            return localVarFp.countryStore(countryStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} country The country ID
         * @param {CountryUpdateRequest} countryUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryUpdate(country: string, countryUpdateRequest: CountryUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CountryStore200Response> {
            return localVarFp.countryUpdate(country, countryUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CountryApi - object-oriented interface
 * @export
 * @class CountryApi
 * @extends {BaseAPI}
 */
export class CountryApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} country The country ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countryDestroy(country: string, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryDestroy(country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countryIndex(options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} country The country ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countryShow(country: string, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryShow(country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {CountryStoreRequest} countryStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countryStore(countryStoreRequest: CountryStoreRequest, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryStore(countryStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} country The country ID
     * @param {CountryUpdateRequest} countryUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countryUpdate(country: string, countryUpdateRequest: CountryUpdateRequest, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryUpdate(country, countryUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DetailApi - axios parameter creator
 * @export
 */
export const DetailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} detail The detail ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailDestroy: async (detail: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detail' is not null or undefined
            assertParamExists('detailDestroy', 'detail', detail)
            const localVarPath = `/detail/{detail}`
                .replace(`{${"detail"}}`, encodeURIComponent(String(detail)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} detail The detail ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailShow: async (detail: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detail' is not null or undefined
            assertParamExists('detailShow', 'detail', detail)
            const localVarPath = `/detail/{detail}`
                .replace(`{${"detail"}}`, encodeURIComponent(String(detail)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {DetailStoreRequest} detailStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailStore: async (detailStoreRequest: DetailStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detailStoreRequest' is not null or undefined
            assertParamExists('detailStore', 'detailStoreRequest', detailStoreRequest)
            const localVarPath = `/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(detailStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} detail The detail ID
         * @param {DetailStoreRequest} detailStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailUpdate: async (detail: string, detailStoreRequest: DetailStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detail' is not null or undefined
            assertParamExists('detailUpdate', 'detail', detail)
            // verify required parameter 'detailStoreRequest' is not null or undefined
            assertParamExists('detailUpdate', 'detailStoreRequest', detailStoreRequest)
            const localVarPath = `/detail/{detail}`
                .replace(`{${"detail"}}`, encodeURIComponent(String(detail)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(detailStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DetailApi - functional programming interface
 * @export
 */
export const DetailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DetailApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} detail The detail ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailDestroy(detail: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailDestroy(detail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailApi.detailDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailApi.detailIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} detail The detail ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailShow(detail: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailShow(detail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailApi.detailShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {DetailStoreRequest} detailStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailStore(detailStoreRequest: DetailStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailStore(detailStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailApi.detailStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} detail The detail ID
         * @param {DetailStoreRequest} detailStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailUpdate(detail: string, detailStoreRequest: DetailStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailUpdate(detail, detailStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailApi.detailUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DetailApi - factory interface
 * @export
 */
export const DetailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DetailApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} detail The detail ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailDestroy(detail: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.detailDestroy(detail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailIndex(options?: RawAxiosRequestConfig): AxiosPromise<DetailIndex200Response> {
            return localVarFp.detailIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} detail The detail ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailShow(detail: string, options?: RawAxiosRequestConfig): AxiosPromise<DetailStore200Response> {
            return localVarFp.detailShow(detail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {DetailStoreRequest} detailStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailStore(detailStoreRequest: DetailStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<DetailStore200Response> {
            return localVarFp.detailStore(detailStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} detail The detail ID
         * @param {DetailStoreRequest} detailStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailUpdate(detail: string, detailStoreRequest: DetailStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<DetailStore200Response> {
            return localVarFp.detailUpdate(detail, detailStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DetailApi - object-oriented interface
 * @export
 * @class DetailApi
 * @extends {BaseAPI}
 */
export class DetailApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} detail The detail ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailApi
     */
    public detailDestroy(detail: string, options?: RawAxiosRequestConfig) {
        return DetailApiFp(this.configuration).detailDestroy(detail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailApi
     */
    public detailIndex(options?: RawAxiosRequestConfig) {
        return DetailApiFp(this.configuration).detailIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} detail The detail ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailApi
     */
    public detailShow(detail: string, options?: RawAxiosRequestConfig) {
        return DetailApiFp(this.configuration).detailShow(detail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {DetailStoreRequest} detailStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailApi
     */
    public detailStore(detailStoreRequest: DetailStoreRequest, options?: RawAxiosRequestConfig) {
        return DetailApiFp(this.configuration).detailStore(detailStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} detail The detail ID
     * @param {DetailStoreRequest} detailStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailApi
     */
    public detailUpdate(detail: string, detailStoreRequest: DetailStoreRequest, options?: RawAxiosRequestConfig) {
        return DetailApiFp(this.configuration).detailUpdate(detail, detailStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DetailTranslationApi - axios parameter creator
 * @export
 */
export const DetailTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationDestroy: async (detailTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detailTranslation' is not null or undefined
            assertParamExists('detailTranslationDestroy', 'detailTranslation', detailTranslation)
            const localVarPath = `/detail-translation/{detailTranslation}`
                .replace(`{${"detailTranslation"}}`, encodeURIComponent(String(detailTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of detail translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/detail-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationShow: async (detailTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detailTranslation' is not null or undefined
            assertParamExists('detailTranslationShow', 'detailTranslation', detailTranslation)
            const localVarPath = `/detail-translation/{detailTranslation}`
                .replace(`{${"detailTranslation"}}`, encodeURIComponent(String(detailTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created detail translation
         * @param {DetailTranslationStoreRequest} detailTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationStore: async (detailTranslationStoreRequest: DetailTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detailTranslationStoreRequest' is not null or undefined
            assertParamExists('detailTranslationStore', 'detailTranslationStoreRequest', detailTranslationStoreRequest)
            const localVarPath = `/detail-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(detailTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {DetailTranslationUpdateRequest} [detailTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationUpdate: async (detailTranslation: string, detailTranslationUpdateRequest?: DetailTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detailTranslation' is not null or undefined
            assertParamExists('detailTranslationUpdate', 'detailTranslation', detailTranslation)
            const localVarPath = `/detail-translation/{detailTranslation}`
                .replace(`{${"detailTranslation"}}`, encodeURIComponent(String(detailTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(detailTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DetailTranslationApi - functional programming interface
 * @export
 */
export const DetailTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DetailTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailTranslationDestroy(detailTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailTranslationDestroy(detailTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailTranslationApi.detailTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of detail translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DetailTranslationResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailTranslationApi.detailTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailTranslationShow(detailTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailTranslationShow(detailTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailTranslationApi.detailTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created detail translation
         * @param {DetailTranslationStoreRequest} detailTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailTranslationStore(detailTranslationStoreRequest: DetailTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailTranslationStore(detailTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailTranslationApi.detailTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {DetailTranslationUpdateRequest} [detailTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailTranslationUpdate(detailTranslation: string, detailTranslationUpdateRequest?: DetailTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailTranslationUpdate(detailTranslation, detailTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailTranslationApi.detailTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DetailTranslationApi - factory interface
 * @export
 */
export const DetailTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DetailTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationDestroy(detailTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.detailTranslationDestroy(detailTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of detail translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<Array<DetailTranslationResource>> {
            return localVarFp.detailTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationShow(detailTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<DetailTranslationShow200Response> {
            return localVarFp.detailTranslationShow(detailTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created detail translation
         * @param {DetailTranslationStoreRequest} detailTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationStore(detailTranslationStoreRequest: DetailTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.detailTranslationStore(detailTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {DetailTranslationUpdateRequest} [detailTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationUpdate(detailTranslation: string, detailTranslationUpdateRequest?: DetailTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<DetailTranslationShow200Response> {
            return localVarFp.detailTranslationUpdate(detailTranslation, detailTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DetailTranslationApi - object-oriented interface
 * @export
 * @class DetailTranslationApi
 * @extends {BaseAPI}
 */
export class DetailTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified detail translation
     * @param {string} detailTranslation The detail translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailTranslationApi
     */
    public detailTranslationDestroy(detailTranslation: string, options?: RawAxiosRequestConfig) {
        return DetailTranslationApiFp(this.configuration).detailTranslationDestroy(detailTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of detail translations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailTranslationApi
     */
    public detailTranslationIndex(options?: RawAxiosRequestConfig) {
        return DetailTranslationApiFp(this.configuration).detailTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified detail translation
     * @param {string} detailTranslation The detail translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailTranslationApi
     */
    public detailTranslationShow(detailTranslation: string, options?: RawAxiosRequestConfig) {
        return DetailTranslationApiFp(this.configuration).detailTranslationShow(detailTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created detail translation
     * @param {DetailTranslationStoreRequest} detailTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailTranslationApi
     */
    public detailTranslationStore(detailTranslationStoreRequest: DetailTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return DetailTranslationApiFp(this.configuration).detailTranslationStore(detailTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified detail translation
     * @param {string} detailTranslation The detail translation ID
     * @param {DetailTranslationUpdateRequest} [detailTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailTranslationApi
     */
    public detailTranslationUpdate(detailTranslation: string, detailTranslationUpdateRequest?: DetailTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return DetailTranslationApiFp(this.configuration).detailTranslationUpdate(detailTranslation, detailTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DetailTranslationsApi - axios parameter creator
 * @export
 */
export const DetailTranslationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationDestroy: async (detailTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detailTranslation' is not null or undefined
            assertParamExists('detailTranslationDestroy', 'detailTranslation', detailTranslation)
            const localVarPath = `/detail-translation/{detailTranslation}`
                .replace(`{${"detailTranslation"}}`, encodeURIComponent(String(detailTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of detail translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/detail-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationShow: async (detailTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detailTranslation' is not null or undefined
            assertParamExists('detailTranslationShow', 'detailTranslation', detailTranslation)
            const localVarPath = `/detail-translation/{detailTranslation}`
                .replace(`{${"detailTranslation"}}`, encodeURIComponent(String(detailTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created detail translation
         * @param {DetailTranslationStoreRequest} detailTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationStore: async (detailTranslationStoreRequest: DetailTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detailTranslationStoreRequest' is not null or undefined
            assertParamExists('detailTranslationStore', 'detailTranslationStoreRequest', detailTranslationStoreRequest)
            const localVarPath = `/detail-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(detailTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {DetailTranslationUpdateRequest} [detailTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationUpdate: async (detailTranslation: string, detailTranslationUpdateRequest?: DetailTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detailTranslation' is not null or undefined
            assertParamExists('detailTranslationUpdate', 'detailTranslation', detailTranslation)
            const localVarPath = `/detail-translation/{detailTranslation}`
                .replace(`{${"detailTranslation"}}`, encodeURIComponent(String(detailTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(detailTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DetailTranslationsApi - functional programming interface
 * @export
 */
export const DetailTranslationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DetailTranslationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailTranslationDestroy(detailTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailTranslationDestroy(detailTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailTranslationsApi.detailTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of detail translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DetailTranslationResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailTranslationsApi.detailTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailTranslationShow(detailTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailTranslationShow(detailTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailTranslationsApi.detailTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created detail translation
         * @param {DetailTranslationStoreRequest} detailTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailTranslationStore(detailTranslationStoreRequest: DetailTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailTranslationStore(detailTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailTranslationsApi.detailTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {DetailTranslationUpdateRequest} [detailTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailTranslationUpdate(detailTranslation: string, detailTranslationUpdateRequest?: DetailTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailTranslationUpdate(detailTranslation, detailTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailTranslationsApi.detailTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DetailTranslationsApi - factory interface
 * @export
 */
export const DetailTranslationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DetailTranslationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationDestroy(detailTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.detailTranslationDestroy(detailTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of detail translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<Array<DetailTranslationResource>> {
            return localVarFp.detailTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationShow(detailTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<DetailTranslationShow200Response> {
            return localVarFp.detailTranslationShow(detailTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created detail translation
         * @param {DetailTranslationStoreRequest} detailTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationStore(detailTranslationStoreRequest: DetailTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.detailTranslationStore(detailTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {DetailTranslationUpdateRequest} [detailTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationUpdate(detailTranslation: string, detailTranslationUpdateRequest?: DetailTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<DetailTranslationShow200Response> {
            return localVarFp.detailTranslationUpdate(detailTranslation, detailTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DetailTranslationsApi - object-oriented interface
 * @export
 * @class DetailTranslationsApi
 * @extends {BaseAPI}
 */
export class DetailTranslationsApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified detail translation
     * @param {string} detailTranslation The detail translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailTranslationsApi
     */
    public detailTranslationDestroy(detailTranslation: string, options?: RawAxiosRequestConfig) {
        return DetailTranslationsApiFp(this.configuration).detailTranslationDestroy(detailTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of detail translations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailTranslationsApi
     */
    public detailTranslationIndex(options?: RawAxiosRequestConfig) {
        return DetailTranslationsApiFp(this.configuration).detailTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified detail translation
     * @param {string} detailTranslation The detail translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailTranslationsApi
     */
    public detailTranslationShow(detailTranslation: string, options?: RawAxiosRequestConfig) {
        return DetailTranslationsApiFp(this.configuration).detailTranslationShow(detailTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created detail translation
     * @param {DetailTranslationStoreRequest} detailTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailTranslationsApi
     */
    public detailTranslationStore(detailTranslationStoreRequest: DetailTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return DetailTranslationsApiFp(this.configuration).detailTranslationStore(detailTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified detail translation
     * @param {string} detailTranslation The detail translation ID
     * @param {DetailTranslationUpdateRequest} [detailTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailTranslationsApi
     */
    public detailTranslationUpdate(detailTranslation: string, detailTranslationUpdateRequest?: DetailTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return DetailTranslationsApiFp(this.configuration).detailTranslationUpdate(detailTranslation, detailTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExhibitionApi - axios parameter creator
 * @export
 */
export const ExhibitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified exhibition from storage
         * @param {string} exhibition The exhibition ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionDestroy: async (exhibition: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exhibition' is not null or undefined
            assertParamExists('exhibitionDestroy', 'exhibition', exhibition)
            const localVarPath = `/exhibition/{exhibition}`
                .replace(`{${"exhibition"}}`, encodeURIComponent(String(exhibition)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the exhibitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exhibition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified exhibition
         * @param {string} exhibition The exhibition ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionShow: async (exhibition: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exhibition' is not null or undefined
            assertParamExists('exhibitionShow', 'exhibition', exhibition)
            const localVarPath = `/exhibition/{exhibition}`
                .replace(`{${"exhibition"}}`, encodeURIComponent(String(exhibition)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created exhibition in storage
         * @param {ExhibitionStoreRequest} exhibitionStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionStore: async (exhibitionStoreRequest: ExhibitionStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exhibitionStoreRequest' is not null or undefined
            assertParamExists('exhibitionStore', 'exhibitionStoreRequest', exhibitionStoreRequest)
            const localVarPath = `/exhibition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exhibitionStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified exhibition in storage
         * @param {string} exhibition The exhibition ID
         * @param {ExhibitionUpdateRequest} [exhibitionUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionUpdate: async (exhibition: string, exhibitionUpdateRequest?: ExhibitionUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exhibition' is not null or undefined
            assertParamExists('exhibitionUpdate', 'exhibition', exhibition)
            const localVarPath = `/exhibition/{exhibition}`
                .replace(`{${"exhibition"}}`, encodeURIComponent(String(exhibition)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exhibitionUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExhibitionApi - functional programming interface
 * @export
 */
export const ExhibitionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExhibitionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified exhibition from storage
         * @param {string} exhibition The exhibition ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exhibitionDestroy(exhibition: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exhibitionDestroy(exhibition, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExhibitionApi.exhibitionDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the exhibitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exhibitionIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExhibitionIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exhibitionIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExhibitionApi.exhibitionIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified exhibition
         * @param {string} exhibition The exhibition ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exhibitionShow(exhibition: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExhibitionStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exhibitionShow(exhibition, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExhibitionApi.exhibitionShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created exhibition in storage
         * @param {ExhibitionStoreRequest} exhibitionStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exhibitionStore(exhibitionStoreRequest: ExhibitionStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExhibitionStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exhibitionStore(exhibitionStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExhibitionApi.exhibitionStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified exhibition in storage
         * @param {string} exhibition The exhibition ID
         * @param {ExhibitionUpdateRequest} [exhibitionUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exhibitionUpdate(exhibition: string, exhibitionUpdateRequest?: ExhibitionUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExhibitionStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exhibitionUpdate(exhibition, exhibitionUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExhibitionApi.exhibitionUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExhibitionApi - factory interface
 * @export
 */
export const ExhibitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExhibitionApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified exhibition from storage
         * @param {string} exhibition The exhibition ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionDestroy(exhibition: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.exhibitionDestroy(exhibition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the exhibitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionIndex(options?: RawAxiosRequestConfig): AxiosPromise<ExhibitionIndex200Response> {
            return localVarFp.exhibitionIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified exhibition
         * @param {string} exhibition The exhibition ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionShow(exhibition: string, options?: RawAxiosRequestConfig): AxiosPromise<ExhibitionStore200Response> {
            return localVarFp.exhibitionShow(exhibition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created exhibition in storage
         * @param {ExhibitionStoreRequest} exhibitionStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionStore(exhibitionStoreRequest: ExhibitionStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ExhibitionStore200Response> {
            return localVarFp.exhibitionStore(exhibitionStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified exhibition in storage
         * @param {string} exhibition The exhibition ID
         * @param {ExhibitionUpdateRequest} [exhibitionUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionUpdate(exhibition: string, exhibitionUpdateRequest?: ExhibitionUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ExhibitionStore200Response> {
            return localVarFp.exhibitionUpdate(exhibition, exhibitionUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExhibitionApi - object-oriented interface
 * @export
 * @class ExhibitionApi
 * @extends {BaseAPI}
 */
export class ExhibitionApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified exhibition from storage
     * @param {string} exhibition The exhibition ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExhibitionApi
     */
    public exhibitionDestroy(exhibition: string, options?: RawAxiosRequestConfig) {
        return ExhibitionApiFp(this.configuration).exhibitionDestroy(exhibition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the exhibitions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExhibitionApi
     */
    public exhibitionIndex(options?: RawAxiosRequestConfig) {
        return ExhibitionApiFp(this.configuration).exhibitionIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified exhibition
     * @param {string} exhibition The exhibition ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExhibitionApi
     */
    public exhibitionShow(exhibition: string, options?: RawAxiosRequestConfig) {
        return ExhibitionApiFp(this.configuration).exhibitionShow(exhibition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created exhibition in storage
     * @param {ExhibitionStoreRequest} exhibitionStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExhibitionApi
     */
    public exhibitionStore(exhibitionStoreRequest: ExhibitionStoreRequest, options?: RawAxiosRequestConfig) {
        return ExhibitionApiFp(this.configuration).exhibitionStore(exhibitionStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified exhibition in storage
     * @param {string} exhibition The exhibition ID
     * @param {ExhibitionUpdateRequest} [exhibitionUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExhibitionApi
     */
    public exhibitionUpdate(exhibition: string, exhibitionUpdateRequest?: ExhibitionUpdateRequest, options?: RawAxiosRequestConfig) {
        return ExhibitionApiFp(this.configuration).exhibitionUpdate(exhibition, exhibitionUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExhibitionTranslationApi - axios parameter creator
 * @export
 */
export const ExhibitionTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified exhibition translation
         * @param {string} exhibitionTranslation The exhibition translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionTranslationDestroy: async (exhibitionTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exhibitionTranslation' is not null or undefined
            assertParamExists('exhibitionTranslationDestroy', 'exhibitionTranslation', exhibitionTranslation)
            const localVarPath = `/exhibition-translation/{exhibitionTranslation}`
                .replace(`{${"exhibitionTranslation"}}`, encodeURIComponent(String(exhibitionTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of exhibition translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exhibition-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified exhibition translation
         * @param {string} exhibitionTranslation The exhibition translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionTranslationShow: async (exhibitionTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exhibitionTranslation' is not null or undefined
            assertParamExists('exhibitionTranslationShow', 'exhibitionTranslation', exhibitionTranslation)
            const localVarPath = `/exhibition-translation/{exhibitionTranslation}`
                .replace(`{${"exhibitionTranslation"}}`, encodeURIComponent(String(exhibitionTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created exhibition translation
         * @param {ExhibitionTranslationStoreRequest} exhibitionTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionTranslationStore: async (exhibitionTranslationStoreRequest: ExhibitionTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exhibitionTranslationStoreRequest' is not null or undefined
            assertParamExists('exhibitionTranslationStore', 'exhibitionTranslationStoreRequest', exhibitionTranslationStoreRequest)
            const localVarPath = `/exhibition-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exhibitionTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified exhibition translation
         * @param {string} exhibitionTranslation The exhibition translation ID
         * @param {ExhibitionTranslationUpdateRequest} [exhibitionTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionTranslationUpdate: async (exhibitionTranslation: string, exhibitionTranslationUpdateRequest?: ExhibitionTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exhibitionTranslation' is not null or undefined
            assertParamExists('exhibitionTranslationUpdate', 'exhibitionTranslation', exhibitionTranslation)
            const localVarPath = `/exhibition-translation/{exhibitionTranslation}`
                .replace(`{${"exhibitionTranslation"}}`, encodeURIComponent(String(exhibitionTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exhibitionTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExhibitionTranslationApi - functional programming interface
 * @export
 */
export const ExhibitionTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExhibitionTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified exhibition translation
         * @param {string} exhibitionTranslation The exhibition translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exhibitionTranslationDestroy(exhibitionTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exhibitionTranslationDestroy(exhibitionTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExhibitionTranslationApi.exhibitionTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of exhibition translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exhibitionTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExhibitionTranslationResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exhibitionTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExhibitionTranslationApi.exhibitionTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified exhibition translation
         * @param {string} exhibitionTranslation The exhibition translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exhibitionTranslationShow(exhibitionTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExhibitionTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exhibitionTranslationShow(exhibitionTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExhibitionTranslationApi.exhibitionTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created exhibition translation
         * @param {ExhibitionTranslationStoreRequest} exhibitionTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exhibitionTranslationStore(exhibitionTranslationStoreRequest: ExhibitionTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExhibitionTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exhibitionTranslationStore(exhibitionTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExhibitionTranslationApi.exhibitionTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified exhibition translation
         * @param {string} exhibitionTranslation The exhibition translation ID
         * @param {ExhibitionTranslationUpdateRequest} [exhibitionTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exhibitionTranslationUpdate(exhibitionTranslation: string, exhibitionTranslationUpdateRequest?: ExhibitionTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExhibitionTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exhibitionTranslationUpdate(exhibitionTranslation, exhibitionTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExhibitionTranslationApi.exhibitionTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExhibitionTranslationApi - factory interface
 * @export
 */
export const ExhibitionTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExhibitionTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified exhibition translation
         * @param {string} exhibitionTranslation The exhibition translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionTranslationDestroy(exhibitionTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.exhibitionTranslationDestroy(exhibitionTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of exhibition translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<Array<ExhibitionTranslationResource>> {
            return localVarFp.exhibitionTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified exhibition translation
         * @param {string} exhibitionTranslation The exhibition translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionTranslationShow(exhibitionTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ExhibitionTranslationStore200Response> {
            return localVarFp.exhibitionTranslationShow(exhibitionTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created exhibition translation
         * @param {ExhibitionTranslationStoreRequest} exhibitionTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionTranslationStore(exhibitionTranslationStoreRequest: ExhibitionTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ExhibitionTranslationStore200Response> {
            return localVarFp.exhibitionTranslationStore(exhibitionTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified exhibition translation
         * @param {string} exhibitionTranslation The exhibition translation ID
         * @param {ExhibitionTranslationUpdateRequest} [exhibitionTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionTranslationUpdate(exhibitionTranslation: string, exhibitionTranslationUpdateRequest?: ExhibitionTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ExhibitionTranslationStore200Response> {
            return localVarFp.exhibitionTranslationUpdate(exhibitionTranslation, exhibitionTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExhibitionTranslationApi - object-oriented interface
 * @export
 * @class ExhibitionTranslationApi
 * @extends {BaseAPI}
 */
export class ExhibitionTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified exhibition translation
     * @param {string} exhibitionTranslation The exhibition translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExhibitionTranslationApi
     */
    public exhibitionTranslationDestroy(exhibitionTranslation: string, options?: RawAxiosRequestConfig) {
        return ExhibitionTranslationApiFp(this.configuration).exhibitionTranslationDestroy(exhibitionTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of exhibition translations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExhibitionTranslationApi
     */
    public exhibitionTranslationIndex(options?: RawAxiosRequestConfig) {
        return ExhibitionTranslationApiFp(this.configuration).exhibitionTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified exhibition translation
     * @param {string} exhibitionTranslation The exhibition translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExhibitionTranslationApi
     */
    public exhibitionTranslationShow(exhibitionTranslation: string, options?: RawAxiosRequestConfig) {
        return ExhibitionTranslationApiFp(this.configuration).exhibitionTranslationShow(exhibitionTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created exhibition translation
     * @param {ExhibitionTranslationStoreRequest} exhibitionTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExhibitionTranslationApi
     */
    public exhibitionTranslationStore(exhibitionTranslationStoreRequest: ExhibitionTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return ExhibitionTranslationApiFp(this.configuration).exhibitionTranslationStore(exhibitionTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified exhibition translation
     * @param {string} exhibitionTranslation The exhibition translation ID
     * @param {ExhibitionTranslationUpdateRequest} [exhibitionTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExhibitionTranslationApi
     */
    public exhibitionTranslationUpdate(exhibitionTranslation: string, exhibitionTranslationUpdateRequest?: ExhibitionTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return ExhibitionTranslationApiFp(this.configuration).exhibitionTranslationUpdate(exhibitionTranslation, exhibitionTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExhibitionTranslationsApi - axios parameter creator
 * @export
 */
export const ExhibitionTranslationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified exhibition translation
         * @param {string} exhibitionTranslation The exhibition translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionTranslationDestroy: async (exhibitionTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exhibitionTranslation' is not null or undefined
            assertParamExists('exhibitionTranslationDestroy', 'exhibitionTranslation', exhibitionTranslation)
            const localVarPath = `/exhibition-translation/{exhibitionTranslation}`
                .replace(`{${"exhibitionTranslation"}}`, encodeURIComponent(String(exhibitionTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of exhibition translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exhibition-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified exhibition translation
         * @param {string} exhibitionTranslation The exhibition translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionTranslationShow: async (exhibitionTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exhibitionTranslation' is not null or undefined
            assertParamExists('exhibitionTranslationShow', 'exhibitionTranslation', exhibitionTranslation)
            const localVarPath = `/exhibition-translation/{exhibitionTranslation}`
                .replace(`{${"exhibitionTranslation"}}`, encodeURIComponent(String(exhibitionTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created exhibition translation
         * @param {ExhibitionTranslationStoreRequest} exhibitionTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionTranslationStore: async (exhibitionTranslationStoreRequest: ExhibitionTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exhibitionTranslationStoreRequest' is not null or undefined
            assertParamExists('exhibitionTranslationStore', 'exhibitionTranslationStoreRequest', exhibitionTranslationStoreRequest)
            const localVarPath = `/exhibition-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exhibitionTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified exhibition translation
         * @param {string} exhibitionTranslation The exhibition translation ID
         * @param {ExhibitionTranslationUpdateRequest} [exhibitionTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionTranslationUpdate: async (exhibitionTranslation: string, exhibitionTranslationUpdateRequest?: ExhibitionTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exhibitionTranslation' is not null or undefined
            assertParamExists('exhibitionTranslationUpdate', 'exhibitionTranslation', exhibitionTranslation)
            const localVarPath = `/exhibition-translation/{exhibitionTranslation}`
                .replace(`{${"exhibitionTranslation"}}`, encodeURIComponent(String(exhibitionTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exhibitionTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExhibitionTranslationsApi - functional programming interface
 * @export
 */
export const ExhibitionTranslationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExhibitionTranslationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified exhibition translation
         * @param {string} exhibitionTranslation The exhibition translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exhibitionTranslationDestroy(exhibitionTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exhibitionTranslationDestroy(exhibitionTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExhibitionTranslationsApi.exhibitionTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of exhibition translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exhibitionTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExhibitionTranslationResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exhibitionTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExhibitionTranslationsApi.exhibitionTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified exhibition translation
         * @param {string} exhibitionTranslation The exhibition translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exhibitionTranslationShow(exhibitionTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExhibitionTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exhibitionTranslationShow(exhibitionTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExhibitionTranslationsApi.exhibitionTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created exhibition translation
         * @param {ExhibitionTranslationStoreRequest} exhibitionTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exhibitionTranslationStore(exhibitionTranslationStoreRequest: ExhibitionTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExhibitionTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exhibitionTranslationStore(exhibitionTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExhibitionTranslationsApi.exhibitionTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified exhibition translation
         * @param {string} exhibitionTranslation The exhibition translation ID
         * @param {ExhibitionTranslationUpdateRequest} [exhibitionTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exhibitionTranslationUpdate(exhibitionTranslation: string, exhibitionTranslationUpdateRequest?: ExhibitionTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExhibitionTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exhibitionTranslationUpdate(exhibitionTranslation, exhibitionTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExhibitionTranslationsApi.exhibitionTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExhibitionTranslationsApi - factory interface
 * @export
 */
export const ExhibitionTranslationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExhibitionTranslationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified exhibition translation
         * @param {string} exhibitionTranslation The exhibition translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionTranslationDestroy(exhibitionTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.exhibitionTranslationDestroy(exhibitionTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of exhibition translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<Array<ExhibitionTranslationResource>> {
            return localVarFp.exhibitionTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified exhibition translation
         * @param {string} exhibitionTranslation The exhibition translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionTranslationShow(exhibitionTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ExhibitionTranslationStore200Response> {
            return localVarFp.exhibitionTranslationShow(exhibitionTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created exhibition translation
         * @param {ExhibitionTranslationStoreRequest} exhibitionTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionTranslationStore(exhibitionTranslationStoreRequest: ExhibitionTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ExhibitionTranslationStore200Response> {
            return localVarFp.exhibitionTranslationStore(exhibitionTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified exhibition translation
         * @param {string} exhibitionTranslation The exhibition translation ID
         * @param {ExhibitionTranslationUpdateRequest} [exhibitionTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exhibitionTranslationUpdate(exhibitionTranslation: string, exhibitionTranslationUpdateRequest?: ExhibitionTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ExhibitionTranslationStore200Response> {
            return localVarFp.exhibitionTranslationUpdate(exhibitionTranslation, exhibitionTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExhibitionTranslationsApi - object-oriented interface
 * @export
 * @class ExhibitionTranslationsApi
 * @extends {BaseAPI}
 */
export class ExhibitionTranslationsApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified exhibition translation
     * @param {string} exhibitionTranslation The exhibition translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExhibitionTranslationsApi
     */
    public exhibitionTranslationDestroy(exhibitionTranslation: string, options?: RawAxiosRequestConfig) {
        return ExhibitionTranslationsApiFp(this.configuration).exhibitionTranslationDestroy(exhibitionTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of exhibition translations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExhibitionTranslationsApi
     */
    public exhibitionTranslationIndex(options?: RawAxiosRequestConfig) {
        return ExhibitionTranslationsApiFp(this.configuration).exhibitionTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified exhibition translation
     * @param {string} exhibitionTranslation The exhibition translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExhibitionTranslationsApi
     */
    public exhibitionTranslationShow(exhibitionTranslation: string, options?: RawAxiosRequestConfig) {
        return ExhibitionTranslationsApiFp(this.configuration).exhibitionTranslationShow(exhibitionTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created exhibition translation
     * @param {ExhibitionTranslationStoreRequest} exhibitionTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExhibitionTranslationsApi
     */
    public exhibitionTranslationStore(exhibitionTranslationStoreRequest: ExhibitionTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return ExhibitionTranslationsApiFp(this.configuration).exhibitionTranslationStore(exhibitionTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified exhibition translation
     * @param {string} exhibitionTranslation The exhibition translation ID
     * @param {ExhibitionTranslationUpdateRequest} [exhibitionTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExhibitionTranslationsApi
     */
    public exhibitionTranslationUpdate(exhibitionTranslation: string, exhibitionTranslationUpdateRequest?: ExhibitionTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return ExhibitionTranslationsApiFp(this.configuration).exhibitionTranslationUpdate(exhibitionTranslation, exhibitionTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GalleryApi - axios parameter creator
 * @export
 */
export const GalleryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified gallery from storage
         * @param {string} gallery The gallery ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        galleryDestroy: async (gallery: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gallery' is not null or undefined
            assertParamExists('galleryDestroy', 'gallery', gallery)
            const localVarPath = `/gallery/{gallery}`
                .replace(`{${"gallery"}}`, encodeURIComponent(String(gallery)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the galleries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        galleryIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gallery`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified gallery
         * @param {string} gallery The gallery ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        galleryShow: async (gallery: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gallery' is not null or undefined
            assertParamExists('galleryShow', 'gallery', gallery)
            const localVarPath = `/gallery/{gallery}`
                .replace(`{${"gallery"}}`, encodeURIComponent(String(gallery)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created gallery in storage
         * @param {GalleryStoreRequest} galleryStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        galleryStore: async (galleryStoreRequest: GalleryStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'galleryStoreRequest' is not null or undefined
            assertParamExists('galleryStore', 'galleryStoreRequest', galleryStoreRequest)
            const localVarPath = `/gallery`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(galleryStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified gallery in storage
         * @param {string} gallery The gallery ID
         * @param {GalleryUpdateRequest} [galleryUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        galleryUpdate: async (gallery: string, galleryUpdateRequest?: GalleryUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gallery' is not null or undefined
            assertParamExists('galleryUpdate', 'gallery', gallery)
            const localVarPath = `/gallery/{gallery}`
                .replace(`{${"gallery"}}`, encodeURIComponent(String(gallery)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(galleryUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GalleryApi - functional programming interface
 * @export
 */
export const GalleryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GalleryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified gallery from storage
         * @param {string} gallery The gallery ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async galleryDestroy(gallery: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.galleryDestroy(gallery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GalleryApi.galleryDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the galleries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async galleryIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GalleryIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.galleryIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GalleryApi.galleryIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified gallery
         * @param {string} gallery The gallery ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async galleryShow(gallery: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GalleryStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.galleryShow(gallery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GalleryApi.galleryShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created gallery in storage
         * @param {GalleryStoreRequest} galleryStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async galleryStore(galleryStoreRequest: GalleryStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GalleryStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.galleryStore(galleryStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GalleryApi.galleryStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified gallery in storage
         * @param {string} gallery The gallery ID
         * @param {GalleryUpdateRequest} [galleryUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async galleryUpdate(gallery: string, galleryUpdateRequest?: GalleryUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GalleryStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.galleryUpdate(gallery, galleryUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GalleryApi.galleryUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GalleryApi - factory interface
 * @export
 */
export const GalleryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GalleryApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified gallery from storage
         * @param {string} gallery The gallery ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        galleryDestroy(gallery: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.galleryDestroy(gallery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the galleries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        galleryIndex(options?: RawAxiosRequestConfig): AxiosPromise<GalleryIndex200Response> {
            return localVarFp.galleryIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified gallery
         * @param {string} gallery The gallery ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        galleryShow(gallery: string, options?: RawAxiosRequestConfig): AxiosPromise<GalleryStore200Response> {
            return localVarFp.galleryShow(gallery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created gallery in storage
         * @param {GalleryStoreRequest} galleryStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        galleryStore(galleryStoreRequest: GalleryStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<GalleryStore200Response> {
            return localVarFp.galleryStore(galleryStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified gallery in storage
         * @param {string} gallery The gallery ID
         * @param {GalleryUpdateRequest} [galleryUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        galleryUpdate(gallery: string, galleryUpdateRequest?: GalleryUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GalleryStore200Response> {
            return localVarFp.galleryUpdate(gallery, galleryUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GalleryApi - object-oriented interface
 * @export
 * @class GalleryApi
 * @extends {BaseAPI}
 */
export class GalleryApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified gallery from storage
     * @param {string} gallery The gallery ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GalleryApi
     */
    public galleryDestroy(gallery: string, options?: RawAxiosRequestConfig) {
        return GalleryApiFp(this.configuration).galleryDestroy(gallery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the galleries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GalleryApi
     */
    public galleryIndex(options?: RawAxiosRequestConfig) {
        return GalleryApiFp(this.configuration).galleryIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified gallery
     * @param {string} gallery The gallery ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GalleryApi
     */
    public galleryShow(gallery: string, options?: RawAxiosRequestConfig) {
        return GalleryApiFp(this.configuration).galleryShow(gallery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created gallery in storage
     * @param {GalleryStoreRequest} galleryStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GalleryApi
     */
    public galleryStore(galleryStoreRequest: GalleryStoreRequest, options?: RawAxiosRequestConfig) {
        return GalleryApiFp(this.configuration).galleryStore(galleryStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified gallery in storage
     * @param {string} gallery The gallery ID
     * @param {GalleryUpdateRequest} [galleryUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GalleryApi
     */
    public galleryUpdate(gallery: string, galleryUpdateRequest?: GalleryUpdateRequest, options?: RawAxiosRequestConfig) {
        return GalleryApiFp(this.configuration).galleryUpdate(gallery, galleryUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImageUploadApi - axios parameter creator
 * @export
 */
export const ImageUploadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadDestroy: async (imageUpload: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageUpload' is not null or undefined
            assertParamExists('imageUploadDestroy', 'imageUpload', imageUpload)
            const localVarPath = `/image-upload/{imageUpload}`
                .replace(`{${"imageUpload"}}`, encodeURIComponent(String(imageUpload)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/image-upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadShow: async (imageUpload: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageUpload' is not null or undefined
            assertParamExists('imageUploadShow', 'imageUpload', imageUpload)
            const localVarPath = `/image-upload/{imageUpload}`
                .replace(`{${"imageUpload"}}`, encodeURIComponent(String(imageUpload)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the processing status. If processing is complete, returns the AvailableImage details. If the ImageUpload no longer exists, check if an AvailableImage exists with the same ID.
         * @summary Get the processing status of an image upload
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadStatus: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageUploadStatus', 'id', id)
            const localVarPath = `/image-upload/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadStore: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('imageUploadStore', 'file', file)
            const localVarPath = `/image-upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageUploadApi - functional programming interface
 * @export
 */
export const ImageUploadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImageUploadApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadDestroy(imageUpload: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadDestroy(imageUpload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadShow(imageUpload: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadShow(imageUpload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the processing status. If processing is complete, returns the AvailableImage details. If the ImageUpload no longer exists, check if an AvailableImage exists with the same ID.
         * @summary Get the processing status of an image upload
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadStatus(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadStatus(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadStore(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadStore(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImageUploadApi - factory interface
 * @export
 */
export const ImageUploadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImageUploadApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadDestroy(imageUpload: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.imageUploadDestroy(imageUpload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadIndex(options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadIndex200Response> {
            return localVarFp.imageUploadIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadShow(imageUpload: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadStore200Response> {
            return localVarFp.imageUploadShow(imageUpload, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the processing status. If processing is complete, returns the AvailableImage details. If the ImageUpload no longer exists, check if an AvailableImage exists with the same ID.
         * @summary Get the processing status of an image upload
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadStatus(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadStatus200Response> {
            return localVarFp.imageUploadStatus(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadStore(file: File, options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadStore200Response> {
            return localVarFp.imageUploadStore(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImageUploadApi - object-oriented interface
 * @export
 * @class ImageUploadApi
 * @extends {BaseAPI}
 */
export class ImageUploadApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} imageUpload The image upload ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageUploadApi
     */
    public imageUploadDestroy(imageUpload: string, options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadDestroy(imageUpload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageUploadApi
     */
    public imageUploadIndex(options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} imageUpload The image upload ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageUploadApi
     */
    public imageUploadShow(imageUpload: string, options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadShow(imageUpload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the processing status. If processing is complete, returns the AvailableImage details. If the ImageUpload no longer exists, check if an AvailableImage exists with the same ID.
     * @summary Get the processing status of an image upload
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageUploadApi
     */
    public imageUploadStatus(id: string, options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadStatus(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageUploadApi
     */
    public imageUploadStore(file: File, options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadStore(file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemApi - axios parameter creator
 * @export
 */
export const ItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDestroy: async (item: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemDestroy', 'item', item)
            const localVarPath = `/item/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get items for a specific tag
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemForTag: async (tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('itemForTag', 'tag', tag)
            const localVarPath = `/item/for-tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemShow: async (item: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemShow', 'item', item)
            const localVarPath = `/item/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ItemStoreRequest} itemStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemStore: async (itemStoreRequest: ItemStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemStoreRequest' is not null or undefined
            assertParamExists('itemStore', 'itemStoreRequest', itemStoreRequest)
            const localVarPath = `/item`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} item The item ID
         * @param {ItemStoreRequest} itemStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdate: async (item: string, itemStoreRequest: ItemStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemUpdate', 'item', item)
            // verify required parameter 'itemStoreRequest' is not null or undefined
            assertParamExists('itemUpdate', 'itemStoreRequest', itemStoreRequest)
            const localVarPath = `/item/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows quick editing of tag associations by specifying which tags to attach or detach from the item. It provides fine-grained control over tag operations without requiring a full item update.
         * @summary Update tags for the specified item without modifying other item properties
         * @param {string} item - The item to update tags for
         * @param {ItemUpdateTagsRequest} [itemUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdateTags: async (item: string, itemUpdateTagsRequest?: ItemUpdateTagsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemUpdateTags', 'item', item)
            const localVarPath = `/item/{item}/tags`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemUpdateTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get items that have ALL of the specified tags (AND condition)
         * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemWithAllTags: async (itemWithAllTagsRequest: ItemWithAllTagsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemWithAllTagsRequest' is not null or undefined
            assertParamExists('itemWithAllTags', 'itemWithAllTagsRequest', itemWithAllTagsRequest)
            const localVarPath = `/item/with-all-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemWithAllTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get items that have ANY of the specified tags (OR condition)
         * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemWithAnyTags: async (itemWithAllTagsRequest: ItemWithAllTagsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemWithAllTagsRequest' is not null or undefined
            assertParamExists('itemWithAnyTags', 'itemWithAllTagsRequest', itemWithAllTagsRequest)
            const localVarPath = `/item/with-any-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemWithAllTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemApi - functional programming interface
 * @export
 */
export const ItemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemDestroy(item: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemDestroy(item, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get items for a specific tag
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemForTag(tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemForTag(tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemForTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemShow(item: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemShow(item, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ItemStoreRequest} itemStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemStore(itemStoreRequest: ItemStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemStore(itemStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} item The item ID
         * @param {ItemStoreRequest} itemStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemUpdate(item: string, itemStoreRequest: ItemStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemUpdate(item, itemStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint allows quick editing of tag associations by specifying which tags to attach or detach from the item. It provides fine-grained control over tag operations without requiring a full item update.
         * @summary Update tags for the specified item without modifying other item properties
         * @param {string} item - The item to update tags for
         * @param {ItemUpdateTagsRequest} [itemUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemUpdateTags(item: string, itemUpdateTagsRequest?: ItemUpdateTagsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemUpdateTags(item, itemUpdateTagsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemUpdateTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get items that have ALL of the specified tags (AND condition)
         * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemWithAllTags(itemWithAllTagsRequest: ItemWithAllTagsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemWithAllTags(itemWithAllTagsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemWithAllTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get items that have ANY of the specified tags (OR condition)
         * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemWithAnyTags(itemWithAllTagsRequest: ItemWithAllTagsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemWithAnyTags(itemWithAllTagsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemWithAnyTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemApi - factory interface
 * @export
 */
export const ItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDestroy(item: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.itemDestroy(item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get items for a specific tag
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemForTag(tag: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemIndex200Response> {
            return localVarFp.itemForTag(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemIndex(options?: RawAxiosRequestConfig): AxiosPromise<ItemIndex200Response> {
            return localVarFp.itemIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemShow(item: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemStore200Response> {
            return localVarFp.itemShow(item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ItemStoreRequest} itemStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemStore(itemStoreRequest: ItemStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemStore200Response> {
            return localVarFp.itemStore(itemStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} item The item ID
         * @param {ItemStoreRequest} itemStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdate(item: string, itemStoreRequest: ItemStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemStore200Response> {
            return localVarFp.itemUpdate(item, itemStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows quick editing of tag associations by specifying which tags to attach or detach from the item. It provides fine-grained control over tag operations without requiring a full item update.
         * @summary Update tags for the specified item without modifying other item properties
         * @param {string} item - The item to update tags for
         * @param {ItemUpdateTagsRequest} [itemUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdateTags(item: string, itemUpdateTagsRequest?: ItemUpdateTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemStore200Response> {
            return localVarFp.itemUpdateTags(item, itemUpdateTagsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get items that have ALL of the specified tags (AND condition)
         * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemWithAllTags(itemWithAllTagsRequest: ItemWithAllTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemIndex200Response> {
            return localVarFp.itemWithAllTags(itemWithAllTagsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get items that have ANY of the specified tags (OR condition)
         * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemWithAnyTags(itemWithAllTagsRequest: ItemWithAllTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemIndex200Response> {
            return localVarFp.itemWithAnyTags(itemWithAllTagsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemApi - object-oriented interface
 * @export
 * @class ItemApi
 * @extends {BaseAPI}
 */
export class ItemApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} item The item ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemDestroy(item: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemDestroy(item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get items for a specific tag
     * @param {string} tag The tag ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemForTag(tag: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemForTag(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemIndex(options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} item The item ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemShow(item: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemShow(item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {ItemStoreRequest} itemStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemStore(itemStoreRequest: ItemStoreRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemStore(itemStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} item The item ID
     * @param {ItemStoreRequest} itemStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemUpdate(item: string, itemStoreRequest: ItemStoreRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemUpdate(item, itemStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows quick editing of tag associations by specifying which tags to attach or detach from the item. It provides fine-grained control over tag operations without requiring a full item update.
     * @summary Update tags for the specified item without modifying other item properties
     * @param {string} item - The item to update tags for
     * @param {ItemUpdateTagsRequest} [itemUpdateTagsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemUpdateTags(item: string, itemUpdateTagsRequest?: ItemUpdateTagsRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemUpdateTags(item, itemUpdateTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get items that have ALL of the specified tags (AND condition)
     * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemWithAllTags(itemWithAllTagsRequest: ItemWithAllTagsRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemWithAllTags(itemWithAllTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get items that have ANY of the specified tags (OR condition)
     * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemWithAnyTags(itemWithAllTagsRequest: ItemWithAllTagsRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemWithAnyTags(itemWithAllTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemTranslationApi - axios parameter creator
 * @export
 */
export const ItemTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationDestroy: async (itemTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationDestroy', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationShow: async (itemTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationShow', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationStore: async (itemTranslationStoreRequest: ItemTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslationStoreRequest' is not null or undefined
            assertParamExists('itemTranslationStore', 'itemTranslationStoreRequest', itemTranslationStoreRequest)
            const localVarPath = `/item-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate: async (itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationUpdate', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemTranslationApi - functional programming interface
 * @export
 */
export const ItemTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationDestroy(itemTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemTranslationResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationShow(itemTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationShow(itemTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationStore(itemTranslationStoreRequest: ItemTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationStore(itemTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationUpdate(itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationUpdate(itemTranslation, itemTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemTranslationApi - factory interface
 * @export
 */
export const ItemTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.itemTranslationDestroy(itemTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<Array<ItemTranslationResource>> {
            return localVarFp.itemTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationShow(itemTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationShow(itemTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationStore(itemTranslationStoreRequest: ItemTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.itemTranslationStore(itemTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate(itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationUpdate(itemTranslation, itemTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemTranslationApi - object-oriented interface
 * @export
 * @class ItemTranslationApi
 * @extends {BaseAPI}
 */
export class ItemTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationApi
     */
    public itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationDestroy(itemTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of item translations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationApi
     */
    public itemTranslationIndex(options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationApi
     */
    public itemTranslationShow(itemTranslation: string, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationShow(itemTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created item translation
     * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationApi
     */
    public itemTranslationStore(itemTranslationStoreRequest: ItemTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationStore(itemTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationApi
     */
    public itemTranslationUpdate(itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationUpdate(itemTranslation, itemTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemTranslationsApi - axios parameter creator
 * @export
 */
export const ItemTranslationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationDestroy: async (itemTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationDestroy', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationShow: async (itemTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationShow', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationStore: async (itemTranslationStoreRequest: ItemTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslationStoreRequest' is not null or undefined
            assertParamExists('itemTranslationStore', 'itemTranslationStoreRequest', itemTranslationStoreRequest)
            const localVarPath = `/item-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate: async (itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationUpdate', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemTranslationsApi - functional programming interface
 * @export
 */
export const ItemTranslationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemTranslationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationDestroy(itemTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemTranslationResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationShow(itemTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationShow(itemTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationStore(itemTranslationStoreRequest: ItemTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationStore(itemTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationUpdate(itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationUpdate(itemTranslation, itemTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemTranslationsApi - factory interface
 * @export
 */
export const ItemTranslationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemTranslationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.itemTranslationDestroy(itemTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<Array<ItemTranslationResource>> {
            return localVarFp.itemTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationShow(itemTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationShow(itemTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationStore(itemTranslationStoreRequest: ItemTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.itemTranslationStore(itemTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate(itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationUpdate(itemTranslation, itemTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemTranslationsApi - object-oriented interface
 * @export
 * @class ItemTranslationsApi
 * @extends {BaseAPI}
 */
export class ItemTranslationsApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationsApi
     */
    public itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationDestroy(itemTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of item translations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationsApi
     */
    public itemTranslationIndex(options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationsApi
     */
    public itemTranslationShow(itemTranslation: string, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationShow(itemTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created item translation
     * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationsApi
     */
    public itemTranslationStore(itemTranslationStoreRequest: ItemTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationStore(itemTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationsApi
     */
    public itemTranslationUpdate(itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationUpdate(itemTranslation, itemTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LanguageApi - axios parameter creator
 * @export
 */
export const LanguageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageDestroy: async (language: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('languageDestroy', 'language', language)
            const localVarPath = `/language/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the default Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageGetDefault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/language/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the english Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageGetEnglish: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/language/english`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/language`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set a Language as the default one
         * @param {string} language The language ID
         * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageSetDefault: async (language: string, contextSetDefaultRequest: ContextSetDefaultRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('languageSetDefault', 'language', language)
            // verify required parameter 'contextSetDefaultRequest' is not null or undefined
            assertParamExists('languageSetDefault', 'contextSetDefaultRequest', contextSetDefaultRequest)
            const localVarPath = `/language/{language}/default`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextSetDefaultRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageShow: async (language: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('languageShow', 'language', language)
            const localVarPath = `/language/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {LanguageStoreRequest} languageStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageStore: async (languageStoreRequest: LanguageStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'languageStoreRequest' is not null or undefined
            assertParamExists('languageStore', 'languageStoreRequest', languageStoreRequest)
            const localVarPath = `/language`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(languageStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} language The language ID
         * @param {LanguageUpdateRequest} languageUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageUpdate: async (language: string, languageUpdateRequest: LanguageUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('languageUpdate', 'language', language)
            // verify required parameter 'languageUpdateRequest' is not null or undefined
            assertParamExists('languageUpdate', 'languageUpdateRequest', languageUpdateRequest)
            const localVarPath = `/language/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(languageUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LanguageApi - functional programming interface
 * @export
 */
export const LanguageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LanguageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageDestroy(language: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageDestroy(language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the default Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageGetDefault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageGetDefault(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageGetDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the english Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageGetEnglish(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageGetEnglish(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageGetEnglish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set a Language as the default one
         * @param {string} language The language ID
         * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageSetDefault(language: string, contextSetDefaultRequest: ContextSetDefaultRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageSetDefault(language, contextSetDefaultRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageSetDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageShow(language: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageShow(language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {LanguageStoreRequest} languageStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageStore(languageStoreRequest: LanguageStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageStore(languageStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} language The language ID
         * @param {LanguageUpdateRequest} languageUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageUpdate(language: string, languageUpdateRequest: LanguageUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageUpdate(language, languageUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LanguageApi - factory interface
 * @export
 */
export const LanguageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LanguageApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageDestroy(language: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.languageDestroy(language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the default Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageGetDefault(options?: RawAxiosRequestConfig): AxiosPromise<LanguageSetDefault200Response> {
            return localVarFp.languageGetDefault(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the english Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageGetEnglish(options?: RawAxiosRequestConfig): AxiosPromise<LanguageSetDefault200Response> {
            return localVarFp.languageGetEnglish(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageIndex(options?: RawAxiosRequestConfig): AxiosPromise<LanguageIndex200Response> {
            return localVarFp.languageIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set a Language as the default one
         * @param {string} language The language ID
         * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageSetDefault(language: string, contextSetDefaultRequest: ContextSetDefaultRequest, options?: RawAxiosRequestConfig): AxiosPromise<LanguageSetDefault200Response> {
            return localVarFp.languageSetDefault(language, contextSetDefaultRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageShow(language: string, options?: RawAxiosRequestConfig): AxiosPromise<LanguageSetDefault200Response> {
            return localVarFp.languageShow(language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {LanguageStoreRequest} languageStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageStore(languageStoreRequest: LanguageStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<LanguageSetDefault200Response> {
            return localVarFp.languageStore(languageStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} language The language ID
         * @param {LanguageUpdateRequest} languageUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageUpdate(language: string, languageUpdateRequest: LanguageUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<LanguageSetDefault200Response> {
            return localVarFp.languageUpdate(language, languageUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LanguageApi - object-oriented interface
 * @export
 * @class LanguageApi
 * @extends {BaseAPI}
 */
export class LanguageApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} language The language ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageDestroy(language: string, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageDestroy(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the default Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageGetDefault(options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageGetDefault(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the english Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageGetEnglish(options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageGetEnglish(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageIndex(options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set a Language as the default one
     * @param {string} language The language ID
     * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageSetDefault(language: string, contextSetDefaultRequest: ContextSetDefaultRequest, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageSetDefault(language, contextSetDefaultRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} language The language ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageShow(language: string, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageShow(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {LanguageStoreRequest} languageStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageStore(languageStoreRequest: LanguageStoreRequest, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageStore(languageStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} language The language ID
     * @param {LanguageUpdateRequest} languageUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageUpdate(language: string, languageUpdateRequest: LanguageUpdateRequest, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageUpdate(language, languageUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationApi - axios parameter creator
 * @export
 */
export const LocationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified location
         * @param {string} location The location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationDestroy: async (location: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('locationDestroy', 'location', location)
            const localVarPath = `/location/{location}`
                .replace(`{${"location"}}`, encodeURIComponent(String(location)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified location
         * @param {string} location The location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationShow: async (location: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('locationShow', 'location', location)
            const localVarPath = `/location/{location}`
                .replace(`{${"location"}}`, encodeURIComponent(String(location)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created location
         * @param {LocationStoreRequest} locationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationStore: async (locationStoreRequest: LocationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationStoreRequest' is not null or undefined
            assertParamExists('locationStore', 'locationStoreRequest', locationStoreRequest)
            const localVarPath = `/location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified location
         * @param {string} location The location ID
         * @param {LocationUpdateRequest} locationUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationUpdate: async (location: string, locationUpdateRequest: LocationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('locationUpdate', 'location', location)
            // verify required parameter 'locationUpdateRequest' is not null or undefined
            assertParamExists('locationUpdate', 'locationUpdateRequest', locationUpdateRequest)
            const localVarPath = `/location/{location}`
                .replace(`{${"location"}}`, encodeURIComponent(String(location)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationApi - functional programming interface
 * @export
 */
export const LocationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified location
         * @param {string} location The location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationDestroy(location: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationDestroy(location, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified location
         * @param {string} location The location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationShow(location: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationShow(location, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created location
         * @param {LocationStoreRequest} locationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationStore(locationStoreRequest: LocationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationStore(locationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified location
         * @param {string} location The location ID
         * @param {LocationUpdateRequest} locationUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationUpdate(location: string, locationUpdateRequest: LocationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationUpdate(location, locationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationApi - factory interface
 * @export
 */
export const LocationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified location
         * @param {string} location The location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationDestroy(location: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.locationDestroy(location, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationIndex(options?: RawAxiosRequestConfig): AxiosPromise<LocationIndex200Response> {
            return localVarFp.locationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified location
         * @param {string} location The location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationShow(location: string, options?: RawAxiosRequestConfig): AxiosPromise<LocationStore201Response> {
            return localVarFp.locationShow(location, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created location
         * @param {LocationStoreRequest} locationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationStore(locationStoreRequest: LocationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationStore201Response> {
            return localVarFp.locationStore(locationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified location
         * @param {string} location The location ID
         * @param {LocationUpdateRequest} locationUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationUpdate(location: string, locationUpdateRequest: LocationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationStore201Response> {
            return localVarFp.locationUpdate(location, locationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationApi - object-oriented interface
 * @export
 * @class LocationApi
 * @extends {BaseAPI}
 */
export class LocationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified location
     * @param {string} location The location ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public locationDestroy(location: string, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationDestroy(location, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of locations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public locationIndex(options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified location
     * @param {string} location The location ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public locationShow(location: string, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationShow(location, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created location
     * @param {LocationStoreRequest} locationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public locationStore(locationStoreRequest: LocationStoreRequest, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationStore(locationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified location
     * @param {string} location The location ID
     * @param {LocationUpdateRequest} locationUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public locationUpdate(location: string, locationUpdateRequest: LocationUpdateRequest, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationUpdate(location, locationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationTranslationApi - axios parameter creator
 * @export
 */
export const LocationTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationDestroy: async (locationTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationTranslation' is not null or undefined
            assertParamExists('locationTranslationDestroy', 'locationTranslation', locationTranslation)
            const localVarPath = `/location-translation/{locationTranslation}`
                .replace(`{${"locationTranslation"}}`, encodeURIComponent(String(locationTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/location-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationShow: async (locationTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationTranslation' is not null or undefined
            assertParamExists('locationTranslationShow', 'locationTranslation', locationTranslation)
            const localVarPath = `/location-translation/{locationTranslation}`
                .replace(`{${"locationTranslation"}}`, encodeURIComponent(String(locationTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {LocationTranslationStoreRequest} locationTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationStore: async (locationTranslationStoreRequest: LocationTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationTranslationStoreRequest' is not null or undefined
            assertParamExists('locationTranslationStore', 'locationTranslationStoreRequest', locationTranslationStoreRequest)
            const localVarPath = `/location-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} locationTranslation The location translation ID
         * @param {LocationTranslationUpdateRequest} [locationTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationUpdate: async (locationTranslation: string, locationTranslationUpdateRequest?: LocationTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationTranslation' is not null or undefined
            assertParamExists('locationTranslationUpdate', 'locationTranslation', locationTranslation)
            const localVarPath = `/location-translation/{locationTranslation}`
                .replace(`{${"locationTranslation"}}`, encodeURIComponent(String(locationTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationTranslationApi - functional programming interface
 * @export
 */
export const LocationTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationDestroy(locationTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationDestroy(locationTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationShow(locationTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationShow(locationTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {LocationTranslationStoreRequest} locationTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationStore(locationTranslationStoreRequest: LocationTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationStore(locationTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} locationTranslation The location translation ID
         * @param {LocationTranslationUpdateRequest} [locationTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationUpdate(locationTranslation: string, locationTranslationUpdateRequest?: LocationTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationUpdate(locationTranslation, locationTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationTranslationApi - factory interface
 * @export
 */
export const LocationTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationDestroy(locationTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.locationTranslationDestroy(locationTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<LocationTranslationIndex200Response> {
            return localVarFp.locationTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationShow(locationTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<LocationTranslationStore200Response> {
            return localVarFp.locationTranslationShow(locationTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {LocationTranslationStoreRequest} locationTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationStore(locationTranslationStoreRequest: LocationTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationTranslationStore200Response> {
            return localVarFp.locationTranslationStore(locationTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} locationTranslation The location translation ID
         * @param {LocationTranslationUpdateRequest} [locationTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationUpdate(locationTranslation: string, locationTranslationUpdateRequest?: LocationTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationTranslationStore200Response> {
            return localVarFp.locationTranslationUpdate(locationTranslation, locationTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationTranslationApi - object-oriented interface
 * @export
 * @class LocationTranslationApi
 * @extends {BaseAPI}
 */
export class LocationTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} locationTranslation The location translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationTranslationApi
     */
    public locationTranslationDestroy(locationTranslation: string, options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationDestroy(locationTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationTranslationApi
     */
    public locationTranslationIndex(options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} locationTranslation The location translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationTranslationApi
     */
    public locationTranslationShow(locationTranslation: string, options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationShow(locationTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {LocationTranslationStoreRequest} locationTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationTranslationApi
     */
    public locationTranslationStore(locationTranslationStoreRequest: LocationTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationStore(locationTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} locationTranslation The location translation ID
     * @param {LocationTranslationUpdateRequest} [locationTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationTranslationApi
     */
    public locationTranslationUpdate(locationTranslation: string, locationTranslationUpdateRequest?: LocationTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationUpdate(locationTranslation, locationTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MarkdownApi - axios parameter creator
 * @export
 */
export const MarkdownApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownAllowedElements: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markdown/allowed-elements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownFromHtml: async (markdownFromHtmlRequest: MarkdownFromHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownFromHtmlRequest' is not null or undefined
            assertParamExists('markdownFromHtml', 'markdownFromHtmlRequest', markdownFromHtmlRequest)
            const localVarPath = `/markdown/from-html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownFromHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownIsMarkdown: async (markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownIsMarkdownRequest' is not null or undefined
            assertParamExists('markdownIsMarkdown', 'markdownIsMarkdownRequest', markdownIsMarkdownRequest)
            const localVarPath = `/markdown/is-markdown`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownIsMarkdownRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownPreview: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markdown/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownToHtml: async (markdownToHtmlRequest: MarkdownToHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownToHtmlRequest' is not null or undefined
            assertParamExists('markdownToHtml', 'markdownToHtmlRequest', markdownToHtmlRequest)
            const localVarPath = `/markdown/to-html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownToHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownValidate: async (markdownToHtmlRequest: MarkdownToHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownToHtmlRequest' is not null or undefined
            assertParamExists('markdownValidate', 'markdownToHtmlRequest', markdownToHtmlRequest)
            const localVarPath = `/markdown/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownToHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarkdownApi - functional programming interface
 * @export
 */
export const MarkdownApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarkdownApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownAllowedElements(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownAllowedElements(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownAllowedElements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownFromHtml(markdownFromHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownFromHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownIsMarkdown(markdownIsMarkdownRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownIsMarkdown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownPreview(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarkdownPreview200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownPreview(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownPreview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownToHtml(markdownToHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownToHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownValidate(markdownToHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownValidate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MarkdownApi - factory interface
 * @export
 */
export const MarkdownApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarkdownApiFp(configuration)
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownAllowedElements(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownAllowedElements(options).then((request) => request(axios, basePath));
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownFromHtml(markdownFromHtmlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownIsMarkdown(markdownIsMarkdownRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownPreview(options?: RawAxiosRequestConfig): AxiosPromise<MarkdownPreview200Response> {
            return localVarFp.markdownPreview(options).then((request) => request(axios, basePath));
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownToHtml(markdownToHtmlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownValidate(markdownToHtmlRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarkdownApi - object-oriented interface
 * @export
 * @class MarkdownApi
 * @extends {BaseAPI}
 */
export class MarkdownApi extends BaseAPI {
    /**
     * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
     * @summary Get allowed HTML tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownApi
     */
    public markdownAllowedElements(options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownAllowedElements(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
     * @summary Convert HTML to Markdown
     * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownApi
     */
    public markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownFromHtml(markdownFromHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
     * @summary Check if content is Markdown
     * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownApi
     */
    public markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownIsMarkdown(markdownIsMarkdownRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
     * @summary Preview Markdown content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownApi
     */
    public markdownPreview(options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownPreview(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
     * @summary Convert Markdown to HTML
     * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownApi
     */
    public markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownToHtml(markdownToHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates Markdown content without converting it, useful for form validation.
     * @summary Validate Markdown content
     * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownApi
     */
    public markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownValidate(markdownToHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi - axios parameter creator
 * @export
 */
export const MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownAllowedElements: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markdown/allowed-elements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownFromHtml: async (markdownFromHtmlRequest: MarkdownFromHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownFromHtmlRequest' is not null or undefined
            assertParamExists('markdownFromHtml', 'markdownFromHtmlRequest', markdownFromHtmlRequest)
            const localVarPath = `/markdown/from-html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownFromHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownIsMarkdown: async (markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownIsMarkdownRequest' is not null or undefined
            assertParamExists('markdownIsMarkdown', 'markdownIsMarkdownRequest', markdownIsMarkdownRequest)
            const localVarPath = `/markdown/is-markdown`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownIsMarkdownRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownPreview: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markdown/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownToHtml: async (markdownToHtmlRequest: MarkdownToHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownToHtmlRequest' is not null or undefined
            assertParamExists('markdownToHtml', 'markdownToHtmlRequest', markdownToHtmlRequest)
            const localVarPath = `/markdown/to-html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownToHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownValidate: async (markdownToHtmlRequest: MarkdownToHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownToHtmlRequest' is not null or undefined
            assertParamExists('markdownValidate', 'markdownToHtmlRequest', markdownToHtmlRequest)
            const localVarPath = `/markdown/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownToHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi - functional programming interface
 * @export
 */
export const MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownAllowedElements(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownAllowedElements(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownAllowedElements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownFromHtml(markdownFromHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownFromHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownIsMarkdown(markdownIsMarkdownRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownIsMarkdown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownPreview(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarkdownPreview200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownPreview(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownPreview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownToHtml(markdownToHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownToHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownValidate(markdownToHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownValidate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi - factory interface
 * @export
 */
export const MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(configuration)
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownAllowedElements(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownAllowedElements(options).then((request) => request(axios, basePath));
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownFromHtml(markdownFromHtmlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownIsMarkdown(markdownIsMarkdownRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownPreview(options?: RawAxiosRequestConfig): AxiosPromise<MarkdownPreview200Response> {
            return localVarFp.markdownPreview(options).then((request) => request(axios, basePath));
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownToHtml(markdownToHtmlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownValidate(markdownToHtmlRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi - object-oriented interface
 * @export
 * @class MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi
 * @extends {BaseAPI}
 */
export class MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi extends BaseAPI {
    /**
     * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
     * @summary Get allowed HTML tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi
     */
    public markdownAllowedElements(options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownAllowedElements(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
     * @summary Convert HTML to Markdown
     * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi
     */
    public markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownFromHtml(markdownFromHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
     * @summary Check if content is Markdown
     * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi
     */
    public markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownIsMarkdown(markdownIsMarkdownRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
     * @summary Preview Markdown content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi
     */
    public markdownPreview(options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownPreview(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
     * @summary Convert Markdown to HTML
     * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi
     */
    public markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownToHtml(markdownToHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates Markdown content without converting it, useful for form validation.
     * @summary Validate Markdown content
     * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi
     */
    public markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownValidate(markdownToHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MobileAppAuthenticationApi - axios parameter creator
 * @export
 */
export const MobileAppAuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Acquire a token for the user
         * @param {TokenAcquireRequest} tokenAcquireRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenAcquire: async (tokenAcquireRequest: TokenAcquireRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenAcquireRequest' is not null or undefined
            assertParamExists('tokenAcquire', 'tokenAcquireRequest', tokenAcquireRequest)
            const localVarPath = `/mobile/acquire-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenAcquireRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke all the token for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenWipe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mobile/wipe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MobileAppAuthenticationApi - functional programming interface
 * @export
 */
export const MobileAppAuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MobileAppAuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Acquire a token for the user
         * @param {TokenAcquireRequest} tokenAcquireRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenAcquire(tokenAcquireRequest: TokenAcquireRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenAcquire(tokenAcquireRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MobileAppAuthenticationApi.tokenAcquire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Revoke all the token for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenWipe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenWipe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MobileAppAuthenticationApi.tokenWipe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MobileAppAuthenticationApi - factory interface
 * @export
 */
export const MobileAppAuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MobileAppAuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary Acquire a token for the user
         * @param {TokenAcquireRequest} tokenAcquireRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenAcquire(tokenAcquireRequest: TokenAcquireRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.tokenAcquire(tokenAcquireRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke all the token for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenWipe(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tokenWipe(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MobileAppAuthenticationApi - object-oriented interface
 * @export
 * @class MobileAppAuthenticationApi
 * @extends {BaseAPI}
 */
export class MobileAppAuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Acquire a token for the user
     * @param {TokenAcquireRequest} tokenAcquireRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileAppAuthenticationApi
     */
    public tokenAcquire(tokenAcquireRequest: TokenAcquireRequest, options?: RawAxiosRequestConfig) {
        return MobileAppAuthenticationApiFp(this.configuration).tokenAcquire(tokenAcquireRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke all the token for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileAppAuthenticationApi
     */
    public tokenWipe(options?: RawAxiosRequestConfig) {
        return MobileAppAuthenticationApiFp(this.configuration).tokenWipe(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PartnerApi - axios parameter creator
 * @export
 */
export const PartnerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerDestroy: async (partner: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partner' is not null or undefined
            assertParamExists('partnerDestroy', 'partner', partner)
            const localVarPath = `/partner/{partner}`
                .replace(`{${"partner"}}`, encodeURIComponent(String(partner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/partner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerShow: async (partner: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partner' is not null or undefined
            assertParamExists('partnerShow', 'partner', partner)
            const localVarPath = `/partner/{partner}`
                .replace(`{${"partner"}}`, encodeURIComponent(String(partner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {PartnerStoreRequest} partnerStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerStore: async (partnerStoreRequest: PartnerStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerStoreRequest' is not null or undefined
            assertParamExists('partnerStore', 'partnerStoreRequest', partnerStoreRequest)
            const localVarPath = `/partner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partnerStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partner The partner ID
         * @param {PartnerStoreRequest} partnerStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerUpdate: async (partner: string, partnerStoreRequest: PartnerStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partner' is not null or undefined
            assertParamExists('partnerUpdate', 'partner', partner)
            // verify required parameter 'partnerStoreRequest' is not null or undefined
            assertParamExists('partnerUpdate', 'partnerStoreRequest', partnerStoreRequest)
            const localVarPath = `/partner/{partner}`
                .replace(`{${"partner"}}`, encodeURIComponent(String(partner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partnerStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnerApi - functional programming interface
 * @export
 */
export const PartnerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartnerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerDestroy(partner: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerDestroy(partner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerShow(partner: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerShow(partner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {PartnerStoreRequest} partnerStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerStore(partnerStoreRequest: PartnerStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerStore(partnerStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partner The partner ID
         * @param {PartnerStoreRequest} partnerStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerUpdate(partner: string, partnerStoreRequest: PartnerStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerUpdate(partner, partnerStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PartnerApi - factory interface
 * @export
 */
export const PartnerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartnerApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerDestroy(partner: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.partnerDestroy(partner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerIndex(options?: RawAxiosRequestConfig): AxiosPromise<PartnerIndex200Response> {
            return localVarFp.partnerIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerShow(partner: string, options?: RawAxiosRequestConfig): AxiosPromise<PartnerStore200Response> {
            return localVarFp.partnerShow(partner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {PartnerStoreRequest} partnerStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerStore(partnerStoreRequest: PartnerStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerStore200Response> {
            return localVarFp.partnerStore(partnerStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partner The partner ID
         * @param {PartnerStoreRequest} partnerStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerUpdate(partner: string, partnerStoreRequest: PartnerStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerStore200Response> {
            return localVarFp.partnerUpdate(partner, partnerStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartnerApi - object-oriented interface
 * @export
 * @class PartnerApi
 * @extends {BaseAPI}
 */
export class PartnerApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} partner The partner ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public partnerDestroy(partner: string, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerDestroy(partner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public partnerIndex(options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} partner The partner ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public partnerShow(partner: string, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerShow(partner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {PartnerStoreRequest} partnerStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public partnerStore(partnerStoreRequest: PartnerStoreRequest, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerStore(partnerStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} partner The partner ID
     * @param {PartnerStoreRequest} partnerStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public partnerUpdate(partner: string, partnerStoreRequest: PartnerStoreRequest, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerUpdate(partner, partnerStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PictureApi - axios parameter creator
 * @export
 */
export const PictureApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Attach an AvailableImage to a Detail
         * @param {string} detail The detail ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureAttachToDetail: async (detail: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detail' is not null or undefined
            assertParamExists('pictureAttachToDetail', 'detail', detail)
            const localVarPath = `/detail/{detail}/pictures`
                .replace(`{${"detail"}}`, encodeURIComponent(String(detail)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Attach an AvailableImage to an Item
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureAttachToItem: async (item: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('pictureAttachToItem', 'item', item)
            const localVarPath = `/item/{item}/pictures`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Attach an AvailableImage to a Partner
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureAttachToPartner: async (partner: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partner' is not null or undefined
            assertParamExists('pictureAttachToPartner', 'partner', partner)
            const localVarPath = `/partner/{partner}/pictures`
                .replace(`{${"partner"}}`, encodeURIComponent(String(partner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureDestroy: async (picture: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'picture' is not null or undefined
            assertParamExists('pictureDestroy', 'picture', picture)
            const localVarPath = `/picture/{picture}`
                .replace(`{${"picture"}}`, encodeURIComponent(String(picture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach a Picture from a Detail and convert it back to AvailableImage
         * @param {string} detail The detail ID
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureDetachFromDetail: async (detail: string, picture: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detail' is not null or undefined
            assertParamExists('pictureDetachFromDetail', 'detail', detail)
            // verify required parameter 'picture' is not null or undefined
            assertParamExists('pictureDetachFromDetail', 'picture', picture)
            const localVarPath = `/detail/{detail}/pictures/{picture}`
                .replace(`{${"detail"}}`, encodeURIComponent(String(detail)))
                .replace(`{${"picture"}}`, encodeURIComponent(String(picture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach a Picture from an Item and convert it back to AvailableImage
         * @param {string} item The item ID
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureDetachFromItem: async (item: string, picture: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('pictureDetachFromItem', 'item', item)
            // verify required parameter 'picture' is not null or undefined
            assertParamExists('pictureDetachFromItem', 'picture', picture)
            const localVarPath = `/item/{item}/pictures/{picture}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)))
                .replace(`{${"picture"}}`, encodeURIComponent(String(picture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach a Picture from a Partner and convert it back to AvailableImage
         * @param {string} partner The partner ID
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureDetachFromPartner: async (partner: string, picture: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partner' is not null or undefined
            assertParamExists('pictureDetachFromPartner', 'partner', partner)
            // verify required parameter 'picture' is not null or undefined
            assertParamExists('pictureDetachFromPartner', 'picture', picture)
            const localVarPath = `/partner/{partner}/pictures/{picture}`
                .replace(`{${"partner"}}`, encodeURIComponent(String(partner)))
                .replace(`{${"picture"}}`, encodeURIComponent(String(picture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the file to the caller for download
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureDownload: async (picture: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'picture' is not null or undefined
            assertParamExists('pictureDownload', 'picture', picture)
            const localVarPath = `/picture/{picture}/download`
                .replace(`{${"picture"}}`, encodeURIComponent(String(picture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/picture`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureShow: async (picture: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'picture' is not null or undefined
            assertParamExists('pictureShow', 'picture', picture)
            const localVarPath = `/picture/{picture}`
                .replace(`{${"picture"}}`, encodeURIComponent(String(picture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} picture The picture ID
         * @param {PictureUpdateRequest} pictureUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureUpdate: async (picture: string, pictureUpdateRequest: PictureUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'picture' is not null or undefined
            assertParamExists('pictureUpdate', 'picture', picture)
            // verify required parameter 'pictureUpdateRequest' is not null or undefined
            assertParamExists('pictureUpdate', 'pictureUpdateRequest', pictureUpdateRequest)
            const localVarPath = `/picture/{picture}`
                .replace(`{${"picture"}}`, encodeURIComponent(String(picture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pictureUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the picture file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureView: async (picture: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'picture' is not null or undefined
            assertParamExists('pictureView', 'picture', picture)
            const localVarPath = `/picture/{picture}/view`
                .replace(`{${"picture"}}`, encodeURIComponent(String(picture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PictureApi - functional programming interface
 * @export
 */
export const PictureApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PictureApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Attach an AvailableImage to a Detail
         * @param {string} detail The detail ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureAttachToDetail(detail: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureAttachToDetail(detail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureAttachToDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Attach an AvailableImage to an Item
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureAttachToItem(item: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureAttachToItem(item, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureAttachToItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Attach an AvailableImage to a Partner
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureAttachToPartner(partner: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureAttachToPartner(partner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureAttachToPartner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureDestroy(picture: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureDestroy(picture, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Detach a Picture from a Detail and convert it back to AvailableImage
         * @param {string} detail The detail ID
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureDetachFromDetail(detail: string, picture: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureDetachFromDetail(detail, picture, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureDetachFromDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Detach a Picture from an Item and convert it back to AvailableImage
         * @param {string} item The item ID
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureDetachFromItem(item: string, picture: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureDetachFromItem(item, picture, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureDetachFromItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Detach a Picture from a Partner and convert it back to AvailableImage
         * @param {string} partner The partner ID
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureDetachFromPartner(partner: string, picture: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureDetachFromPartner(partner, picture, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureDetachFromPartner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the file to the caller for download
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureDownload(picture: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureDownload(picture, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureDownload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PictureIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureShow(picture: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PictureShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureShow(picture, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} picture The picture ID
         * @param {PictureUpdateRequest} pictureUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureUpdate(picture: string, pictureUpdateRequest: PictureUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PictureShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureUpdate(picture, pictureUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the picture file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureView(picture: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureView(picture, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PictureApi - factory interface
 * @export
 */
export const PictureApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PictureApiFp(configuration)
    return {
        /**
         * 
         * @summary Attach an AvailableImage to a Detail
         * @param {string} detail The detail ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureAttachToDetail(detail: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.pictureAttachToDetail(detail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Attach an AvailableImage to an Item
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureAttachToItem(item: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.pictureAttachToItem(item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Attach an AvailableImage to a Partner
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureAttachToPartner(partner: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.pictureAttachToPartner(partner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureDestroy(picture: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pictureDestroy(picture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detach a Picture from a Detail and convert it back to AvailableImage
         * @param {string} detail The detail ID
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureDetachFromDetail(detail: string, picture: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.pictureDetachFromDetail(detail, picture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detach a Picture from an Item and convert it back to AvailableImage
         * @param {string} item The item ID
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureDetachFromItem(item: string, picture: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.pictureDetachFromItem(item, picture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detach a Picture from a Partner and convert it back to AvailableImage
         * @param {string} partner The partner ID
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureDetachFromPartner(partner: string, picture: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.pictureDetachFromPartner(partner, picture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the file to the caller for download
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureDownload(picture: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.pictureDownload(picture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureIndex(options?: RawAxiosRequestConfig): AxiosPromise<PictureIndex200Response> {
            return localVarFp.pictureIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureShow(picture: string, options?: RawAxiosRequestConfig): AxiosPromise<PictureShow200Response> {
            return localVarFp.pictureShow(picture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} picture The picture ID
         * @param {PictureUpdateRequest} pictureUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureUpdate(picture: string, pictureUpdateRequest: PictureUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<PictureShow200Response> {
            return localVarFp.pictureUpdate(picture, pictureUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the picture file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureView(picture: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.pictureView(picture, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PictureApi - object-oriented interface
 * @export
 * @class PictureApi
 * @extends {BaseAPI}
 */
export class PictureApi extends BaseAPI {
    /**
     * 
     * @summary Attach an AvailableImage to a Detail
     * @param {string} detail The detail ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureAttachToDetail(detail: string, options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureAttachToDetail(detail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Attach an AvailableImage to an Item
     * @param {string} item The item ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureAttachToItem(item: string, options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureAttachToItem(item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Attach an AvailableImage to a Partner
     * @param {string} partner The partner ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureAttachToPartner(partner: string, options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureAttachToPartner(partner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} picture The picture ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureDestroy(picture: string, options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureDestroy(picture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detach a Picture from a Detail and convert it back to AvailableImage
     * @param {string} detail The detail ID
     * @param {string} picture The picture ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureDetachFromDetail(detail: string, picture: string, options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureDetachFromDetail(detail, picture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detach a Picture from an Item and convert it back to AvailableImage
     * @param {string} item The item ID
     * @param {string} picture The picture ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureDetachFromItem(item: string, picture: string, options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureDetachFromItem(item, picture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detach a Picture from a Partner and convert it back to AvailableImage
     * @param {string} partner The partner ID
     * @param {string} picture The picture ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureDetachFromPartner(partner: string, picture: string, options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureDetachFromPartner(partner, picture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the file to the caller for download
     * @param {string} picture The picture ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureDownload(picture: string, options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureDownload(picture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureIndex(options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} picture The picture ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureShow(picture: string, options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureShow(picture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} picture The picture ID
     * @param {PictureUpdateRequest} pictureUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureUpdate(picture: string, pictureUpdateRequest: PictureUpdateRequest, options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureUpdate(picture, pictureUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the picture file for direct viewing (e.g., for use in <img> src attribute)
     * @param {string} picture The picture ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureView(picture: string, options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureView(picture, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PictureTranslationApi - axios parameter creator
 * @export
 */
export const PictureTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} pictureTranslation The picture translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureTranslationDestroy: async (pictureTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pictureTranslation' is not null or undefined
            assertParamExists('pictureTranslationDestroy', 'pictureTranslation', pictureTranslation)
            const localVarPath = `/picture-translation/{pictureTranslation}`
                .replace(`{${"pictureTranslation"}}`, encodeURIComponent(String(pictureTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/picture-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} pictureTranslation The picture translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureTranslationShow: async (pictureTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pictureTranslation' is not null or undefined
            assertParamExists('pictureTranslationShow', 'pictureTranslation', pictureTranslation)
            const localVarPath = `/picture-translation/{pictureTranslation}`
                .replace(`{${"pictureTranslation"}}`, encodeURIComponent(String(pictureTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {PictureTranslationStoreRequest} pictureTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureTranslationStore: async (pictureTranslationStoreRequest: PictureTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pictureTranslationStoreRequest' is not null or undefined
            assertParamExists('pictureTranslationStore', 'pictureTranslationStoreRequest', pictureTranslationStoreRequest)
            const localVarPath = `/picture-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pictureTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} pictureTranslation The picture translation ID
         * @param {PictureTranslationUpdateRequest} [pictureTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureTranslationUpdate: async (pictureTranslation: string, pictureTranslationUpdateRequest?: PictureTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pictureTranslation' is not null or undefined
            assertParamExists('pictureTranslationUpdate', 'pictureTranslation', pictureTranslation)
            const localVarPath = `/picture-translation/{pictureTranslation}`
                .replace(`{${"pictureTranslation"}}`, encodeURIComponent(String(pictureTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pictureTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PictureTranslationApi - functional programming interface
 * @export
 */
export const PictureTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PictureTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} pictureTranslation The picture translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureTranslationDestroy(pictureTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureTranslationDestroy(pictureTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureTranslationApi.pictureTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PictureTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureTranslationApi.pictureTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} pictureTranslation The picture translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureTranslationShow(pictureTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PictureTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureTranslationShow(pictureTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureTranslationApi.pictureTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {PictureTranslationStoreRequest} pictureTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureTranslationStore(pictureTranslationStoreRequest: PictureTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PictureTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureTranslationStore(pictureTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureTranslationApi.pictureTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} pictureTranslation The picture translation ID
         * @param {PictureTranslationUpdateRequest} [pictureTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureTranslationUpdate(pictureTranslation: string, pictureTranslationUpdateRequest?: PictureTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PictureTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureTranslationUpdate(pictureTranslation, pictureTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureTranslationApi.pictureTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PictureTranslationApi - factory interface
 * @export
 */
export const PictureTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PictureTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} pictureTranslation The picture translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureTranslationDestroy(pictureTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pictureTranslationDestroy(pictureTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<PictureTranslationIndex200Response> {
            return localVarFp.pictureTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} pictureTranslation The picture translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureTranslationShow(pictureTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<PictureTranslationStore200Response> {
            return localVarFp.pictureTranslationShow(pictureTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {PictureTranslationStoreRequest} pictureTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureTranslationStore(pictureTranslationStoreRequest: PictureTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<PictureTranslationStore200Response> {
            return localVarFp.pictureTranslationStore(pictureTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} pictureTranslation The picture translation ID
         * @param {PictureTranslationUpdateRequest} [pictureTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureTranslationUpdate(pictureTranslation: string, pictureTranslationUpdateRequest?: PictureTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<PictureTranslationStore200Response> {
            return localVarFp.pictureTranslationUpdate(pictureTranslation, pictureTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PictureTranslationApi - object-oriented interface
 * @export
 * @class PictureTranslationApi
 * @extends {BaseAPI}
 */
export class PictureTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} pictureTranslation The picture translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureTranslationApi
     */
    public pictureTranslationDestroy(pictureTranslation: string, options?: RawAxiosRequestConfig) {
        return PictureTranslationApiFp(this.configuration).pictureTranslationDestroy(pictureTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureTranslationApi
     */
    public pictureTranslationIndex(options?: RawAxiosRequestConfig) {
        return PictureTranslationApiFp(this.configuration).pictureTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} pictureTranslation The picture translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureTranslationApi
     */
    public pictureTranslationShow(pictureTranslation: string, options?: RawAxiosRequestConfig) {
        return PictureTranslationApiFp(this.configuration).pictureTranslationShow(pictureTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {PictureTranslationStoreRequest} pictureTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureTranslationApi
     */
    public pictureTranslationStore(pictureTranslationStoreRequest: PictureTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return PictureTranslationApiFp(this.configuration).pictureTranslationStore(pictureTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} pictureTranslation The picture translation ID
     * @param {PictureTranslationUpdateRequest} [pictureTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureTranslationApi
     */
    public pictureTranslationUpdate(pictureTranslation: string, pictureTranslationUpdateRequest?: PictureTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return PictureTranslationApiFp(this.configuration).pictureTranslationUpdate(pictureTranslation, pictureTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectApi - axios parameter creator
 * @export
 */
export const ProjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} project The project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDestroy: async (project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectDestroy', 'project', project)
            const localVarPath = `/project/{project}`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all enabled projects (Enabled + launched)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEnabled: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project/enabled`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggle Enable/disable on a project
         * @param {string} project The project ID
         * @param {ProjectSetEnabledRequest} projectSetEnabledRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSetEnabled: async (project: string, projectSetEnabledRequest: ProjectSetEnabledRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectSetEnabled', 'project', project)
            // verify required parameter 'projectSetEnabledRequest' is not null or undefined
            assertParamExists('projectSetEnabled', 'projectSetEnabledRequest', projectSetEnabledRequest)
            const localVarPath = `/project/{project}/enabled`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectSetEnabledRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggle Launched/not-launched on a project
         * @param {string} project The project ID
         * @param {ProjectSetLaunchedRequest} [projectSetLaunchedRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSetLaunched: async (project: string, projectSetLaunchedRequest?: ProjectSetLaunchedRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectSetLaunched', 'project', project)
            const localVarPath = `/project/{project}/launched`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectSetLaunchedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} project The project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectShow: async (project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectShow', 'project', project)
            const localVarPath = `/project/{project}`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ProjectStoreRequest} projectStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStore: async (projectStoreRequest: ProjectStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectStoreRequest' is not null or undefined
            assertParamExists('projectStore', 'projectStoreRequest', projectStoreRequest)
            const localVarPath = `/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} project The project ID
         * @param {ProjectStoreRequest} projectStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectUpdate: async (project: string, projectStoreRequest: ProjectStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectUpdate', 'project', project)
            // verify required parameter 'projectStoreRequest' is not null or undefined
            assertParamExists('projectUpdate', 'projectStoreRequest', projectStoreRequest)
            const localVarPath = `/project/{project}`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} project The project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectDestroy(project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectDestroy(project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all enabled projects (Enabled + launched)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectEnabled(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectEnabled200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectEnabled(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectEnabled']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectEnabled200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Toggle Enable/disable on a project
         * @param {string} project The project ID
         * @param {ProjectSetEnabledRequest} projectSetEnabledRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectSetEnabled(project: string, projectSetEnabledRequest: ProjectSetEnabledRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSetLaunched200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectSetEnabled(project, projectSetEnabledRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectSetEnabled']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Toggle Launched/not-launched on a project
         * @param {string} project The project ID
         * @param {ProjectSetLaunchedRequest} [projectSetLaunchedRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectSetLaunched(project: string, projectSetLaunchedRequest?: ProjectSetLaunchedRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSetLaunched200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectSetLaunched(project, projectSetLaunchedRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectSetLaunched']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} project The project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectShow(project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSetLaunched200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectShow(project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ProjectStoreRequest} projectStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectStore(projectStoreRequest: ProjectStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSetLaunched200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectStore(projectStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} project The project ID
         * @param {ProjectStoreRequest} projectStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectUpdate(project: string, projectStoreRequest: ProjectStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSetLaunched200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectUpdate(project, projectStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} project The project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDestroy(project: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.projectDestroy(project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all enabled projects (Enabled + launched)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEnabled(options?: RawAxiosRequestConfig): AxiosPromise<ProjectEnabled200Response> {
            return localVarFp.projectEnabled(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectIndex(options?: RawAxiosRequestConfig): AxiosPromise<ProjectEnabled200Response> {
            return localVarFp.projectIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Toggle Enable/disable on a project
         * @param {string} project The project ID
         * @param {ProjectSetEnabledRequest} projectSetEnabledRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSetEnabled(project: string, projectSetEnabledRequest: ProjectSetEnabledRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectSetLaunched200Response> {
            return localVarFp.projectSetEnabled(project, projectSetEnabledRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Toggle Launched/not-launched on a project
         * @param {string} project The project ID
         * @param {ProjectSetLaunchedRequest} [projectSetLaunchedRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSetLaunched(project: string, projectSetLaunchedRequest?: ProjectSetLaunchedRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectSetLaunched200Response> {
            return localVarFp.projectSetLaunched(project, projectSetLaunchedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} project The project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectShow(project: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectSetLaunched200Response> {
            return localVarFp.projectShow(project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ProjectStoreRequest} projectStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStore(projectStoreRequest: ProjectStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectSetLaunched200Response> {
            return localVarFp.projectStore(projectStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} project The project ID
         * @param {ProjectStoreRequest} projectStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectUpdate(project: string, projectStoreRequest: ProjectStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectSetLaunched200Response> {
            return localVarFp.projectUpdate(project, projectStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} project The project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectDestroy(project: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectDestroy(project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all enabled projects (Enabled + launched)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectEnabled(options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectEnabled(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectIndex(options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Toggle Enable/disable on a project
     * @param {string} project The project ID
     * @param {ProjectSetEnabledRequest} projectSetEnabledRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectSetEnabled(project: string, projectSetEnabledRequest: ProjectSetEnabledRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectSetEnabled(project, projectSetEnabledRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Toggle Launched/not-launched on a project
     * @param {string} project The project ID
     * @param {ProjectSetLaunchedRequest} [projectSetLaunchedRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectSetLaunched(project: string, projectSetLaunchedRequest?: ProjectSetLaunchedRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectSetLaunched(project, projectSetLaunchedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} project The project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectShow(project: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectShow(project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {ProjectStoreRequest} projectStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectStore(projectStoreRequest: ProjectStoreRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectStore(projectStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} project The project ID
     * @param {ProjectStoreRequest} projectStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectUpdate(project: string, projectStoreRequest: ProjectStoreRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectUpdate(project, projectStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProvinceApi - axios parameter creator
 * @export
 */
export const ProvinceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified province
         * @param {string} province The province ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceDestroy: async (province: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'province' is not null or undefined
            assertParamExists('provinceDestroy', 'province', province)
            const localVarPath = `/province/{province}`
                .replace(`{${"province"}}`, encodeURIComponent(String(province)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of provinces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/province`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified province
         * @param {string} province The province ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceShow: async (province: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'province' is not null or undefined
            assertParamExists('provinceShow', 'province', province)
            const localVarPath = `/province/{province}`
                .replace(`{${"province"}}`, encodeURIComponent(String(province)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created province
         * @param {LocationStoreRequest} locationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceStore: async (locationStoreRequest: LocationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationStoreRequest' is not null or undefined
            assertParamExists('provinceStore', 'locationStoreRequest', locationStoreRequest)
            const localVarPath = `/province`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified province
         * @param {string} province The province ID
         * @param {LocationUpdateRequest} locationUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceUpdate: async (province: string, locationUpdateRequest: LocationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'province' is not null or undefined
            assertParamExists('provinceUpdate', 'province', province)
            // verify required parameter 'locationUpdateRequest' is not null or undefined
            assertParamExists('provinceUpdate', 'locationUpdateRequest', locationUpdateRequest)
            const localVarPath = `/province/{province}`
                .replace(`{${"province"}}`, encodeURIComponent(String(province)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvinceApi - functional programming interface
 * @export
 */
export const ProvinceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProvinceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified province
         * @param {string} province The province ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceDestroy(province: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceDestroy(province, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of provinces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified province
         * @param {string} province The province ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceShow(province: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceShow(province, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created province
         * @param {LocationStoreRequest} locationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceStore(locationStoreRequest: LocationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceStore(locationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified province
         * @param {string} province The province ID
         * @param {LocationUpdateRequest} locationUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceUpdate(province: string, locationUpdateRequest: LocationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceUpdate(province, locationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProvinceApi - factory interface
 * @export
 */
export const ProvinceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProvinceApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified province
         * @param {string} province The province ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceDestroy(province: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.provinceDestroy(province, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of provinces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceIndex(options?: RawAxiosRequestConfig): AxiosPromise<ProvinceIndex200Response> {
            return localVarFp.provinceIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified province
         * @param {string} province The province ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceShow(province: string, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceStore201Response> {
            return localVarFp.provinceShow(province, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created province
         * @param {LocationStoreRequest} locationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceStore(locationStoreRequest: LocationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceStore201Response> {
            return localVarFp.provinceStore(locationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified province
         * @param {string} province The province ID
         * @param {LocationUpdateRequest} locationUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceUpdate(province: string, locationUpdateRequest: LocationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceStore201Response> {
            return localVarFp.provinceUpdate(province, locationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProvinceApi - object-oriented interface
 * @export
 * @class ProvinceApi
 * @extends {BaseAPI}
 */
export class ProvinceApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified province
     * @param {string} province The province ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceApi
     */
    public provinceDestroy(province: string, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceDestroy(province, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of provinces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceApi
     */
    public provinceIndex(options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified province
     * @param {string} province The province ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceApi
     */
    public provinceShow(province: string, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceShow(province, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created province
     * @param {LocationStoreRequest} locationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceApi
     */
    public provinceStore(locationStoreRequest: LocationStoreRequest, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceStore(locationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified province
     * @param {string} province The province ID
     * @param {LocationUpdateRequest} locationUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceApi
     */
    public provinceUpdate(province: string, locationUpdateRequest: LocationUpdateRequest, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceUpdate(province, locationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProvinceTranslationApi - axios parameter creator
 * @export
 */
export const ProvinceTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationDestroy: async (provinceTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provinceTranslation' is not null or undefined
            assertParamExists('provinceTranslationDestroy', 'provinceTranslation', provinceTranslation)
            const localVarPath = `/province-translation/{provinceTranslation}`
                .replace(`{${"provinceTranslation"}}`, encodeURIComponent(String(provinceTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/province-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationShow: async (provinceTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provinceTranslation' is not null or undefined
            assertParamExists('provinceTranslationShow', 'provinceTranslation', provinceTranslation)
            const localVarPath = `/province-translation/{provinceTranslation}`
                .replace(`{${"provinceTranslation"}}`, encodeURIComponent(String(provinceTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ProvinceTranslationStoreRequest} provinceTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationStore: async (provinceTranslationStoreRequest: ProvinceTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provinceTranslationStoreRequest' is not null or undefined
            assertParamExists('provinceTranslationStore', 'provinceTranslationStoreRequest', provinceTranslationStoreRequest)
            const localVarPath = `/province-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provinceTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} provinceTranslation The province translation ID
         * @param {ProvinceTranslationUpdateRequest} [provinceTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationUpdate: async (provinceTranslation: string, provinceTranslationUpdateRequest?: ProvinceTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provinceTranslation' is not null or undefined
            assertParamExists('provinceTranslationUpdate', 'provinceTranslation', provinceTranslation)
            const localVarPath = `/province-translation/{provinceTranslation}`
                .replace(`{${"provinceTranslation"}}`, encodeURIComponent(String(provinceTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provinceTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvinceTranslationApi - functional programming interface
 * @export
 */
export const ProvinceTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProvinceTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationDestroy(provinceTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationDestroy(provinceTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationShow(provinceTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationShow(provinceTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ProvinceTranslationStoreRequest} provinceTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationStore(provinceTranslationStoreRequest: ProvinceTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationStore(provinceTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} provinceTranslation The province translation ID
         * @param {ProvinceTranslationUpdateRequest} [provinceTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationUpdate(provinceTranslation: string, provinceTranslationUpdateRequest?: ProvinceTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationUpdate(provinceTranslation, provinceTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProvinceTranslationApi - factory interface
 * @export
 */
export const ProvinceTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProvinceTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationDestroy(provinceTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.provinceTranslationDestroy(provinceTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<ProvinceTranslationIndex200Response> {
            return localVarFp.provinceTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationShow(provinceTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceTranslationStore200Response> {
            return localVarFp.provinceTranslationShow(provinceTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ProvinceTranslationStoreRequest} provinceTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationStore(provinceTranslationStoreRequest: ProvinceTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceTranslationStore200Response> {
            return localVarFp.provinceTranslationStore(provinceTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} provinceTranslation The province translation ID
         * @param {ProvinceTranslationUpdateRequest} [provinceTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationUpdate(provinceTranslation: string, provinceTranslationUpdateRequest?: ProvinceTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceTranslationStore200Response> {
            return localVarFp.provinceTranslationUpdate(provinceTranslation, provinceTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProvinceTranslationApi - object-oriented interface
 * @export
 * @class ProvinceTranslationApi
 * @extends {BaseAPI}
 */
export class ProvinceTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} provinceTranslation The province translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceTranslationApi
     */
    public provinceTranslationDestroy(provinceTranslation: string, options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationDestroy(provinceTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceTranslationApi
     */
    public provinceTranslationIndex(options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} provinceTranslation The province translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceTranslationApi
     */
    public provinceTranslationShow(provinceTranslation: string, options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationShow(provinceTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {ProvinceTranslationStoreRequest} provinceTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceTranslationApi
     */
    public provinceTranslationStore(provinceTranslationStoreRequest: ProvinceTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationStore(provinceTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} provinceTranslation The province translation ID
     * @param {ProvinceTranslationUpdateRequest} [provinceTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceTranslationApi
     */
    public provinceTranslationUpdate(provinceTranslation: string, provinceTranslationUpdateRequest?: ProvinceTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationUpdate(provinceTranslation, provinceTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagApi - axios parameter creator
 * @export
 */
export const TagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDestroy: async (tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('tagDestroy', 'tag', tag)
            const localVarPath = `/tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tags for a specific item
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagForItem: async (item: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('tagForItem', 'item', item)
            const localVarPath = `/tag/for-item/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagShow: async (tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('tagShow', 'tag', tag)
            const localVarPath = `/tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {TagStoreRequest} tagStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagStore: async (tagStoreRequest: TagStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagStoreRequest' is not null or undefined
            assertParamExists('tagStore', 'tagStoreRequest', tagStoreRequest)
            const localVarPath = `/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} tag The tag ID
         * @param {TagStoreRequest} tagStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagUpdate: async (tag: string, tagStoreRequest: TagStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('tagUpdate', 'tag', tag)
            // verify required parameter 'tagStoreRequest' is not null or undefined
            assertParamExists('tagUpdate', 'tagStoreRequest', tagStoreRequest)
            const localVarPath = `/tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagApi - functional programming interface
 * @export
 */
export const TagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagDestroy(tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagDestroy(tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get tags for a specific item
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagForItem(item: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagForItem(item, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagForItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagShow(tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagShow(tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {TagStoreRequest} tagStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagStore(tagStoreRequest: TagStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagStore(tagStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} tag The tag ID
         * @param {TagStoreRequest} tagStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagUpdate(tag: string, tagStoreRequest: TagStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagUpdate(tag, tagStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagApi - factory interface
 * @export
 */
export const TagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDestroy(tag: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tagDestroy(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tags for a specific item
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagForItem(item: string, options?: RawAxiosRequestConfig): AxiosPromise<TagIndex200Response> {
            return localVarFp.tagForItem(item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagIndex(options?: RawAxiosRequestConfig): AxiosPromise<TagIndex200Response> {
            return localVarFp.tagIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagShow(tag: string, options?: RawAxiosRequestConfig): AxiosPromise<TagStore200Response> {
            return localVarFp.tagShow(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {TagStoreRequest} tagStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagStore(tagStoreRequest: TagStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<TagStore200Response> {
            return localVarFp.tagStore(tagStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} tag The tag ID
         * @param {TagStoreRequest} tagStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagUpdate(tag: string, tagStoreRequest: TagStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<TagStore200Response> {
            return localVarFp.tagUpdate(tag, tagStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagApi - object-oriented interface
 * @export
 * @class TagApi
 * @extends {BaseAPI}
 */
export class TagApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} tag The tag ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public tagDestroy(tag: string, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagDestroy(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tags for a specific item
     * @param {string} item The item ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public tagForItem(item: string, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagForItem(item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public tagIndex(options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} tag The tag ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public tagShow(tag: string, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagShow(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {TagStoreRequest} tagStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public tagStore(tagStoreRequest: TagStoreRequest, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagStore(tagStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} tag The tag ID
     * @param {TagStoreRequest} tagStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public tagUpdate(tag: string, tagStoreRequest: TagStoreRequest, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagUpdate(tag, tagStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ThemeApi - axios parameter creator
 * @export
 */
export const ThemeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified theme from storage
         * @param {string} theme The theme ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeDestroy: async (theme: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'theme' is not null or undefined
            assertParamExists('themeDestroy', 'theme', theme)
            const localVarPath = `/theme/{theme}`
                .replace(`{${"theme"}}`, encodeURIComponent(String(theme)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the themes for an exhibition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/theme`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified theme
         * @param {string} theme The theme ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeShow: async (theme: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'theme' is not null or undefined
            assertParamExists('themeShow', 'theme', theme)
            const localVarPath = `/theme/{theme}`
                .replace(`{${"theme"}}`, encodeURIComponent(String(theme)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created theme in storage
         * @param {ThemeStoreRequest} themeStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeStore: async (themeStoreRequest: ThemeStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeStoreRequest' is not null or undefined
            assertParamExists('themeStore', 'themeStoreRequest', themeStoreRequest)
            const localVarPath = `/theme`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(themeStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified theme in storage
         * @param {string} theme The theme ID
         * @param {ExhibitionUpdateRequest} [exhibitionUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeUpdate: async (theme: string, exhibitionUpdateRequest?: ExhibitionUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'theme' is not null or undefined
            assertParamExists('themeUpdate', 'theme', theme)
            const localVarPath = `/theme/{theme}`
                .replace(`{${"theme"}}`, encodeURIComponent(String(theme)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exhibitionUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThemeApi - functional programming interface
 * @export
 */
export const ThemeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThemeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme from storage
         * @param {string} theme The theme ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeDestroy(theme: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeDestroy(theme, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeApi.themeDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the themes for an exhibition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeApi.themeIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified theme
         * @param {string} theme The theme ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeShow(theme: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeShow(theme, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeApi.themeShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created theme in storage
         * @param {ThemeStoreRequest} themeStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeStore(themeStoreRequest: ThemeStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeStore(themeStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeApi.themeStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified theme in storage
         * @param {string} theme The theme ID
         * @param {ExhibitionUpdateRequest} [exhibitionUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeUpdate(theme: string, exhibitionUpdateRequest?: ExhibitionUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeUpdate(theme, exhibitionUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeApi.themeUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ThemeApi - factory interface
 * @export
 */
export const ThemeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThemeApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme from storage
         * @param {string} theme The theme ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeDestroy(theme: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.themeDestroy(theme, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the themes for an exhibition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeIndex(options?: RawAxiosRequestConfig): AxiosPromise<ThemeIndex200Response> {
            return localVarFp.themeIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified theme
         * @param {string} theme The theme ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeShow(theme: string, options?: RawAxiosRequestConfig): AxiosPromise<ThemeStore200Response> {
            return localVarFp.themeShow(theme, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created theme in storage
         * @param {ThemeStoreRequest} themeStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeStore(themeStoreRequest: ThemeStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeStore200Response> {
            return localVarFp.themeStore(themeStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified theme in storage
         * @param {string} theme The theme ID
         * @param {ExhibitionUpdateRequest} [exhibitionUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeUpdate(theme: string, exhibitionUpdateRequest?: ExhibitionUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeStore200Response> {
            return localVarFp.themeUpdate(theme, exhibitionUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThemeApi - object-oriented interface
 * @export
 * @class ThemeApi
 * @extends {BaseAPI}
 */
export class ThemeApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified theme from storage
     * @param {string} theme The theme ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeApi
     */
    public themeDestroy(theme: string, options?: RawAxiosRequestConfig) {
        return ThemeApiFp(this.configuration).themeDestroy(theme, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the themes for an exhibition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeApi
     */
    public themeIndex(options?: RawAxiosRequestConfig) {
        return ThemeApiFp(this.configuration).themeIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified theme
     * @param {string} theme The theme ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeApi
     */
    public themeShow(theme: string, options?: RawAxiosRequestConfig) {
        return ThemeApiFp(this.configuration).themeShow(theme, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created theme in storage
     * @param {ThemeStoreRequest} themeStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeApi
     */
    public themeStore(themeStoreRequest: ThemeStoreRequest, options?: RawAxiosRequestConfig) {
        return ThemeApiFp(this.configuration).themeStore(themeStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified theme in storage
     * @param {string} theme The theme ID
     * @param {ExhibitionUpdateRequest} [exhibitionUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeApi
     */
    public themeUpdate(theme: string, exhibitionUpdateRequest?: ExhibitionUpdateRequest, options?: RawAxiosRequestConfig) {
        return ThemeApiFp(this.configuration).themeUpdate(theme, exhibitionUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ThemeTranslationApi - axios parameter creator
 * @export
 */
export const ThemeTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationDestroy: async (themeTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationDestroy', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/theme-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationShow: async (themeTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationShow', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {ThemeTranslationStoreRequest} themeTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationStore: async (themeTranslationStoreRequest: ThemeTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslationStoreRequest' is not null or undefined
            assertParamExists('themeTranslationStore', 'themeTranslationStoreRequest', themeTranslationStoreRequest)
            const localVarPath = `/theme-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(themeTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {ThemeTranslationUpdateRequest} [themeTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate: async (themeTranslation: string, themeTranslationUpdateRequest?: ThemeTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationUpdate', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(themeTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThemeTranslationApi - functional programming interface
 * @export
 */
export const ThemeTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThemeTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationDestroy(themeTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationApi.themeTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThemeTranslationResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationApi.themeTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationShow(themeTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationApi.themeTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {ThemeTranslationStoreRequest} themeTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationStore(themeTranslationStoreRequest: ThemeTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationStore(themeTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationApi.themeTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {ThemeTranslationUpdateRequest} [themeTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationUpdate(themeTranslation: string, themeTranslationUpdateRequest?: ThemeTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationUpdate(themeTranslation, themeTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationApi.themeTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ThemeTranslationApi - factory interface
 * @export
 */
export const ThemeTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThemeTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.themeTranslationDestroy(themeTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<Array<ThemeTranslationResource>> {
            return localVarFp.themeTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationStore200Response> {
            return localVarFp.themeTranslationShow(themeTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {ThemeTranslationStoreRequest} themeTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationStore(themeTranslationStoreRequest: ThemeTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationStore200Response> {
            return localVarFp.themeTranslationStore(themeTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {ThemeTranslationUpdateRequest} [themeTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate(themeTranslation: string, themeTranslationUpdateRequest?: ThemeTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationStore200Response> {
            return localVarFp.themeTranslationUpdate(themeTranslation, themeTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThemeTranslationApi - object-oriented interface
 * @export
 * @class ThemeTranslationApi
 * @extends {BaseAPI}
 */
export class ThemeTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeTranslationApi
     */
    public themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig) {
        return ThemeTranslationApiFp(this.configuration).themeTranslationDestroy(themeTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of theme translations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeTranslationApi
     */
    public themeTranslationIndex(options?: RawAxiosRequestConfig) {
        return ThemeTranslationApiFp(this.configuration).themeTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeTranslationApi
     */
    public themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig) {
        return ThemeTranslationApiFp(this.configuration).themeTranslationShow(themeTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created theme translation
     * @param {ThemeTranslationStoreRequest} themeTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeTranslationApi
     */
    public themeTranslationStore(themeTranslationStoreRequest: ThemeTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return ThemeTranslationApiFp(this.configuration).themeTranslationStore(themeTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {ThemeTranslationUpdateRequest} [themeTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeTranslationApi
     */
    public themeTranslationUpdate(themeTranslation: string, themeTranslationUpdateRequest?: ThemeTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return ThemeTranslationApiFp(this.configuration).themeTranslationUpdate(themeTranslation, themeTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ThemeTranslationsApi - axios parameter creator
 * @export
 */
export const ThemeTranslationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationDestroy: async (themeTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationDestroy', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/theme-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationShow: async (themeTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationShow', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {ThemeTranslationStoreRequest} themeTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationStore: async (themeTranslationStoreRequest: ThemeTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslationStoreRequest' is not null or undefined
            assertParamExists('themeTranslationStore', 'themeTranslationStoreRequest', themeTranslationStoreRequest)
            const localVarPath = `/theme-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(themeTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {ThemeTranslationUpdateRequest} [themeTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate: async (themeTranslation: string, themeTranslationUpdateRequest?: ThemeTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationUpdate', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(themeTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThemeTranslationsApi - functional programming interface
 * @export
 */
export const ThemeTranslationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThemeTranslationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationDestroy(themeTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationsApi.themeTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThemeTranslationResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationsApi.themeTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationShow(themeTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationsApi.themeTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {ThemeTranslationStoreRequest} themeTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationStore(themeTranslationStoreRequest: ThemeTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationStore(themeTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationsApi.themeTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {ThemeTranslationUpdateRequest} [themeTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationUpdate(themeTranslation: string, themeTranslationUpdateRequest?: ThemeTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationUpdate(themeTranslation, themeTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationsApi.themeTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ThemeTranslationsApi - factory interface
 * @export
 */
export const ThemeTranslationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThemeTranslationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.themeTranslationDestroy(themeTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<Array<ThemeTranslationResource>> {
            return localVarFp.themeTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationStore200Response> {
            return localVarFp.themeTranslationShow(themeTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {ThemeTranslationStoreRequest} themeTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationStore(themeTranslationStoreRequest: ThemeTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationStore200Response> {
            return localVarFp.themeTranslationStore(themeTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {ThemeTranslationUpdateRequest} [themeTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate(themeTranslation: string, themeTranslationUpdateRequest?: ThemeTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationStore200Response> {
            return localVarFp.themeTranslationUpdate(themeTranslation, themeTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThemeTranslationsApi - object-oriented interface
 * @export
 * @class ThemeTranslationsApi
 * @extends {BaseAPI}
 */
export class ThemeTranslationsApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeTranslationsApi
     */
    public themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig) {
        return ThemeTranslationsApiFp(this.configuration).themeTranslationDestroy(themeTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of theme translations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeTranslationsApi
     */
    public themeTranslationIndex(options?: RawAxiosRequestConfig) {
        return ThemeTranslationsApiFp(this.configuration).themeTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeTranslationsApi
     */
    public themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig) {
        return ThemeTranslationsApiFp(this.configuration).themeTranslationShow(themeTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created theme translation
     * @param {ThemeTranslationStoreRequest} themeTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeTranslationsApi
     */
    public themeTranslationStore(themeTranslationStoreRequest: ThemeTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return ThemeTranslationsApiFp(this.configuration).themeTranslationStore(themeTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {ThemeTranslationUpdateRequest} [themeTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeTranslationsApi
     */
    public themeTranslationUpdate(themeTranslation: string, themeTranslationUpdateRequest?: ThemeTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return ThemeTranslationsApiFp(this.configuration).themeTranslationUpdate(themeTranslation, themeTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



