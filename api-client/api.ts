/* tslint:disable */
/* eslint-disable */
/**
 * Inventory-App
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddressIndex200Response
 */
export interface AddressIndex200Response {
    /**
     * 
     * @type {Array<AddressResource>}
     * @memberof AddressIndex200Response
     */
    'data': Array<AddressResource>;
}
/**
 * 
 * @export
 * @interface AddressResource
 */
export interface AddressResource {
    /**
     * 
     * @type {string}
     * @memberof AddressResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AddressResource
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof AddressResource
     */
    'country_id': string;
    /**
     * 
     * @type {Array<AddressTranslationResource>}
     * @memberof AddressResource
     */
    'translations'?: Array<AddressTranslationResource>;
    /**
     * 
     * @type {string}
     * @memberof AddressResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface AddressStore201Response
 */
export interface AddressStore201Response {
    /**
     * 
     * @type {AddressResource}
     * @memberof AddressStore201Response
     */
    'data': AddressResource;
}
/**
 * 
 * @export
 * @interface AddressStore422Response
 */
export interface AddressStore422Response {
    /**
     * 
     * @type {string}
     * @memberof AddressStore422Response
     */
    'errors': string;
}
/**
 * 
 * @export
 * @interface AddressStoreRequest
 */
export interface AddressStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressStoreRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {number}
     * @memberof AddressStoreRequest
     */
    'country_id': number;
    /**
     * 
     * @type {Array<AddressStoreRequestTranslationsInner>}
     * @memberof AddressStoreRequest
     */
    'translations'?: Array<AddressStoreRequestTranslationsInner>;
}
/**
 * 
 * @export
 * @interface AddressStoreRequestTranslationsInner
 */
export interface AddressStoreRequestTranslationsInner {
    /**
     * 
     * @type {number}
     * @memberof AddressStoreRequestTranslationsInner
     */
    'language_id': number;
    /**
     * 
     * @type {string}
     * @memberof AddressStoreRequestTranslationsInner
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof AddressStoreRequestTranslationsInner
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface AddressTranslationIndex200Response
 */
export interface AddressTranslationIndex200Response {
    /**
     * 
     * @type {Array<AddressTranslationResource>}
     * @memberof AddressTranslationIndex200Response
     */
    'data': Array<AddressTranslationResource>;
}
/**
 * 
 * @export
 * @interface AddressTranslationResource
 */
export interface AddressTranslationResource {
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationResource
     */
    'address_id': string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationResource
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationResource
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationResource
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface AddressTranslationStore200Response
 */
export interface AddressTranslationStore200Response {
    /**
     * 
     * @type {AddressTranslationResource}
     * @memberof AddressTranslationStore200Response
     */
    'data': AddressTranslationResource;
}
/**
 * 
 * @export
 * @interface AddressTranslationStoreRequest
 */
export interface AddressTranslationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationStoreRequest
     */
    'address_id': string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationStoreRequest
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationStoreRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface AddressTranslationUpdateRequest
 */
export interface AddressTranslationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationUpdateRequest
     */
    'address_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationUpdateRequest
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationUpdateRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface AddressUpdateRequest
 */
export interface AddressUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressUpdateRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdateRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {number}
     * @memberof AddressUpdateRequest
     */
    'country_id': number;
    /**
     * 
     * @type {Array<AddressUpdateRequestTranslationsInner>}
     * @memberof AddressUpdateRequest
     */
    'translations'?: Array<AddressUpdateRequestTranslationsInner>;
}
/**
 * 
 * @export
 * @interface AddressUpdateRequestTranslationsInner
 */
export interface AddressUpdateRequestTranslationsInner {
    /**
     * 
     * @type {number}
     * @memberof AddressUpdateRequestTranslationsInner
     */
    'language_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdateRequestTranslationsInner
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdateRequestTranslationsInner
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface ArtistResource
 */
export interface ArtistResource {
    /**
     * 
     * @type {string}
     * @memberof ArtistResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ArtistResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ArtistResource
     */
    'place_of_birth': string | null;
    /**
     * 
     * @type {string}
     * @memberof ArtistResource
     */
    'place_of_death': string | null;
    /**
     * 
     * @type {string}
     * @memberof ArtistResource
     */
    'date_of_birth': string | null;
    /**
     * 
     * @type {string}
     * @memberof ArtistResource
     */
    'date_of_death': string | null;
    /**
     * 
     * @type {string}
     * @memberof ArtistResource
     */
    'period_of_activity': string | null;
    /**
     * 
     * @type {string}
     * @memberof ArtistResource
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ArtistResource
     */
    'backward_compatibility': string | null;
    /**
     * 
     * @type {string}
     * @memberof ArtistResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof ArtistResource
     */
    'updated_at': string | null;
    /**
     * 
     * @type {Array<ItemResource>}
     * @memberof ArtistResource
     */
    'items'?: Array<ItemResource>;
}
/**
 * 
 * @export
 * @interface AuthorResource
 */
export interface AuthorResource {
    /**
     * 
     * @type {string}
     * @memberof AuthorResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AuthorResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AuthorResource
     */
    'internal_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthorResource
     */
    'backward_compatibility': string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthorResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthorResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface AvailableImageIndex200Response
 */
export interface AvailableImageIndex200Response {
    /**
     * 
     * @type {Array<AvailableImageResource>}
     * @memberof AvailableImageIndex200Response
     */
    'data': Array<AvailableImageResource>;
}
/**
 * 
 * @export
 * @interface AvailableImageResource
 */
export interface AvailableImageResource {
    /**
     * The unique identifier of the picture (GUID)
     * @type {string}
     * @memberof AvailableImageResource
     */
    'id': string;
    /**
     * The path to the picture file
     * @type {string}
     * @memberof AvailableImageResource
     */
    'path': string | null;
    /**
     * A user defined comment associated with the file
     * @type {string}
     * @memberof AvailableImageResource
     */
    'comment': string | null;
    /**
     * Date of creation
     * @type {string}
     * @memberof AvailableImageResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof AvailableImageResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface AvailableImageShow200Response
 */
export interface AvailableImageShow200Response {
    /**
     * 
     * @type {AvailableImageResource}
     * @memberof AvailableImageShow200Response
     */
    'data': AvailableImageResource;
}
/**
 * 
 * @export
 * @interface AvailableImageUpdateRequest
 */
export interface AvailableImageUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof AvailableImageUpdateRequest
     */
    'comment'?: string | null;
}
/**
 * 
 * @export
 * @interface ContactIndex200Response
 */
export interface ContactIndex200Response {
    /**
     * 
     * @type {Array<ContactResource>}
     * @memberof ContactIndex200Response
     */
    'data': Array<ContactResource>;
}
/**
 * 
 * @export
 * @interface ContactResource
 */
export interface ContactResource {
    /**
     * 
     * @type {string}
     * @memberof ContactResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContactResource
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ContactResource
     */
    'phone_number': string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResource
     */
    'formatted_phone_number': string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResource
     */
    'fax_number': string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResource
     */
    'formatted_fax_number': string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResource
     */
    'email': string | null;
    /**
     * 
     * @type {Array<ContactTranslationResource>}
     * @memberof ContactResource
     */
    'translations'?: Array<ContactTranslationResource>;
    /**
     * 
     * @type {string}
     * @memberof ContactResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ContactStore201Response
 */
export interface ContactStore201Response {
    /**
     * 
     * @type {ContactResource}
     * @memberof ContactStore201Response
     */
    'data': ContactResource;
}
/**
 * 
 * @export
 * @interface ContactStoreRequest
 */
export interface ContactStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ContactStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ContactStoreRequest
     */
    'phone_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactStoreRequest
     */
    'fax_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactStoreRequest
     */
    'email'?: string | null;
    /**
     * 
     * @type {Array<ContactStoreRequestTranslationsInner>}
     * @memberof ContactStoreRequest
     */
    'translations': Array<ContactStoreRequestTranslationsInner>;
}
/**
 * 
 * @export
 * @interface ContactStoreRequestTranslationsInner
 */
export interface ContactStoreRequestTranslationsInner {
    /**
     * 
     * @type {number}
     * @memberof ContactStoreRequestTranslationsInner
     */
    'language_id': number;
    /**
     * 
     * @type {string}
     * @memberof ContactStoreRequestTranslationsInner
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface ContactTranslationIndex200Response
 */
export interface ContactTranslationIndex200Response {
    /**
     * 
     * @type {Array<ContactTranslationResource>}
     * @memberof ContactTranslationIndex200Response
     */
    'data': Array<ContactTranslationResource>;
}
/**
 * 
 * @export
 * @interface ContactTranslationResource
 */
export interface ContactTranslationResource {
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationResource
     */
    'contact_id': string;
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationResource
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationResource
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ContactTranslationStore200Response
 */
export interface ContactTranslationStore200Response {
    /**
     * 
     * @type {ContactTranslationResource}
     * @memberof ContactTranslationStore200Response
     */
    'data': ContactTranslationResource;
}
/**
 * 
 * @export
 * @interface ContactTranslationStoreRequest
 */
export interface ContactTranslationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationStoreRequest
     */
    'contact_id': string;
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationStoreRequest
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface ContactTranslationUpdateRequest
 */
export interface ContactTranslationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationUpdateRequest
     */
    'contact_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationUpdateRequest
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface ContactUpdateRequest
 */
export interface ContactUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateRequest
     */
    'phone_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateRequest
     */
    'fax_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateRequest
     */
    'email'?: string | null;
    /**
     * 
     * @type {Array<ContactUpdateRequestTranslationsInner>}
     * @memberof ContactUpdateRequest
     */
    'translations'?: Array<ContactUpdateRequestTranslationsInner>;
}
/**
 * 
 * @export
 * @interface ContactUpdateRequestTranslationsInner
 */
export interface ContactUpdateRequestTranslationsInner {
    /**
     * 
     * @type {number}
     * @memberof ContactUpdateRequestTranslationsInner
     */
    'language_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateRequestTranslationsInner
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface ContextGetDefault404Response
 */
export interface ContextGetDefault404Response {
    /**
     * 
     * @type {string}
     * @memberof ContextGetDefault404Response
     */
    'message': ContextGetDefault404ResponseMessageEnum;
}

export const ContextGetDefault404ResponseMessageEnum = {
    NoDefaultContextFound: 'No default context found'
} as const;

export type ContextGetDefault404ResponseMessageEnum = typeof ContextGetDefault404ResponseMessageEnum[keyof typeof ContextGetDefault404ResponseMessageEnum];

/**
 * 
 * @export
 * @interface ContextIndex200Response
 */
export interface ContextIndex200Response {
    /**
     * 
     * @type {Array<ContextResource>}
     * @memberof ContextIndex200Response
     */
    'data': Array<ContextResource>;
}
/**
 * 
 * @export
 * @interface ContextResource
 */
export interface ContextResource {
    /**
     * The unique identifier of the context (GUID)
     * @type {string}
     * @memberof ContextResource
     */
    'id': string;
    /**
     * The name of the context, it shall only be used internally
     * @type {string}
     * @memberof ContextResource
     */
    'internal_name': string;
    /**
     * The legacy Id when this context corresponds to a legacy context from the MWNF3 database, nullable
     * @type {string}
     * @memberof ContextResource
     */
    'backward_compatibility': string | null;
    /**
     * Indicates if this context is the default one. There is one single default context for the entire database.
     * @type {boolean}
     * @memberof ContextResource
     */
    'is_default': boolean;
    /**
     * Date of creation
     * @type {string}
     * @memberof ContextResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof ContextResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ContextSetDefault200Response
 */
export interface ContextSetDefault200Response {
    /**
     * 
     * @type {ContextResource}
     * @memberof ContextSetDefault200Response
     */
    'data': ContextResource;
}
/**
 * 
 * @export
 * @interface ContextSetDefaultRequest
 */
export interface ContextSetDefaultRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ContextSetDefaultRequest
     */
    'is_default': boolean;
}
/**
 * 
 * @export
 * @interface ContextStoreRequest
 */
export interface ContextStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ContextStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ContextStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ContextStoreRequest
     */
    'is_default'?: boolean;
}
/**
 * 
 * @export
 * @interface CountryIndex200Response
 */
export interface CountryIndex200Response {
    /**
     * 
     * @type {Array<CountryResource>}
     * @memberof CountryIndex200Response
     */
    'data': Array<CountryResource>;
}
/**
 * 
 * @export
 * @interface CountryResource
 */
export interface CountryResource {
    /**
     * The unique identifier of the country (ISO 3166-1 alpha-3 code)
     * @type {string}
     * @memberof CountryResource
     */
    'id': string;
    /**
     * The name of the country, it shall only be used internally
     * @type {string}
     * @memberof CountryResource
     */
    'internal_name': string;
    /**
     * The legacy Id when this country corresponds to a legacy country from the MWNF3 database, nullable
     * @type {string}
     * @memberof CountryResource
     */
    'backward_compatibility': string | null;
    /**
     * Date of creation
     * @type {string}
     * @memberof CountryResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof CountryResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface CountryStore200Response
 */
export interface CountryStore200Response {
    /**
     * 
     * @type {CountryResource}
     * @memberof CountryStore200Response
     */
    'data': CountryResource;
}
/**
 * 
 * @export
 * @interface CountryStoreRequest
 */
export interface CountryStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof CountryStoreRequest
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CountryStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof CountryStoreRequest
     */
    'backward_compatibility'?: string | null;
}
/**
 * 
 * @export
 * @interface CountryUpdateRequest
 */
export interface CountryUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof CountryUpdateRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof CountryUpdateRequest
     */
    'backward_compatibility'?: string | null;
}
/**
 * 
 * @export
 * @interface DetailIndex200Response
 */
export interface DetailIndex200Response {
    /**
     * 
     * @type {Array<DetailResource>}
     * @memberof DetailIndex200Response
     */
    'data': Array<DetailResource>;
}
/**
 * 
 * @export
 * @interface DetailResource
 */
export interface DetailResource {
    /**
     * The unique identifier of the item (GUID)
     * @type {string}
     * @memberof DetailResource
     */
    'id': string;
    /**
     * The name of the item, it shall only be used internally
     * @type {string}
     * @memberof DetailResource
     */
    'internal_name': string;
    /**
     * The item this detail belongs to
     * @type {ItemResource}
     * @memberof DetailResource
     */
    'item'?: ItemResource;
    /**
     * The legacy Id when this item corresponds to a legacy item from the MWNF3 database, nullable
     * @type {string}
     * @memberof DetailResource
     */
    'backward_compatibility': string | null;
    /**
     * Translations for this detail (internationalization and contextualization)
     * @type {Array<DetailTranslationResource>}
     * @memberof DetailResource
     */
    'translations'?: Array<DetailTranslationResource>;
    /**
     * Date of creation
     * @type {string}
     * @memberof DetailResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof DetailResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface DetailStore200Response
 */
export interface DetailStore200Response {
    /**
     * 
     * @type {DetailResource}
     * @memberof DetailStore200Response
     */
    'data': DetailResource;
}
/**
 * 
 * @export
 * @interface DetailStoreRequest
 */
export interface DetailStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof DetailStoreRequest
     */
    'item_id': string;
    /**
     * 
     * @type {string}
     * @memberof DetailStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof DetailStoreRequest
     */
    'backward_compatibility'?: string | null;
}
/**
 * 
 * @export
 * @interface DetailTranslationResource
 */
export interface DetailTranslationResource {
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'detail_id': string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'context_id': string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'alternate_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'author_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'text_copy_editor_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'translator_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'translation_copy_editor_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'backward_compatibility': string | null;
    /**
     * 
     * @type {Array<any>}
     * @memberof DetailTranslationResource
     */
    'extra': Array<any> | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationResource
     */
    'updated_at': string | null;
    /**
     * Relationship data
     * @type {DetailResource}
     * @memberof DetailTranslationResource
     */
    'detail'?: DetailResource;
    /**
     * 
     * @type {LanguageResource}
     * @memberof DetailTranslationResource
     */
    'language'?: LanguageResource;
    /**
     * 
     * @type {ContextResource}
     * @memberof DetailTranslationResource
     */
    'context'?: ContextResource;
    /**
     * 
     * @type {AuthorResource}
     * @memberof DetailTranslationResource
     */
    'author'?: AuthorResource;
    /**
     * 
     * @type {AuthorResource}
     * @memberof DetailTranslationResource
     */
    'text_copy_editor'?: AuthorResource;
    /**
     * 
     * @type {AuthorResource}
     * @memberof DetailTranslationResource
     */
    'translator'?: AuthorResource;
    /**
     * 
     * @type {AuthorResource}
     * @memberof DetailTranslationResource
     */
    'translation_copy_editor'?: AuthorResource;
}
/**
 * 
 * @export
 * @interface DetailTranslationShow200Response
 */
export interface DetailTranslationShow200Response {
    /**
     * 
     * @type {DetailTranslationResource}
     * @memberof DetailTranslationShow200Response
     */
    'data': DetailTranslationResource;
}
/**
 * 
 * @export
 * @interface DetailTranslationStoreRequest
 */
export interface DetailTranslationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationStoreRequest
     */
    'detail_id': string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationStoreRequest
     */
    'context_id': string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationStoreRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationStoreRequest
     */
    'alternate_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationStoreRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationStoreRequest
     */
    'author_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationStoreRequest
     */
    'text_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationStoreRequest
     */
    'translator_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationStoreRequest
     */
    'translation_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof DetailTranslationStoreRequest
     */
    'extra'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface DetailTranslationUpdateRequest
 */
export interface DetailTranslationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationUpdateRequest
     */
    'detail_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationUpdateRequest
     */
    'context_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationUpdateRequest
     */
    'alternate_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationUpdateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationUpdateRequest
     */
    'author_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationUpdateRequest
     */
    'text_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationUpdateRequest
     */
    'translator_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationUpdateRequest
     */
    'translation_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationUpdateRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof DetailTranslationUpdateRequest
     */
    'extra'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface ImageUploadIndex200Response
 */
export interface ImageUploadIndex200Response {
    /**
     * 
     * @type {Array<ImageUploadResource>}
     * @memberof ImageUploadIndex200Response
     */
    'data': Array<ImageUploadResource>;
}
/**
 * 
 * @export
 * @interface ImageUploadResource
 */
export interface ImageUploadResource {
    /**
     * The unique identifier of the picture (GUID)
     * @type {string}
     * @memberof ImageUploadResource
     */
    'id': string;
    /**
     * The path to the picture file
     * @type {string}
     * @memberof ImageUploadResource
     */
    'path': string | null;
    /**
     * The original name of the uploaded file
     * @type {string}
     * @memberof ImageUploadResource
     */
    'name': string | null;
    /**
     * The file extension of the uploaded file
     * @type {string}
     * @memberof ImageUploadResource
     */
    'extension': string | null;
    /**
     * The MIME type of the uploaded file
     * @type {string}
     * @memberof ImageUploadResource
     */
    'mime_type': string | null;
    /**
     * The size of the uploaded file in bytes
     * @type {number}
     * @memberof ImageUploadResource
     */
    'size': number | null;
    /**
     * Date of creation
     * @type {string}
     * @memberof ImageUploadResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof ImageUploadResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ImageUploadStore200Response
 */
export interface ImageUploadStore200Response {
    /**
     * 
     * @type {ImageUploadResource}
     * @memberof ImageUploadStore200Response
     */
    'data': ImageUploadResource;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * Errors overview.
     * @type {string}
     * @memberof InlineObject
     */
    'message': string;
    /**
     * A detailed description of each field that failed validation.
     * @type {{ [key: string]: Array<string>; }}
     * @memberof InlineObject
     */
    'errors': { [key: string]: Array<string>; };
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * Error overview.
     * @type {string}
     * @memberof InlineObject1
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ItemIndex200Response
 */
export interface ItemIndex200Response {
    /**
     * 
     * @type {Array<ItemResource>}
     * @memberof ItemIndex200Response
     */
    'data': Array<ItemResource>;
}
/**
 * 
 * @export
 * @interface ItemResource
 */
export interface ItemResource {
    /**
     * The unique identifier of the item (GUID)
     * @type {string}
     * @memberof ItemResource
     */
    'id': string;
    /**
     * The name of the item, it shall only be used internally
     * @type {string}
     * @memberof ItemResource
     */
    'internal_name': string;
    /**
     * The legacy Id when this item corresponds to a legacy item from the MWNF3 database, nullable
     * @type {string}
     * @memberof ItemResource
     */
    'backward_compatibility': string | null;
    /**
     * The type of the item, either \'object\' or \'monument\'
     * @type {string}
     * @memberof ItemResource
     */
    'type': string;
    /**
     * Owner\'s reference number for the item
     * @type {string}
     * @memberof ItemResource
     */
    'owner_reference': string | null;
    /**
     * MWNF reference number for the item
     * @type {string}
     * @memberof ItemResource
     */
    'mwnf_reference': string | null;
    /**
     * The partner owning the item
     * @type {PartnerResource}
     * @memberof ItemResource
     */
    'partner'?: PartnerResource;
    /**
     * The project this item belongs to, nullable
     * @type {ProjectResource}
     * @memberof ItemResource
     */
    'project'?: ProjectResource;
    /**
     * The country this item is associated with, nullable
     * @type {CountryResource}
     * @memberof ItemResource
     */
    'country'?: CountryResource;
    /**
     * Artists associated with this item
     * @type {Array<ArtistResource>}
     * @memberof ItemResource
     */
    'artists': Array<ArtistResource>;
    /**
     * Workshops associated with this item
     * @type {Array<WorkshopResource>}
     * @memberof ItemResource
     */
    'workshops': Array<WorkshopResource>;
    /**
     * Tags associated with this item
     * @type {Array<TagResource>}
     * @memberof ItemResource
     */
    'tags'?: Array<TagResource>;
    /**
     * Translations for this item (internationalization and contextualization)
     * @type {Array<ItemTranslationResource>}
     * @memberof ItemResource
     */
    'translations'?: Array<ItemTranslationResource>;
    /**
     * Date of creation
     * @type {string}
     * @memberof ItemResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof ItemResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ItemStore200Response
 */
export interface ItemStore200Response {
    /**
     * 
     * @type {ItemResource}
     * @memberof ItemStore200Response
     */
    'data': ItemResource;
}
/**
 * 
 * @export
 * @interface ItemStoreRequest
 */
export interface ItemStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemStoreRequest
     */
    'partner_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ItemStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemStoreRequest
     */
    'type': ItemStoreRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ItemStoreRequest
     */
    'country_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemStoreRequest
     */
    'project_id'?: string | null;
}

export const ItemStoreRequestTypeEnum = {
    Object: 'object',
    Monument: 'monument'
} as const;

export type ItemStoreRequestTypeEnum = typeof ItemStoreRequestTypeEnum[keyof typeof ItemStoreRequestTypeEnum];

/**
 * 
 * @export
 * @interface ItemTranslationResource
 */
export interface ItemTranslationResource {
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'item_id': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'context_id': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'alternate_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'type': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'holder': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'owner': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'initial_owner': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'dates': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'location': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'dimensions': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'place_of_production': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'method_for_datation': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'method_for_provenance': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'obtention': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'bibliography': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'author_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'text_copy_editor_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'translator_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'translation_copy_editor_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'backward_compatibility': string | null;
    /**
     * 
     * @type {Array<any>}
     * @memberof ItemTranslationResource
     */
    'extra': Array<any> | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'updated_at': string | null;
    /**
     * Relationship data
     * @type {ItemResource}
     * @memberof ItemTranslationResource
     */
    'item'?: ItemResource;
    /**
     * 
     * @type {LanguageResource}
     * @memberof ItemTranslationResource
     */
    'language'?: LanguageResource;
    /**
     * 
     * @type {ContextResource}
     * @memberof ItemTranslationResource
     */
    'context'?: ContextResource;
    /**
     * 
     * @type {AuthorResource}
     * @memberof ItemTranslationResource
     */
    'author'?: AuthorResource;
    /**
     * 
     * @type {AuthorResource}
     * @memberof ItemTranslationResource
     */
    'text_copy_editor'?: AuthorResource;
    /**
     * 
     * @type {AuthorResource}
     * @memberof ItemTranslationResource
     */
    'translator'?: AuthorResource;
    /**
     * 
     * @type {AuthorResource}
     * @memberof ItemTranslationResource
     */
    'translation_copy_editor'?: AuthorResource;
}
/**
 * 
 * @export
 * @interface ItemTranslationShow200Response
 */
export interface ItemTranslationShow200Response {
    /**
     * 
     * @type {ItemTranslationResource}
     * @memberof ItemTranslationShow200Response
     */
    'data': ItemTranslationResource;
}
/**
 * 
 * @export
 * @interface ItemTranslationStoreRequest
 */
export interface ItemTranslationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'item_id': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'context_id': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'alternate_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'holder'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'owner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'initial_owner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'dates'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'location'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'dimensions'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'place_of_production'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'method_for_datation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'method_for_provenance'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'obtention'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'bibliography'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'author_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'text_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'translator_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'translation_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemTranslationStoreRequest
     */
    'extra'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface ItemTranslationUpdateRequest
 */
export interface ItemTranslationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'item_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'context_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'alternate_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'holder'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'owner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'initial_owner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'dates'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'location'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'dimensions'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'place_of_production'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'method_for_datation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'method_for_provenance'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'obtention'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'bibliography'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'author_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'text_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'translator_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'translation_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemTranslationUpdateRequest
     */
    'extra'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface ItemUpdateTagsRequest
 */
export interface ItemUpdateTagsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemUpdateTagsRequest
     */
    'attach'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemUpdateTagsRequest
     */
    'detach'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ItemWithAllTagsRequest
 */
export interface ItemWithAllTagsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemWithAllTagsRequest
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface LanguageGetDefault404Response
 */
export interface LanguageGetDefault404Response {
    /**
     * 
     * @type {string}
     * @memberof LanguageGetDefault404Response
     */
    'message': LanguageGetDefault404ResponseMessageEnum;
}

export const LanguageGetDefault404ResponseMessageEnum = {
    NoDefaultLanguageFound: 'No default language found'
} as const;

export type LanguageGetDefault404ResponseMessageEnum = typeof LanguageGetDefault404ResponseMessageEnum[keyof typeof LanguageGetDefault404ResponseMessageEnum];

/**
 * 
 * @export
 * @interface LanguageGetEnglish404Response
 */
export interface LanguageGetEnglish404Response {
    /**
     * 
     * @type {string}
     * @memberof LanguageGetEnglish404Response
     */
    'message': LanguageGetEnglish404ResponseMessageEnum;
}

export const LanguageGetEnglish404ResponseMessageEnum = {
    NoEnglishLanguageFound: 'No English language found'
} as const;

export type LanguageGetEnglish404ResponseMessageEnum = typeof LanguageGetEnglish404ResponseMessageEnum[keyof typeof LanguageGetEnglish404ResponseMessageEnum];

/**
 * 
 * @export
 * @interface LanguageIndex200Response
 */
export interface LanguageIndex200Response {
    /**
     * 
     * @type {Array<LanguageResource>}
     * @memberof LanguageIndex200Response
     */
    'data': Array<LanguageResource>;
}
/**
 * 
 * @export
 * @interface LanguageResource
 */
export interface LanguageResource {
    /**
     * The unique identifier of the language (ISO 639-1 code)
     * @type {string}
     * @memberof LanguageResource
     */
    'id': string;
    /**
     * The name of the language, it shall only be used internally
     * @type {string}
     * @memberof LanguageResource
     */
    'internal_name': string;
    /**
     * The legacy Id when this language corresponds to a legacy language from the MWNF3 database, nullable
     * @type {string}
     * @memberof LanguageResource
     */
    'backward_compatibility': string | null;
    /**
     * Indicates if this language is the default one. There is one single default language for the entire database.
     * @type {boolean}
     * @memberof LanguageResource
     */
    'is_default': boolean;
    /**
     * Date of creation
     * @type {string}
     * @memberof LanguageResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof LanguageResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface LanguageSetDefault200Response
 */
export interface LanguageSetDefault200Response {
    /**
     * 
     * @type {LanguageResource}
     * @memberof LanguageSetDefault200Response
     */
    'data': LanguageResource;
}
/**
 * 
 * @export
 * @interface LanguageStoreRequest
 */
export interface LanguageStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof LanguageStoreRequest
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LanguageStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof LanguageStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof LanguageStoreRequest
     */
    'is_default'?: boolean;
}
/**
 * 
 * @export
 * @interface LanguageUpdateRequest
 */
export interface LanguageUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof LanguageUpdateRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof LanguageUpdateRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof LanguageUpdateRequest
     */
    'is_default'?: boolean;
}
/**
 * 
 * @export
 * @interface LocationIndex200Response
 */
export interface LocationIndex200Response {
    /**
     * 
     * @type {Array<LocationResource>}
     * @memberof LocationIndex200Response
     */
    'data': Array<LocationResource>;
}
/**
 * 
 * @export
 * @interface LocationResource
 */
export interface LocationResource {
    /**
     * 
     * @type {string}
     * @memberof LocationResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LocationResource
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof LocationResource
     */
    'country_id': string;
    /**
     * 
     * @type {Array<LocationTranslationResource>}
     * @memberof LocationResource
     */
    'translations'?: Array<LocationTranslationResource>;
    /**
     * 
     * @type {string}
     * @memberof LocationResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof LocationResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface LocationStore201Response
 */
export interface LocationStore201Response {
    /**
     * 
     * @type {LocationResource}
     * @memberof LocationStore201Response
     */
    'data': LocationResource;
}
/**
 * 
 * @export
 * @interface LocationStoreRequest
 */
export interface LocationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof LocationStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {number}
     * @memberof LocationStoreRequest
     */
    'country_id': number;
    /**
     * 
     * @type {Array<LocationStoreRequestTranslationsInner>}
     * @memberof LocationStoreRequest
     */
    'translations': Array<LocationStoreRequestTranslationsInner>;
}
/**
 * 
 * @export
 * @interface LocationStoreRequestTranslationsInner
 */
export interface LocationStoreRequestTranslationsInner {
    /**
     * 
     * @type {number}
     * @memberof LocationStoreRequestTranslationsInner
     */
    'language_id': number;
    /**
     * 
     * @type {string}
     * @memberof LocationStoreRequestTranslationsInner
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface LocationTranslationIndex200Response
 */
export interface LocationTranslationIndex200Response {
    /**
     * 
     * @type {Array<LocationTranslationResource>}
     * @memberof LocationTranslationIndex200Response
     */
    'data': Array<LocationTranslationResource>;
}
/**
 * 
 * @export
 * @interface LocationTranslationResource
 */
export interface LocationTranslationResource {
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationResource
     */
    'location_id': string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationResource
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationResource
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface LocationTranslationStore200Response
 */
export interface LocationTranslationStore200Response {
    /**
     * 
     * @type {LocationTranslationResource}
     * @memberof LocationTranslationStore200Response
     */
    'data': LocationTranslationResource;
}
/**
 * 
 * @export
 * @interface LocationTranslationStoreRequest
 */
export interface LocationTranslationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationStoreRequest
     */
    'location_id': string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationStoreRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationStoreRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface LocationTranslationUpdateRequest
 */
export interface LocationTranslationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationUpdateRequest
     */
    'location_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationUpdateRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface LocationUpdateRequest
 */
export interface LocationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof LocationUpdateRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {number}
     * @memberof LocationUpdateRequest
     */
    'country_id': number;
    /**
     * 
     * @type {Array<LocationUpdateRequestTranslationsInner>}
     * @memberof LocationUpdateRequest
     */
    'translations'?: Array<LocationUpdateRequestTranslationsInner>;
}
/**
 * 
 * @export
 * @interface LocationUpdateRequestTranslationsInner
 */
export interface LocationUpdateRequestTranslationsInner {
    /**
     * 
     * @type {number}
     * @memberof LocationUpdateRequestTranslationsInner
     */
    'language_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof LocationUpdateRequestTranslationsInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface MarkdownFromHtmlRequest
 */
export interface MarkdownFromHtmlRequest {
    /**
     * 
     * @type {string}
     * @memberof MarkdownFromHtmlRequest
     */
    'html': string;
}
/**
 * 
 * @export
 * @interface MarkdownIsMarkdownRequest
 */
export interface MarkdownIsMarkdownRequest {
    /**
     * 
     * @type {string}
     * @memberof MarkdownIsMarkdownRequest
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface MarkdownPreview200Response
 */
export interface MarkdownPreview200Response {
    /**
     * 
     * @type {boolean}
     * @memberof MarkdownPreview200Response
     */
    'success': boolean;
    /**
     * 
     * @type {MarkdownPreview200ResponseData}
     * @memberof MarkdownPreview200Response
     */
    'data': MarkdownPreview200ResponseData;
}
/**
 * 
 * @export
 * @interface MarkdownPreview200ResponseData
 */
export interface MarkdownPreview200ResponseData {
    /**
     * 
     * @type {string}
     * @memberof MarkdownPreview200ResponseData
     */
    'html': string;
}
/**
 * 
 * @export
 * @interface MarkdownPreview422Response
 */
export interface MarkdownPreview422Response {
    /**
     * 
     * @type {boolean}
     * @memberof MarkdownPreview422Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof MarkdownPreview422Response
     */
    'message': MarkdownPreview422ResponseMessageEnum;
    /**
     * 
     * @type {string}
     * @memberof MarkdownPreview422Response
     */
    'errors': string;
}

export const MarkdownPreview422ResponseMessageEnum = {
    ValidationFailed: 'Validation failed'
} as const;

export type MarkdownPreview422ResponseMessageEnum = typeof MarkdownPreview422ResponseMessageEnum[keyof typeof MarkdownPreview422ResponseMessageEnum];

/**
 * 
 * @export
 * @interface MarkdownPreview500Response
 */
export interface MarkdownPreview500Response {
    /**
     * 
     * @type {boolean}
     * @memberof MarkdownPreview500Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof MarkdownPreview500Response
     */
    'message': MarkdownPreview500ResponseMessageEnum;
    /**
     * 
     * @type {string}
     * @memberof MarkdownPreview500Response
     */
    'error': string;
}

export const MarkdownPreview500ResponseMessageEnum = {
    FailedToConvertMarkdownToHtml: 'Failed to convert markdown to HTML'
} as const;

export type MarkdownPreview500ResponseMessageEnum = typeof MarkdownPreview500ResponseMessageEnum[keyof typeof MarkdownPreview500ResponseMessageEnum];

/**
 * 
 * @export
 * @interface MarkdownToHtmlRequest
 */
export interface MarkdownToHtmlRequest {
    /**
     * 
     * @type {string}
     * @memberof MarkdownToHtmlRequest
     */
    'markdown': string;
}
/**
 * 
 * @export
 * @interface PartnerIndex200Response
 */
export interface PartnerIndex200Response {
    /**
     * 
     * @type {Array<PartnerResource>}
     * @memberof PartnerIndex200Response
     */
    'data': Array<PartnerResource>;
}
/**
 * 
 * @export
 * @interface PartnerResource
 */
export interface PartnerResource {
    /**
     * The unique identifier of the partner (GUID)
     * @type {string}
     * @memberof PartnerResource
     */
    'id': string;
    /**
     * The name of the partner, it shall only be used internally
     * @type {string}
     * @memberof PartnerResource
     */
    'internal_name': string;
    /**
     * The legacy Id when this partner corresponds to a legacy partner from the MWNF3 database, nullable
     * @type {string}
     * @memberof PartnerResource
     */
    'backward_compatibility': string | null;
    /**
     * The type of the partner, either \'museum\',  \'institution\' or \'individual\'
     * @type {string}
     * @memberof PartnerResource
     */
    'type': string;
    /**
     * The country this partner is associated with, nullable
     * @type {CountryResource}
     * @memberof PartnerResource
     */
    'country'?: CountryResource;
    /**
     * Date of creation
     * @type {string}
     * @memberof PartnerResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof PartnerResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface PartnerStore200Response
 */
export interface PartnerStore200Response {
    /**
     * 
     * @type {PartnerResource}
     * @memberof PartnerStore200Response
     */
    'data': PartnerResource;
}
/**
 * 
 * @export
 * @interface PartnerStoreRequest
 */
export interface PartnerStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof PartnerStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof PartnerStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartnerStoreRequest
     */
    'type': PartnerStoreRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PartnerStoreRequest
     */
    'country_id'?: string | null;
}

export const PartnerStoreRequestTypeEnum = {
    Museum: 'museum',
    Institution: 'institution',
    Individual: 'individual'
} as const;

export type PartnerStoreRequestTypeEnum = typeof PartnerStoreRequestTypeEnum[keyof typeof PartnerStoreRequestTypeEnum];

/**
 * 
 * @export
 * @interface PictureDetachFromItem422Response
 */
export interface PictureDetachFromItem422Response {
    /**
     * 
     * @type {string}
     * @memberof PictureDetachFromItem422Response
     */
    'error': PictureDetachFromItem422ResponseErrorEnum;
}

export const PictureDetachFromItem422ResponseErrorEnum = {
    PictureDoesNotBelongToThisModel: 'Picture does not belong to this model'
} as const;

export type PictureDetachFromItem422ResponseErrorEnum = typeof PictureDetachFromItem422ResponseErrorEnum[keyof typeof PictureDetachFromItem422ResponseErrorEnum];

/**
 * 
 * @export
 * @interface PictureIndex200Response
 */
export interface PictureIndex200Response {
    /**
     * 
     * @type {Array<PictureResource>}
     * @memberof PictureIndex200Response
     */
    'data': Array<PictureResource>;
}
/**
 * 
 * @export
 * @interface PictureResource
 */
export interface PictureResource {
    /**
     * The unique identifier of the picture (UUID)
     * @type {string}
     * @memberof PictureResource
     */
    'id': string;
    /**
     * The internal name of the picture
     * @type {string}
     * @memberof PictureResource
     */
    'internal_name': string;
    /**
     * The legacy ID when this picture corresponds to a legacy image from the MWNF3 database, nullable
     * @type {string}
     * @memberof PictureResource
     */
    'backward_compatibility': string | null;
    /**
     * The path to the picture file
     * @type {string}
     * @memberof PictureResource
     */
    'path': string;
    /**
     * The copyright text associated with the picture
     * @type {string}
     * @memberof PictureResource
     */
    'copyright_text': string | null;
    /**
     * The URL for the copyright information
     * @type {string}
     * @memberof PictureResource
     */
    'copyright_url': string | null;
    /**
     * The original name of the uploaded file
     * @type {string}
     * @memberof PictureResource
     */
    'upload_name': string;
    /**
     * The file extension of the uploaded file
     * @type {string}
     * @memberof PictureResource
     */
    'upload_extension': string;
    /**
     * The MIME type of the uploaded file
     * @type {string}
     * @memberof PictureResource
     */
    'upload_mime_type': string;
    /**
     * The size of the uploaded file in bytes
     * @type {number}
     * @memberof PictureResource
     */
    'upload_size': number;
    /**
     * The type of the parent model (Item, Detail, Partner)
     * @type {string}
     * @memberof PictureResource
     */
    'pictureable_type': string;
    /**
     * The ID of the parent model
     * @type {string}
     * @memberof PictureResource
     */
    'pictureable_id': string;
    /**
     * Date of creation
     * @type {string}
     * @memberof PictureResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof PictureResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface PictureShow200Response
 */
export interface PictureShow200Response {
    /**
     * 
     * @type {PictureResource}
     * @memberof PictureShow200Response
     */
    'data': PictureResource;
}
/**
 * 
 * @export
 * @interface PictureUpdateRequest
 */
export interface PictureUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof PictureUpdateRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof PictureUpdateRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PictureUpdateRequest
     */
    'copyright_text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PictureUpdateRequest
     */
    'copyright_url'?: string | null;
}
/**
 * 
 * @export
 * @interface ProjectEnabled200Response
 */
export interface ProjectEnabled200Response {
    /**
     * 
     * @type {Array<ProjectResource>}
     * @memberof ProjectEnabled200Response
     */
    'data': Array<ProjectResource>;
}
/**
 * 
 * @export
 * @interface ProjectResource
 */
export interface ProjectResource {
    /**
     * The unique identifier of the project (GUID)
     * @type {string}
     * @memberof ProjectResource
     */
    'id': string;
    /**
     * The name of the project, it shall only be used internally
     * @type {string}
     * @memberof ProjectResource
     */
    'internal_name': string;
    /**
     * The legacy Id when this project corresponds to a legacy project from the MWNF3 database, nullable
     * @type {string}
     * @memberof ProjectResource
     */
    'backward_compatibility': string | null;
    /**
     * Launch date of the project, nullable
     * @type {string}
     * @memberof ProjectResource
     */
    'launch_date': string | null;
    /**
     * Indicates if the project has been launched already
     * @type {boolean}
     * @memberof ProjectResource
     */
    'is_launched': boolean;
    /**
     * Indicates if the project is enabled (active)
     * @type {boolean}
     * @memberof ProjectResource
     */
    'is_enabled': boolean;
    /**
     * The default context used within the project
     * @type {ContextResource}
     * @memberof ProjectResource
     */
    'context'?: ContextResource;
    /**
     * The default language used within the project
     * @type {LanguageResource}
     * @memberof ProjectResource
     */
    'language'?: LanguageResource;
    /**
     * Date of creation
     * @type {string}
     * @memberof ProjectResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof ProjectResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ProjectSetEnabledRequest
 */
export interface ProjectSetEnabledRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ProjectSetEnabledRequest
     */
    'is_enabled': boolean;
}
/**
 * 
 * @export
 * @interface ProjectSetLaunched200Response
 */
export interface ProjectSetLaunched200Response {
    /**
     * 
     * @type {ProjectResource}
     * @memberof ProjectSetLaunched200Response
     */
    'data': ProjectResource;
}
/**
 * 
 * @export
 * @interface ProjectSetLaunchedRequest
 */
export interface ProjectSetLaunchedRequest {
    /**
     * 
     * @type {string}
     * @memberof ProjectSetLaunchedRequest
     */
    'launch_date'?: string | null;
}
/**
 * 
 * @export
 * @interface ProjectStoreRequest
 */
export interface ProjectStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ProjectStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProjectStoreRequest
     */
    'launch_date'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectStoreRequest
     */
    'is_launched'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectStoreRequest
     */
    'is_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectStoreRequest
     */
    'context_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProjectStoreRequest
     */
    'language_id'?: string | null;
}
/**
 * 
 * @export
 * @interface ProvinceIndex200Response
 */
export interface ProvinceIndex200Response {
    /**
     * 
     * @type {Array<ProvinceResource>}
     * @memberof ProvinceIndex200Response
     */
    'data': Array<ProvinceResource>;
}
/**
 * 
 * @export
 * @interface ProvinceResource
 */
export interface ProvinceResource {
    /**
     * 
     * @type {string}
     * @memberof ProvinceResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceResource
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceResource
     */
    'country_id': string;
    /**
     * 
     * @type {Array<ProvinceTranslationResource>}
     * @memberof ProvinceResource
     */
    'translations'?: Array<ProvinceTranslationResource>;
    /**
     * 
     * @type {string}
     * @memberof ProvinceResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof ProvinceResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ProvinceStore201Response
 */
export interface ProvinceStore201Response {
    /**
     * 
     * @type {ProvinceResource}
     * @memberof ProvinceStore201Response
     */
    'data': ProvinceResource;
}
/**
 * 
 * @export
 * @interface ProvinceTranslationIndex200Response
 */
export interface ProvinceTranslationIndex200Response {
    /**
     * 
     * @type {Array<ProvinceTranslationResource>}
     * @memberof ProvinceTranslationIndex200Response
     */
    'data': Array<ProvinceTranslationResource>;
}
/**
 * 
 * @export
 * @interface ProvinceTranslationResource
 */
export interface ProvinceTranslationResource {
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationResource
     */
    'province_id': string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationResource
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationResource
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ProvinceTranslationStore200Response
 */
export interface ProvinceTranslationStore200Response {
    /**
     * 
     * @type {ProvinceTranslationResource}
     * @memberof ProvinceTranslationStore200Response
     */
    'data': ProvinceTranslationResource;
}
/**
 * 
 * @export
 * @interface ProvinceTranslationStoreRequest
 */
export interface ProvinceTranslationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationStoreRequest
     */
    'province_id': string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationStoreRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationStoreRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface ProvinceTranslationUpdateRequest
 */
export interface ProvinceTranslationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationUpdateRequest
     */
    'province_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationUpdateRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface TagIndex200Response
 */
export interface TagIndex200Response {
    /**
     * 
     * @type {Array<TagResource>}
     * @memberof TagIndex200Response
     */
    'data': Array<TagResource>;
}
/**
 * 
 * @export
 * @interface TagResource
 */
export interface TagResource {
    /**
     * The unique identifier of the tag (GUID)
     * @type {string}
     * @memberof TagResource
     */
    'id': string;
    /**
     * The name of the tag, it shall only be used internally
     * @type {string}
     * @memberof TagResource
     */
    'internal_name': string;
    /**
     * The legacy Id when this tag corresponds to a legacy tag from the previous database, nullable
     * @type {string}
     * @memberof TagResource
     */
    'backward_compatibility': string | null;
    /**
     * The description of the tag
     * @type {string}
     * @memberof TagResource
     */
    'description': string;
    /**
     * Date of creation
     * @type {string}
     * @memberof TagResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof TagResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface TagStore200Response
 */
export interface TagStore200Response {
    /**
     * 
     * @type {TagResource}
     * @memberof TagStore200Response
     */
    'data': TagResource;
}
/**
 * 
 * @export
 * @interface TagStoreRequest
 */
export interface TagStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof TagStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof TagStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TagStoreRequest
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface TokenAcquireRequest
 */
export interface TokenAcquireRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenAcquireRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TokenAcquireRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof TokenAcquireRequest
     */
    'device_name': string;
    /**
     * 
     * @type {boolean}
     * @memberof TokenAcquireRequest
     */
    'wipe_tokens'?: boolean;
}
/**
 * 
 * @export
 * @interface WorkshopResource
 */
export interface WorkshopResource {
    /**
     * 
     * @type {string}
     * @memberof WorkshopResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopResource
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopResource
     */
    'backward_compatibility': string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkshopResource
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkshopResource
     */
    'updated_at': string | null;
    /**
     * 
     * @type {Array<ItemResource>}
     * @memberof WorkshopResource
     */
    'items'?: Array<ItemResource>;
}

/**
 * AddressApi - axios parameter creator
 * @export
 */
export const AddressApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified address
         * @param {string} address The address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressDestroy: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addressDestroy', 'address', address)
            const localVarPath = `/address/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified address
         * @param {string} address The address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressShow: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addressShow', 'address', address)
            const localVarPath = `/address/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created address
         * @param {AddressStoreRequest} addressStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressStore: async (addressStoreRequest: AddressStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressStoreRequest' is not null or undefined
            assertParamExists('addressStore', 'addressStoreRequest', addressStoreRequest)
            const localVarPath = `/address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified address
         * @param {string} address The address ID
         * @param {AddressUpdateRequest} addressUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUpdate: async (address: string, addressUpdateRequest: AddressUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addressUpdate', 'address', address)
            // verify required parameter 'addressUpdateRequest' is not null or undefined
            assertParamExists('addressUpdate', 'addressUpdateRequest', addressUpdateRequest)
            const localVarPath = `/address/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressApi - functional programming interface
 * @export
 */
export const AddressApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified address
         * @param {string} address The address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressDestroy(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressDestroy(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.addressDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.addressIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified address
         * @param {string} address The address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressShow(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressShow(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.addressShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created address
         * @param {AddressStoreRequest} addressStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressStore(addressStoreRequest: AddressStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressStore(addressStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.addressStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified address
         * @param {string} address The address ID
         * @param {AddressUpdateRequest} addressUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressUpdate(address: string, addressUpdateRequest: AddressUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressUpdate(address, addressUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.addressUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AddressApi - factory interface
 * @export
 */
export const AddressApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified address
         * @param {string} address The address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressDestroy(address: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addressDestroy(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressIndex(options?: RawAxiosRequestConfig): AxiosPromise<AddressIndex200Response> {
            return localVarFp.addressIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified address
         * @param {string} address The address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressShow(address: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressStore201Response> {
            return localVarFp.addressShow(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created address
         * @param {AddressStoreRequest} addressStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressStore(addressStoreRequest: AddressStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddressStore201Response> {
            return localVarFp.addressStore(addressStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified address
         * @param {string} address The address ID
         * @param {AddressUpdateRequest} addressUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUpdate(address: string, addressUpdateRequest: AddressUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddressStore201Response> {
            return localVarFp.addressUpdate(address, addressUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressApi - object-oriented interface
 * @export
 * @class AddressApi
 * @extends {BaseAPI}
 */
export class AddressApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified address
     * @param {string} address The address ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressDestroy(address: string, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).addressDestroy(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressIndex(options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).addressIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified address
     * @param {string} address The address ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressShow(address: string, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).addressShow(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created address
     * @param {AddressStoreRequest} addressStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressStore(addressStoreRequest: AddressStoreRequest, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).addressStore(addressStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified address
     * @param {string} address The address ID
     * @param {AddressUpdateRequest} addressUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressUpdate(address: string, addressUpdateRequest: AddressUpdateRequest, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).addressUpdate(address, addressUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AddressTranslationApi - axios parameter creator
 * @export
 */
export const AddressTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationDestroy: async (addressTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressTranslation' is not null or undefined
            assertParamExists('addressTranslationDestroy', 'addressTranslation', addressTranslation)
            const localVarPath = `/address-translation/{addressTranslation}`
                .replace(`{${"addressTranslation"}}`, encodeURIComponent(String(addressTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/address-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationShow: async (addressTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressTranslation' is not null or undefined
            assertParamExists('addressTranslationShow', 'addressTranslation', addressTranslation)
            const localVarPath = `/address-translation/{addressTranslation}`
                .replace(`{${"addressTranslation"}}`, encodeURIComponent(String(addressTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {AddressTranslationStoreRequest} addressTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationStore: async (addressTranslationStoreRequest: AddressTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressTranslationStoreRequest' is not null or undefined
            assertParamExists('addressTranslationStore', 'addressTranslationStoreRequest', addressTranslationStoreRequest)
            const localVarPath = `/address-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} addressTranslation The address translation ID
         * @param {AddressTranslationUpdateRequest} [addressTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationUpdate: async (addressTranslation: string, addressTranslationUpdateRequest?: AddressTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressTranslation' is not null or undefined
            assertParamExists('addressTranslationUpdate', 'addressTranslation', addressTranslation)
            const localVarPath = `/address-translation/{addressTranslation}`
                .replace(`{${"addressTranslation"}}`, encodeURIComponent(String(addressTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressTranslationApi - functional programming interface
 * @export
 */
export const AddressTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressTranslationDestroy(addressTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressTranslationDestroy(addressTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressTranslationApi.addressTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressTranslationApi.addressTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressTranslationShow(addressTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressTranslationShow(addressTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressTranslationApi.addressTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {AddressTranslationStoreRequest} addressTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressTranslationStore(addressTranslationStoreRequest: AddressTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressTranslationStore(addressTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressTranslationApi.addressTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} addressTranslation The address translation ID
         * @param {AddressTranslationUpdateRequest} [addressTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressTranslationUpdate(addressTranslation: string, addressTranslationUpdateRequest?: AddressTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressTranslationUpdate(addressTranslation, addressTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressTranslationApi.addressTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AddressTranslationApi - factory interface
 * @export
 */
export const AddressTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationDestroy(addressTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addressTranslationDestroy(addressTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<AddressTranslationIndex200Response> {
            return localVarFp.addressTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationShow(addressTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressTranslationStore200Response> {
            return localVarFp.addressTranslationShow(addressTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {AddressTranslationStoreRequest} addressTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationStore(addressTranslationStoreRequest: AddressTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddressTranslationStore200Response> {
            return localVarFp.addressTranslationStore(addressTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} addressTranslation The address translation ID
         * @param {AddressTranslationUpdateRequest} [addressTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationUpdate(addressTranslation: string, addressTranslationUpdateRequest?: AddressTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddressTranslationStore200Response> {
            return localVarFp.addressTranslationUpdate(addressTranslation, addressTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressTranslationApi - object-oriented interface
 * @export
 * @class AddressTranslationApi
 * @extends {BaseAPI}
 */
export class AddressTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} addressTranslation The address translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressTranslationApi
     */
    public addressTranslationDestroy(addressTranslation: string, options?: RawAxiosRequestConfig) {
        return AddressTranslationApiFp(this.configuration).addressTranslationDestroy(addressTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressTranslationApi
     */
    public addressTranslationIndex(options?: RawAxiosRequestConfig) {
        return AddressTranslationApiFp(this.configuration).addressTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} addressTranslation The address translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressTranslationApi
     */
    public addressTranslationShow(addressTranslation: string, options?: RawAxiosRequestConfig) {
        return AddressTranslationApiFp(this.configuration).addressTranslationShow(addressTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {AddressTranslationStoreRequest} addressTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressTranslationApi
     */
    public addressTranslationStore(addressTranslationStoreRequest: AddressTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return AddressTranslationApiFp(this.configuration).addressTranslationStore(addressTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} addressTranslation The address translation ID
     * @param {AddressTranslationUpdateRequest} [addressTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressTranslationApi
     */
    public addressTranslationUpdate(addressTranslation: string, addressTranslationUpdateRequest?: AddressTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return AddressTranslationApiFp(this.configuration).addressTranslationUpdate(addressTranslation, addressTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AvailableImageApi - axios parameter creator
 * @export
 */
export const AvailableImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageDestroy: async (availableImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageDestroy', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageDownload: async (availableImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageDownload', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}/download`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/available-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageShow: async (availableImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageShow', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} availableImage The available image ID
         * @param {AvailableImageUpdateRequest} [availableImageUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageUpdate: async (availableImage: string, availableImageUpdateRequest?: AvailableImageUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageUpdate', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(availableImageUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageView: async (availableImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageView', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}/view`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AvailableImageApi - functional programming interface
 * @export
 */
export const AvailableImageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AvailableImageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageDestroy(availableImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageDestroy(availableImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageDownload(availableImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageDownload(availableImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageDownload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableImageIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageShow(availableImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageShow(availableImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} availableImage The available image ID
         * @param {AvailableImageUpdateRequest} [availableImageUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageUpdate(availableImage: string, availableImageUpdateRequest?: AvailableImageUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageUpdate(availableImage, availableImageUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageView(availableImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageView(availableImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AvailableImageApi - factory interface
 * @export
 */
export const AvailableImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AvailableImageApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageDestroy(availableImage: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.availableImageDestroy(availableImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageDownload(availableImage: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.availableImageDownload(availableImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageIndex(options?: RawAxiosRequestConfig): AxiosPromise<AvailableImageIndex200Response> {
            return localVarFp.availableImageIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageShow(availableImage: string, options?: RawAxiosRequestConfig): AxiosPromise<AvailableImageShow200Response> {
            return localVarFp.availableImageShow(availableImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} availableImage The available image ID
         * @param {AvailableImageUpdateRequest} [availableImageUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageUpdate(availableImage: string, availableImageUpdateRequest?: AvailableImageUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AvailableImageShow200Response> {
            return localVarFp.availableImageUpdate(availableImage, availableImageUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageView(availableImage: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.availableImageView(availableImage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AvailableImageApi - object-oriented interface
 * @export
 * @class AvailableImageApi
 * @extends {BaseAPI}
 */
export class AvailableImageApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} availableImage The available image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableImageApi
     */
    public availableImageDestroy(availableImage: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageDestroy(availableImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the file to the caller
     * @param {string} availableImage The available image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableImageApi
     */
    public availableImageDownload(availableImage: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageDownload(availableImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableImageApi
     */
    public availableImageIndex(options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} availableImage The available image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableImageApi
     */
    public availableImageShow(availableImage: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageShow(availableImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} availableImage The available image ID
     * @param {AvailableImageUpdateRequest} [availableImageUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableImageApi
     */
    public availableImageUpdate(availableImage: string, availableImageUpdateRequest?: AvailableImageUpdateRequest, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageUpdate(availableImage, availableImageUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
     * @param {string} availableImage The available image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableImageApi
     */
    public availableImageView(availableImage: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageView(availableImage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContactApi - axios parameter creator
 * @export
 */
export const ContactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified contact
         * @param {string} contact The contact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactDestroy: async (contact: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('contactDestroy', 'contact', contact)
            const localVarPath = `/contact/{contact}`
                .replace(`{${"contact"}}`, encodeURIComponent(String(contact)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified contact
         * @param {string} contact The contact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactShow: async (contact: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('contactShow', 'contact', contact)
            const localVarPath = `/contact/{contact}`
                .replace(`{${"contact"}}`, encodeURIComponent(String(contact)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created contact
         * @param {ContactStoreRequest} contactStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactStore: async (contactStoreRequest: ContactStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactStoreRequest' is not null or undefined
            assertParamExists('contactStore', 'contactStoreRequest', contactStoreRequest)
            const localVarPath = `/contact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified contact
         * @param {string} contact The contact ID
         * @param {ContactUpdateRequest} contactUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactUpdate: async (contact: string, contactUpdateRequest: ContactUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('contactUpdate', 'contact', contact)
            // verify required parameter 'contactUpdateRequest' is not null or undefined
            assertParamExists('contactUpdate', 'contactUpdateRequest', contactUpdateRequest)
            const localVarPath = `/contact/{contact}`
                .replace(`{${"contact"}}`, encodeURIComponent(String(contact)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactApi - functional programming interface
 * @export
 */
export const ContactApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified contact
         * @param {string} contact The contact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactDestroy(contact: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactDestroy(contact, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.contactDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.contactIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified contact
         * @param {string} contact The contact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactShow(contact: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactShow(contact, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.contactShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created contact
         * @param {ContactStoreRequest} contactStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactStore(contactStoreRequest: ContactStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactStore(contactStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.contactStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified contact
         * @param {string} contact The contact ID
         * @param {ContactUpdateRequest} contactUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactUpdate(contact: string, contactUpdateRequest: ContactUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactUpdate(contact, contactUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.contactUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactApi - factory interface
 * @export
 */
export const ContactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified contact
         * @param {string} contact The contact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactDestroy(contact: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.contactDestroy(contact, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactIndex(options?: RawAxiosRequestConfig): AxiosPromise<ContactIndex200Response> {
            return localVarFp.contactIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified contact
         * @param {string} contact The contact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactShow(contact: string, options?: RawAxiosRequestConfig): AxiosPromise<ContactStore201Response> {
            return localVarFp.contactShow(contact, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created contact
         * @param {ContactStoreRequest} contactStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactStore(contactStoreRequest: ContactStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContactStore201Response> {
            return localVarFp.contactStore(contactStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified contact
         * @param {string} contact The contact ID
         * @param {ContactUpdateRequest} contactUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactUpdate(contact: string, contactUpdateRequest: ContactUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContactStore201Response> {
            return localVarFp.contactUpdate(contact, contactUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactApi - object-oriented interface
 * @export
 * @class ContactApi
 * @extends {BaseAPI}
 */
export class ContactApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified contact
     * @param {string} contact The contact ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactDestroy(contact: string, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactDestroy(contact, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of contacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactIndex(options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified contact
     * @param {string} contact The contact ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactShow(contact: string, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactShow(contact, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created contact
     * @param {ContactStoreRequest} contactStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactStore(contactStoreRequest: ContactStoreRequest, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactStore(contactStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified contact
     * @param {string} contact The contact ID
     * @param {ContactUpdateRequest} contactUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactUpdate(contact: string, contactUpdateRequest: ContactUpdateRequest, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactUpdate(contact, contactUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContactTranslationApi - axios parameter creator
 * @export
 */
export const ContactTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationDestroy: async (contactTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactTranslation' is not null or undefined
            assertParamExists('contactTranslationDestroy', 'contactTranslation', contactTranslation)
            const localVarPath = `/contact-translation/{contactTranslation}`
                .replace(`{${"contactTranslation"}}`, encodeURIComponent(String(contactTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contact-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationShow: async (contactTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactTranslation' is not null or undefined
            assertParamExists('contactTranslationShow', 'contactTranslation', contactTranslation)
            const localVarPath = `/contact-translation/{contactTranslation}`
                .replace(`{${"contactTranslation"}}`, encodeURIComponent(String(contactTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ContactTranslationStoreRequest} contactTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationStore: async (contactTranslationStoreRequest: ContactTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactTranslationStoreRequest' is not null or undefined
            assertParamExists('contactTranslationStore', 'contactTranslationStoreRequest', contactTranslationStoreRequest)
            const localVarPath = `/contact-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} contactTranslation The contact translation ID
         * @param {ContactTranslationUpdateRequest} [contactTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationUpdate: async (contactTranslation: string, contactTranslationUpdateRequest?: ContactTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactTranslation' is not null or undefined
            assertParamExists('contactTranslationUpdate', 'contactTranslation', contactTranslation)
            const localVarPath = `/contact-translation/{contactTranslation}`
                .replace(`{${"contactTranslation"}}`, encodeURIComponent(String(contactTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactTranslationApi - functional programming interface
 * @export
 */
export const ContactTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactTranslationDestroy(contactTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactTranslationDestroy(contactTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactTranslationApi.contactTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactTranslationApi.contactTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactTranslationShow(contactTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactTranslationShow(contactTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactTranslationApi.contactTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ContactTranslationStoreRequest} contactTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactTranslationStore(contactTranslationStoreRequest: ContactTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactTranslationStore(contactTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactTranslationApi.contactTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} contactTranslation The contact translation ID
         * @param {ContactTranslationUpdateRequest} [contactTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactTranslationUpdate(contactTranslation: string, contactTranslationUpdateRequest?: ContactTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactTranslationUpdate(contactTranslation, contactTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactTranslationApi.contactTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactTranslationApi - factory interface
 * @export
 */
export const ContactTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationDestroy(contactTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.contactTranslationDestroy(contactTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<ContactTranslationIndex200Response> {
            return localVarFp.contactTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationShow(contactTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ContactTranslationStore200Response> {
            return localVarFp.contactTranslationShow(contactTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ContactTranslationStoreRequest} contactTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationStore(contactTranslationStoreRequest: ContactTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContactTranslationStore200Response> {
            return localVarFp.contactTranslationStore(contactTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} contactTranslation The contact translation ID
         * @param {ContactTranslationUpdateRequest} [contactTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationUpdate(contactTranslation: string, contactTranslationUpdateRequest?: ContactTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContactTranslationStore200Response> {
            return localVarFp.contactTranslationUpdate(contactTranslation, contactTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactTranslationApi - object-oriented interface
 * @export
 * @class ContactTranslationApi
 * @extends {BaseAPI}
 */
export class ContactTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} contactTranslation The contact translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactTranslationApi
     */
    public contactTranslationDestroy(contactTranslation: string, options?: RawAxiosRequestConfig) {
        return ContactTranslationApiFp(this.configuration).contactTranslationDestroy(contactTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactTranslationApi
     */
    public contactTranslationIndex(options?: RawAxiosRequestConfig) {
        return ContactTranslationApiFp(this.configuration).contactTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} contactTranslation The contact translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactTranslationApi
     */
    public contactTranslationShow(contactTranslation: string, options?: RawAxiosRequestConfig) {
        return ContactTranslationApiFp(this.configuration).contactTranslationShow(contactTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {ContactTranslationStoreRequest} contactTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactTranslationApi
     */
    public contactTranslationStore(contactTranslationStoreRequest: ContactTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return ContactTranslationApiFp(this.configuration).contactTranslationStore(contactTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} contactTranslation The contact translation ID
     * @param {ContactTranslationUpdateRequest} [contactTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactTranslationApi
     */
    public contactTranslationUpdate(contactTranslation: string, contactTranslationUpdateRequest?: ContactTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return ContactTranslationApiFp(this.configuration).contactTranslationUpdate(contactTranslation, contactTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContextApi - axios parameter creator
 * @export
 */
export const ContextApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} context The context ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDestroy: async (context: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('contextDestroy', 'context', context)
            const localVarPath = `/context/{context}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the default context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextGetDefault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/context/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set a context as the default one
         * @param {string} context The context ID
         * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextSetDefault: async (context: string, contextSetDefaultRequest: ContextSetDefaultRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('contextSetDefault', 'context', context)
            // verify required parameter 'contextSetDefaultRequest' is not null or undefined
            assertParamExists('contextSetDefault', 'contextSetDefaultRequest', contextSetDefaultRequest)
            const localVarPath = `/context/{context}/default`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextSetDefaultRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} context The context ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextShow: async (context: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('contextShow', 'context', context)
            const localVarPath = `/context/{context}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ContextStoreRequest} contextStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextStore: async (contextStoreRequest: ContextStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contextStoreRequest' is not null or undefined
            assertParamExists('contextStore', 'contextStoreRequest', contextStoreRequest)
            const localVarPath = `/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} context The context ID
         * @param {ContextStoreRequest} contextStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextUpdate: async (context: string, contextStoreRequest: ContextStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('contextUpdate', 'context', context)
            // verify required parameter 'contextStoreRequest' is not null or undefined
            assertParamExists('contextUpdate', 'contextStoreRequest', contextStoreRequest)
            const localVarPath = `/context/{context}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContextApi - functional programming interface
 * @export
 */
export const ContextApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContextApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} context The context ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextDestroy(context: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextDestroy(context, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the default context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextGetDefault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextGetDefault(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextGetDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set a context as the default one
         * @param {string} context The context ID
         * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextSetDefault(context: string, contextSetDefaultRequest: ContextSetDefaultRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextSetDefault(context, contextSetDefaultRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextSetDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} context The context ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextShow(context: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextShow(context, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ContextStoreRequest} contextStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextStore(contextStoreRequest: ContextStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextStore(contextStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} context The context ID
         * @param {ContextStoreRequest} contextStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextUpdate(context: string, contextStoreRequest: ContextStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextUpdate(context, contextStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContextApi - factory interface
 * @export
 */
export const ContextApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContextApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} context The context ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDestroy(context: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.contextDestroy(context, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the default context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextGetDefault(options?: RawAxiosRequestConfig): AxiosPromise<ContextSetDefault200Response> {
            return localVarFp.contextGetDefault(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextIndex(options?: RawAxiosRequestConfig): AxiosPromise<ContextIndex200Response> {
            return localVarFp.contextIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set a context as the default one
         * @param {string} context The context ID
         * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextSetDefault(context: string, contextSetDefaultRequest: ContextSetDefaultRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContextSetDefault200Response> {
            return localVarFp.contextSetDefault(context, contextSetDefaultRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} context The context ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextShow(context: string, options?: RawAxiosRequestConfig): AxiosPromise<ContextSetDefault200Response> {
            return localVarFp.contextShow(context, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ContextStoreRequest} contextStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextStore(contextStoreRequest: ContextStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContextSetDefault200Response> {
            return localVarFp.contextStore(contextStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} context The context ID
         * @param {ContextStoreRequest} contextStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextUpdate(context: string, contextStoreRequest: ContextStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContextSetDefault200Response> {
            return localVarFp.contextUpdate(context, contextStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContextApi - object-oriented interface
 * @export
 * @class ContextApi
 * @extends {BaseAPI}
 */
export class ContextApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} context The context ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public contextDestroy(context: string, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextDestroy(context, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the default context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public contextGetDefault(options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextGetDefault(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public contextIndex(options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set a context as the default one
     * @param {string} context The context ID
     * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public contextSetDefault(context: string, contextSetDefaultRequest: ContextSetDefaultRequest, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextSetDefault(context, contextSetDefaultRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} context The context ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public contextShow(context: string, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextShow(context, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {ContextStoreRequest} contextStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public contextStore(contextStoreRequest: ContextStoreRequest, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextStore(contextStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} context The context ID
     * @param {ContextStoreRequest} contextStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public contextUpdate(context: string, contextStoreRequest: ContextStoreRequest, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextUpdate(context, contextStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CountryApi - axios parameter creator
 * @export
 */
export const CountryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} country The country ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryDestroy: async (country: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('countryDestroy', 'country', country)
            const localVarPath = `/country/{country}`
                .replace(`{${"country"}}`, encodeURIComponent(String(country)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/country`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} country The country ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryShow: async (country: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('countryShow', 'country', country)
            const localVarPath = `/country/{country}`
                .replace(`{${"country"}}`, encodeURIComponent(String(country)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {CountryStoreRequest} countryStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryStore: async (countryStoreRequest: CountryStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryStoreRequest' is not null or undefined
            assertParamExists('countryStore', 'countryStoreRequest', countryStoreRequest)
            const localVarPath = `/country`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(countryStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} country The country ID
         * @param {CountryUpdateRequest} countryUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryUpdate: async (country: string, countryUpdateRequest: CountryUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('countryUpdate', 'country', country)
            // verify required parameter 'countryUpdateRequest' is not null or undefined
            assertParamExists('countryUpdate', 'countryUpdateRequest', countryUpdateRequest)
            const localVarPath = `/country/{country}`
                .replace(`{${"country"}}`, encodeURIComponent(String(country)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(countryUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountryApi - functional programming interface
 * @export
 */
export const CountryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CountryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} country The country ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryDestroy(country: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryDestroy(country, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} country The country ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryShow(country: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryShow(country, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {CountryStoreRequest} countryStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryStore(countryStoreRequest: CountryStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryStore(countryStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} country The country ID
         * @param {CountryUpdateRequest} countryUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryUpdate(country: string, countryUpdateRequest: CountryUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryUpdate(country, countryUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CountryApi - factory interface
 * @export
 */
export const CountryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CountryApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} country The country ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryDestroy(country: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.countryDestroy(country, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryIndex(options?: RawAxiosRequestConfig): AxiosPromise<CountryIndex200Response> {
            return localVarFp.countryIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} country The country ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryShow(country: string, options?: RawAxiosRequestConfig): AxiosPromise<CountryStore200Response> {
            return localVarFp.countryShow(country, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {CountryStoreRequest} countryStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryStore(countryStoreRequest: CountryStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<CountryStore200Response> {
            return localVarFp.countryStore(countryStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} country The country ID
         * @param {CountryUpdateRequest} countryUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryUpdate(country: string, countryUpdateRequest: CountryUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CountryStore200Response> {
            return localVarFp.countryUpdate(country, countryUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CountryApi - object-oriented interface
 * @export
 * @class CountryApi
 * @extends {BaseAPI}
 */
export class CountryApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} country The country ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countryDestroy(country: string, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryDestroy(country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countryIndex(options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} country The country ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countryShow(country: string, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryShow(country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {CountryStoreRequest} countryStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countryStore(countryStoreRequest: CountryStoreRequest, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryStore(countryStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} country The country ID
     * @param {CountryUpdateRequest} countryUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countryUpdate(country: string, countryUpdateRequest: CountryUpdateRequest, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryUpdate(country, countryUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DetailApi - axios parameter creator
 * @export
 */
export const DetailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} detail The detail ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailDestroy: async (detail: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detail' is not null or undefined
            assertParamExists('detailDestroy', 'detail', detail)
            const localVarPath = `/detail/{detail}`
                .replace(`{${"detail"}}`, encodeURIComponent(String(detail)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} detail The detail ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailShow: async (detail: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detail' is not null or undefined
            assertParamExists('detailShow', 'detail', detail)
            const localVarPath = `/detail/{detail}`
                .replace(`{${"detail"}}`, encodeURIComponent(String(detail)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {DetailStoreRequest} detailStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailStore: async (detailStoreRequest: DetailStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detailStoreRequest' is not null or undefined
            assertParamExists('detailStore', 'detailStoreRequest', detailStoreRequest)
            const localVarPath = `/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(detailStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} detail The detail ID
         * @param {DetailStoreRequest} detailStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailUpdate: async (detail: string, detailStoreRequest: DetailStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detail' is not null or undefined
            assertParamExists('detailUpdate', 'detail', detail)
            // verify required parameter 'detailStoreRequest' is not null or undefined
            assertParamExists('detailUpdate', 'detailStoreRequest', detailStoreRequest)
            const localVarPath = `/detail/{detail}`
                .replace(`{${"detail"}}`, encodeURIComponent(String(detail)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(detailStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DetailApi - functional programming interface
 * @export
 */
export const DetailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DetailApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} detail The detail ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailDestroy(detail: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailDestroy(detail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailApi.detailDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailApi.detailIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} detail The detail ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailShow(detail: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailShow(detail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailApi.detailShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {DetailStoreRequest} detailStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailStore(detailStoreRequest: DetailStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailStore(detailStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailApi.detailStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} detail The detail ID
         * @param {DetailStoreRequest} detailStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailUpdate(detail: string, detailStoreRequest: DetailStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailUpdate(detail, detailStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailApi.detailUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DetailApi - factory interface
 * @export
 */
export const DetailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DetailApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} detail The detail ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailDestroy(detail: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.detailDestroy(detail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailIndex(options?: RawAxiosRequestConfig): AxiosPromise<DetailIndex200Response> {
            return localVarFp.detailIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} detail The detail ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailShow(detail: string, options?: RawAxiosRequestConfig): AxiosPromise<DetailStore200Response> {
            return localVarFp.detailShow(detail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {DetailStoreRequest} detailStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailStore(detailStoreRequest: DetailStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<DetailStore200Response> {
            return localVarFp.detailStore(detailStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} detail The detail ID
         * @param {DetailStoreRequest} detailStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailUpdate(detail: string, detailStoreRequest: DetailStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<DetailStore200Response> {
            return localVarFp.detailUpdate(detail, detailStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DetailApi - object-oriented interface
 * @export
 * @class DetailApi
 * @extends {BaseAPI}
 */
export class DetailApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} detail The detail ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailApi
     */
    public detailDestroy(detail: string, options?: RawAxiosRequestConfig) {
        return DetailApiFp(this.configuration).detailDestroy(detail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailApi
     */
    public detailIndex(options?: RawAxiosRequestConfig) {
        return DetailApiFp(this.configuration).detailIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} detail The detail ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailApi
     */
    public detailShow(detail: string, options?: RawAxiosRequestConfig) {
        return DetailApiFp(this.configuration).detailShow(detail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {DetailStoreRequest} detailStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailApi
     */
    public detailStore(detailStoreRequest: DetailStoreRequest, options?: RawAxiosRequestConfig) {
        return DetailApiFp(this.configuration).detailStore(detailStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} detail The detail ID
     * @param {DetailStoreRequest} detailStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailApi
     */
    public detailUpdate(detail: string, detailStoreRequest: DetailStoreRequest, options?: RawAxiosRequestConfig) {
        return DetailApiFp(this.configuration).detailUpdate(detail, detailStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DetailTranslationApi - axios parameter creator
 * @export
 */
export const DetailTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationDestroy: async (detailTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detailTranslation' is not null or undefined
            assertParamExists('detailTranslationDestroy', 'detailTranslation', detailTranslation)
            const localVarPath = `/detail-translation/{detailTranslation}`
                .replace(`{${"detailTranslation"}}`, encodeURIComponent(String(detailTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of detail translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/detail-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationShow: async (detailTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detailTranslation' is not null or undefined
            assertParamExists('detailTranslationShow', 'detailTranslation', detailTranslation)
            const localVarPath = `/detail-translation/{detailTranslation}`
                .replace(`{${"detailTranslation"}}`, encodeURIComponent(String(detailTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created detail translation
         * @param {DetailTranslationStoreRequest} detailTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationStore: async (detailTranslationStoreRequest: DetailTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detailTranslationStoreRequest' is not null or undefined
            assertParamExists('detailTranslationStore', 'detailTranslationStoreRequest', detailTranslationStoreRequest)
            const localVarPath = `/detail-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(detailTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {DetailTranslationUpdateRequest} [detailTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationUpdate: async (detailTranslation: string, detailTranslationUpdateRequest?: DetailTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detailTranslation' is not null or undefined
            assertParamExists('detailTranslationUpdate', 'detailTranslation', detailTranslation)
            const localVarPath = `/detail-translation/{detailTranslation}`
                .replace(`{${"detailTranslation"}}`, encodeURIComponent(String(detailTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(detailTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DetailTranslationApi - functional programming interface
 * @export
 */
export const DetailTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DetailTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailTranslationDestroy(detailTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailTranslationDestroy(detailTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailTranslationApi.detailTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of detail translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DetailTranslationResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailTranslationApi.detailTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailTranslationShow(detailTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailTranslationShow(detailTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailTranslationApi.detailTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created detail translation
         * @param {DetailTranslationStoreRequest} detailTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailTranslationStore(detailTranslationStoreRequest: DetailTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailTranslationStore(detailTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailTranslationApi.detailTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {DetailTranslationUpdateRequest} [detailTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailTranslationUpdate(detailTranslation: string, detailTranslationUpdateRequest?: DetailTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailTranslationUpdate(detailTranslation, detailTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailTranslationApi.detailTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DetailTranslationApi - factory interface
 * @export
 */
export const DetailTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DetailTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationDestroy(detailTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.detailTranslationDestroy(detailTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of detail translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<Array<DetailTranslationResource>> {
            return localVarFp.detailTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationShow(detailTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<DetailTranslationShow200Response> {
            return localVarFp.detailTranslationShow(detailTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created detail translation
         * @param {DetailTranslationStoreRequest} detailTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationStore(detailTranslationStoreRequest: DetailTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.detailTranslationStore(detailTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {DetailTranslationUpdateRequest} [detailTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationUpdate(detailTranslation: string, detailTranslationUpdateRequest?: DetailTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<DetailTranslationShow200Response> {
            return localVarFp.detailTranslationUpdate(detailTranslation, detailTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DetailTranslationApi - object-oriented interface
 * @export
 * @class DetailTranslationApi
 * @extends {BaseAPI}
 */
export class DetailTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified detail translation
     * @param {string} detailTranslation The detail translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailTranslationApi
     */
    public detailTranslationDestroy(detailTranslation: string, options?: RawAxiosRequestConfig) {
        return DetailTranslationApiFp(this.configuration).detailTranslationDestroy(detailTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of detail translations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailTranslationApi
     */
    public detailTranslationIndex(options?: RawAxiosRequestConfig) {
        return DetailTranslationApiFp(this.configuration).detailTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified detail translation
     * @param {string} detailTranslation The detail translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailTranslationApi
     */
    public detailTranslationShow(detailTranslation: string, options?: RawAxiosRequestConfig) {
        return DetailTranslationApiFp(this.configuration).detailTranslationShow(detailTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created detail translation
     * @param {DetailTranslationStoreRequest} detailTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailTranslationApi
     */
    public detailTranslationStore(detailTranslationStoreRequest: DetailTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return DetailTranslationApiFp(this.configuration).detailTranslationStore(detailTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified detail translation
     * @param {string} detailTranslation The detail translation ID
     * @param {DetailTranslationUpdateRequest} [detailTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailTranslationApi
     */
    public detailTranslationUpdate(detailTranslation: string, detailTranslationUpdateRequest?: DetailTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return DetailTranslationApiFp(this.configuration).detailTranslationUpdate(detailTranslation, detailTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DetailTranslationsApi - axios parameter creator
 * @export
 */
export const DetailTranslationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationDestroy: async (detailTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detailTranslation' is not null or undefined
            assertParamExists('detailTranslationDestroy', 'detailTranslation', detailTranslation)
            const localVarPath = `/detail-translation/{detailTranslation}`
                .replace(`{${"detailTranslation"}}`, encodeURIComponent(String(detailTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of detail translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/detail-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationShow: async (detailTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detailTranslation' is not null or undefined
            assertParamExists('detailTranslationShow', 'detailTranslation', detailTranslation)
            const localVarPath = `/detail-translation/{detailTranslation}`
                .replace(`{${"detailTranslation"}}`, encodeURIComponent(String(detailTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created detail translation
         * @param {DetailTranslationStoreRequest} detailTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationStore: async (detailTranslationStoreRequest: DetailTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detailTranslationStoreRequest' is not null or undefined
            assertParamExists('detailTranslationStore', 'detailTranslationStoreRequest', detailTranslationStoreRequest)
            const localVarPath = `/detail-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(detailTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {DetailTranslationUpdateRequest} [detailTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationUpdate: async (detailTranslation: string, detailTranslationUpdateRequest?: DetailTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detailTranslation' is not null or undefined
            assertParamExists('detailTranslationUpdate', 'detailTranslation', detailTranslation)
            const localVarPath = `/detail-translation/{detailTranslation}`
                .replace(`{${"detailTranslation"}}`, encodeURIComponent(String(detailTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(detailTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DetailTranslationsApi - functional programming interface
 * @export
 */
export const DetailTranslationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DetailTranslationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailTranslationDestroy(detailTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailTranslationDestroy(detailTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailTranslationsApi.detailTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of detail translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DetailTranslationResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailTranslationsApi.detailTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailTranslationShow(detailTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailTranslationShow(detailTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailTranslationsApi.detailTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created detail translation
         * @param {DetailTranslationStoreRequest} detailTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailTranslationStore(detailTranslationStoreRequest: DetailTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailTranslationStore(detailTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailTranslationsApi.detailTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {DetailTranslationUpdateRequest} [detailTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailTranslationUpdate(detailTranslation: string, detailTranslationUpdateRequest?: DetailTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailTranslationUpdate(detailTranslation, detailTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetailTranslationsApi.detailTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DetailTranslationsApi - factory interface
 * @export
 */
export const DetailTranslationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DetailTranslationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationDestroy(detailTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.detailTranslationDestroy(detailTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of detail translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<Array<DetailTranslationResource>> {
            return localVarFp.detailTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationShow(detailTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<DetailTranslationShow200Response> {
            return localVarFp.detailTranslationShow(detailTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created detail translation
         * @param {DetailTranslationStoreRequest} detailTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationStore(detailTranslationStoreRequest: DetailTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.detailTranslationStore(detailTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified detail translation
         * @param {string} detailTranslation The detail translation ID
         * @param {DetailTranslationUpdateRequest} [detailTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailTranslationUpdate(detailTranslation: string, detailTranslationUpdateRequest?: DetailTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<DetailTranslationShow200Response> {
            return localVarFp.detailTranslationUpdate(detailTranslation, detailTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DetailTranslationsApi - object-oriented interface
 * @export
 * @class DetailTranslationsApi
 * @extends {BaseAPI}
 */
export class DetailTranslationsApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified detail translation
     * @param {string} detailTranslation The detail translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailTranslationsApi
     */
    public detailTranslationDestroy(detailTranslation: string, options?: RawAxiosRequestConfig) {
        return DetailTranslationsApiFp(this.configuration).detailTranslationDestroy(detailTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of detail translations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailTranslationsApi
     */
    public detailTranslationIndex(options?: RawAxiosRequestConfig) {
        return DetailTranslationsApiFp(this.configuration).detailTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified detail translation
     * @param {string} detailTranslation The detail translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailTranslationsApi
     */
    public detailTranslationShow(detailTranslation: string, options?: RawAxiosRequestConfig) {
        return DetailTranslationsApiFp(this.configuration).detailTranslationShow(detailTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created detail translation
     * @param {DetailTranslationStoreRequest} detailTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailTranslationsApi
     */
    public detailTranslationStore(detailTranslationStoreRequest: DetailTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return DetailTranslationsApiFp(this.configuration).detailTranslationStore(detailTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified detail translation
     * @param {string} detailTranslation The detail translation ID
     * @param {DetailTranslationUpdateRequest} [detailTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetailTranslationsApi
     */
    public detailTranslationUpdate(detailTranslation: string, detailTranslationUpdateRequest?: DetailTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return DetailTranslationsApiFp(this.configuration).detailTranslationUpdate(detailTranslation, detailTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImageUploadApi - axios parameter creator
 * @export
 */
export const ImageUploadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadDestroy: async (imageUpload: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageUpload' is not null or undefined
            assertParamExists('imageUploadDestroy', 'imageUpload', imageUpload)
            const localVarPath = `/image-upload/{imageUpload}`
                .replace(`{${"imageUpload"}}`, encodeURIComponent(String(imageUpload)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/image-upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadShow: async (imageUpload: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageUpload' is not null or undefined
            assertParamExists('imageUploadShow', 'imageUpload', imageUpload)
            const localVarPath = `/image-upload/{imageUpload}`
                .replace(`{${"imageUpload"}}`, encodeURIComponent(String(imageUpload)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadStore: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('imageUploadStore', 'file', file)
            const localVarPath = `/image-upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageUploadApi - functional programming interface
 * @export
 */
export const ImageUploadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImageUploadApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadDestroy(imageUpload: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadDestroy(imageUpload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadShow(imageUpload: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadShow(imageUpload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadStore(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadStore(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImageUploadApi - factory interface
 * @export
 */
export const ImageUploadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImageUploadApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadDestroy(imageUpload: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.imageUploadDestroy(imageUpload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadIndex(options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadIndex200Response> {
            return localVarFp.imageUploadIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadShow(imageUpload: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadStore200Response> {
            return localVarFp.imageUploadShow(imageUpload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadStore(file: File, options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadStore200Response> {
            return localVarFp.imageUploadStore(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImageUploadApi - object-oriented interface
 * @export
 * @class ImageUploadApi
 * @extends {BaseAPI}
 */
export class ImageUploadApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} imageUpload The image upload ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageUploadApi
     */
    public imageUploadDestroy(imageUpload: string, options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadDestroy(imageUpload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageUploadApi
     */
    public imageUploadIndex(options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} imageUpload The image upload ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageUploadApi
     */
    public imageUploadShow(imageUpload: string, options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadShow(imageUpload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageUploadApi
     */
    public imageUploadStore(file: File, options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadStore(file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemApi - axios parameter creator
 * @export
 */
export const ItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDestroy: async (item: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemDestroy', 'item', item)
            const localVarPath = `/item/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get items for a specific tag
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemForTag: async (tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('itemForTag', 'tag', tag)
            const localVarPath = `/item/for-tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemShow: async (item: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemShow', 'item', item)
            const localVarPath = `/item/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ItemStoreRequest} itemStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemStore: async (itemStoreRequest: ItemStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemStoreRequest' is not null or undefined
            assertParamExists('itemStore', 'itemStoreRequest', itemStoreRequest)
            const localVarPath = `/item`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} item The item ID
         * @param {ItemStoreRequest} itemStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdate: async (item: string, itemStoreRequest: ItemStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemUpdate', 'item', item)
            // verify required parameter 'itemStoreRequest' is not null or undefined
            assertParamExists('itemUpdate', 'itemStoreRequest', itemStoreRequest)
            const localVarPath = `/item/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows quick editing of tag associations by specifying which tags to attach or detach from the item. It provides fine-grained control over tag operations without requiring a full item update.
         * @summary Update tags for the specified item without modifying other item properties
         * @param {string} item - The item to update tags for
         * @param {ItemUpdateTagsRequest} [itemUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdateTags: async (item: string, itemUpdateTagsRequest?: ItemUpdateTagsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemUpdateTags', 'item', item)
            const localVarPath = `/item/{item}/tags`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemUpdateTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get items that have ALL of the specified tags (AND condition)
         * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemWithAllTags: async (itemWithAllTagsRequest: ItemWithAllTagsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemWithAllTagsRequest' is not null or undefined
            assertParamExists('itemWithAllTags', 'itemWithAllTagsRequest', itemWithAllTagsRequest)
            const localVarPath = `/item/with-all-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemWithAllTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get items that have ANY of the specified tags (OR condition)
         * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemWithAnyTags: async (itemWithAllTagsRequest: ItemWithAllTagsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemWithAllTagsRequest' is not null or undefined
            assertParamExists('itemWithAnyTags', 'itemWithAllTagsRequest', itemWithAllTagsRequest)
            const localVarPath = `/item/with-any-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemWithAllTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemApi - functional programming interface
 * @export
 */
export const ItemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemDestroy(item: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemDestroy(item, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get items for a specific tag
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemForTag(tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemForTag(tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemForTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemShow(item: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemShow(item, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ItemStoreRequest} itemStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemStore(itemStoreRequest: ItemStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemStore(itemStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} item The item ID
         * @param {ItemStoreRequest} itemStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemUpdate(item: string, itemStoreRequest: ItemStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemUpdate(item, itemStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint allows quick editing of tag associations by specifying which tags to attach or detach from the item. It provides fine-grained control over tag operations without requiring a full item update.
         * @summary Update tags for the specified item without modifying other item properties
         * @param {string} item - The item to update tags for
         * @param {ItemUpdateTagsRequest} [itemUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemUpdateTags(item: string, itemUpdateTagsRequest?: ItemUpdateTagsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemUpdateTags(item, itemUpdateTagsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemUpdateTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get items that have ALL of the specified tags (AND condition)
         * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemWithAllTags(itemWithAllTagsRequest: ItemWithAllTagsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemWithAllTags(itemWithAllTagsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemWithAllTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get items that have ANY of the specified tags (OR condition)
         * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemWithAnyTags(itemWithAllTagsRequest: ItemWithAllTagsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemWithAnyTags(itemWithAllTagsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemWithAnyTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemApi - factory interface
 * @export
 */
export const ItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDestroy(item: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.itemDestroy(item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get items for a specific tag
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemForTag(tag: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemIndex200Response> {
            return localVarFp.itemForTag(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemIndex(options?: RawAxiosRequestConfig): AxiosPromise<ItemIndex200Response> {
            return localVarFp.itemIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemShow(item: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemStore200Response> {
            return localVarFp.itemShow(item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ItemStoreRequest} itemStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemStore(itemStoreRequest: ItemStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemStore200Response> {
            return localVarFp.itemStore(itemStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} item The item ID
         * @param {ItemStoreRequest} itemStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdate(item: string, itemStoreRequest: ItemStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemStore200Response> {
            return localVarFp.itemUpdate(item, itemStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows quick editing of tag associations by specifying which tags to attach or detach from the item. It provides fine-grained control over tag operations without requiring a full item update.
         * @summary Update tags for the specified item without modifying other item properties
         * @param {string} item - The item to update tags for
         * @param {ItemUpdateTagsRequest} [itemUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdateTags(item: string, itemUpdateTagsRequest?: ItemUpdateTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemStore200Response> {
            return localVarFp.itemUpdateTags(item, itemUpdateTagsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get items that have ALL of the specified tags (AND condition)
         * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemWithAllTags(itemWithAllTagsRequest: ItemWithAllTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemIndex200Response> {
            return localVarFp.itemWithAllTags(itemWithAllTagsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get items that have ANY of the specified tags (OR condition)
         * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemWithAnyTags(itemWithAllTagsRequest: ItemWithAllTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemIndex200Response> {
            return localVarFp.itemWithAnyTags(itemWithAllTagsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemApi - object-oriented interface
 * @export
 * @class ItemApi
 * @extends {BaseAPI}
 */
export class ItemApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} item The item ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemDestroy(item: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemDestroy(item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get items for a specific tag
     * @param {string} tag The tag ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemForTag(tag: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemForTag(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemIndex(options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} item The item ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemShow(item: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemShow(item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {ItemStoreRequest} itemStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemStore(itemStoreRequest: ItemStoreRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemStore(itemStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} item The item ID
     * @param {ItemStoreRequest} itemStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemUpdate(item: string, itemStoreRequest: ItemStoreRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemUpdate(item, itemStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows quick editing of tag associations by specifying which tags to attach or detach from the item. It provides fine-grained control over tag operations without requiring a full item update.
     * @summary Update tags for the specified item without modifying other item properties
     * @param {string} item - The item to update tags for
     * @param {ItemUpdateTagsRequest} [itemUpdateTagsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemUpdateTags(item: string, itemUpdateTagsRequest?: ItemUpdateTagsRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemUpdateTags(item, itemUpdateTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get items that have ALL of the specified tags (AND condition)
     * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemWithAllTags(itemWithAllTagsRequest: ItemWithAllTagsRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemWithAllTags(itemWithAllTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get items that have ANY of the specified tags (OR condition)
     * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemWithAnyTags(itemWithAllTagsRequest: ItemWithAllTagsRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemWithAnyTags(itemWithAllTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemTranslationApi - axios parameter creator
 * @export
 */
export const ItemTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationDestroy: async (itemTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationDestroy', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationShow: async (itemTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationShow', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationStore: async (itemTranslationStoreRequest: ItemTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslationStoreRequest' is not null or undefined
            assertParamExists('itemTranslationStore', 'itemTranslationStoreRequest', itemTranslationStoreRequest)
            const localVarPath = `/item-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate: async (itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationUpdate', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemTranslationApi - functional programming interface
 * @export
 */
export const ItemTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationDestroy(itemTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemTranslationResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationShow(itemTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationShow(itemTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationStore(itemTranslationStoreRequest: ItemTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationStore(itemTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationUpdate(itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationUpdate(itemTranslation, itemTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemTranslationApi - factory interface
 * @export
 */
export const ItemTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.itemTranslationDestroy(itemTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<Array<ItemTranslationResource>> {
            return localVarFp.itemTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationShow(itemTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationShow(itemTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationStore(itemTranslationStoreRequest: ItemTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.itemTranslationStore(itemTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate(itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationUpdate(itemTranslation, itemTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemTranslationApi - object-oriented interface
 * @export
 * @class ItemTranslationApi
 * @extends {BaseAPI}
 */
export class ItemTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationApi
     */
    public itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationDestroy(itemTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of item translations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationApi
     */
    public itemTranslationIndex(options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationApi
     */
    public itemTranslationShow(itemTranslation: string, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationShow(itemTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created item translation
     * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationApi
     */
    public itemTranslationStore(itemTranslationStoreRequest: ItemTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationStore(itemTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationApi
     */
    public itemTranslationUpdate(itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationUpdate(itemTranslation, itemTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemTranslationsApi - axios parameter creator
 * @export
 */
export const ItemTranslationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationDestroy: async (itemTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationDestroy', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationShow: async (itemTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationShow', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationStore: async (itemTranslationStoreRequest: ItemTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslationStoreRequest' is not null or undefined
            assertParamExists('itemTranslationStore', 'itemTranslationStoreRequest', itemTranslationStoreRequest)
            const localVarPath = `/item-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate: async (itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationUpdate', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemTranslationsApi - functional programming interface
 * @export
 */
export const ItemTranslationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemTranslationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationDestroy(itemTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemTranslationResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationShow(itemTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationShow(itemTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationStore(itemTranslationStoreRequest: ItemTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationStore(itemTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationUpdate(itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationUpdate(itemTranslation, itemTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemTranslationsApi - factory interface
 * @export
 */
export const ItemTranslationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemTranslationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.itemTranslationDestroy(itemTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<Array<ItemTranslationResource>> {
            return localVarFp.itemTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationShow(itemTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationShow(itemTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationStore(itemTranslationStoreRequest: ItemTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.itemTranslationStore(itemTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate(itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationUpdate(itemTranslation, itemTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemTranslationsApi - object-oriented interface
 * @export
 * @class ItemTranslationsApi
 * @extends {BaseAPI}
 */
export class ItemTranslationsApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationsApi
     */
    public itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationDestroy(itemTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of item translations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationsApi
     */
    public itemTranslationIndex(options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationsApi
     */
    public itemTranslationShow(itemTranslation: string, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationShow(itemTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created item translation
     * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationsApi
     */
    public itemTranslationStore(itemTranslationStoreRequest: ItemTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationStore(itemTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationsApi
     */
    public itemTranslationUpdate(itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationUpdate(itemTranslation, itemTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LanguageApi - axios parameter creator
 * @export
 */
export const LanguageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageDestroy: async (language: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('languageDestroy', 'language', language)
            const localVarPath = `/language/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the default Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageGetDefault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/language/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the english Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageGetEnglish: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/language/english`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/language`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set a Language as the default one
         * @param {string} language The language ID
         * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageSetDefault: async (language: string, contextSetDefaultRequest: ContextSetDefaultRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('languageSetDefault', 'language', language)
            // verify required parameter 'contextSetDefaultRequest' is not null or undefined
            assertParamExists('languageSetDefault', 'contextSetDefaultRequest', contextSetDefaultRequest)
            const localVarPath = `/language/{language}/default`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextSetDefaultRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageShow: async (language: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('languageShow', 'language', language)
            const localVarPath = `/language/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {LanguageStoreRequest} languageStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageStore: async (languageStoreRequest: LanguageStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'languageStoreRequest' is not null or undefined
            assertParamExists('languageStore', 'languageStoreRequest', languageStoreRequest)
            const localVarPath = `/language`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(languageStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} language The language ID
         * @param {LanguageUpdateRequest} languageUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageUpdate: async (language: string, languageUpdateRequest: LanguageUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('languageUpdate', 'language', language)
            // verify required parameter 'languageUpdateRequest' is not null or undefined
            assertParamExists('languageUpdate', 'languageUpdateRequest', languageUpdateRequest)
            const localVarPath = `/language/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(languageUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LanguageApi - functional programming interface
 * @export
 */
export const LanguageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LanguageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageDestroy(language: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageDestroy(language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the default Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageGetDefault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageGetDefault(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageGetDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the english Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageGetEnglish(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageGetEnglish(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageGetEnglish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set a Language as the default one
         * @param {string} language The language ID
         * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageSetDefault(language: string, contextSetDefaultRequest: ContextSetDefaultRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageSetDefault(language, contextSetDefaultRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageSetDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageShow(language: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageShow(language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {LanguageStoreRequest} languageStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageStore(languageStoreRequest: LanguageStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageStore(languageStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} language The language ID
         * @param {LanguageUpdateRequest} languageUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageUpdate(language: string, languageUpdateRequest: LanguageUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageUpdate(language, languageUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LanguageApi - factory interface
 * @export
 */
export const LanguageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LanguageApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageDestroy(language: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.languageDestroy(language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the default Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageGetDefault(options?: RawAxiosRequestConfig): AxiosPromise<LanguageSetDefault200Response> {
            return localVarFp.languageGetDefault(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the english Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageGetEnglish(options?: RawAxiosRequestConfig): AxiosPromise<LanguageSetDefault200Response> {
            return localVarFp.languageGetEnglish(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageIndex(options?: RawAxiosRequestConfig): AxiosPromise<LanguageIndex200Response> {
            return localVarFp.languageIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set a Language as the default one
         * @param {string} language The language ID
         * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageSetDefault(language: string, contextSetDefaultRequest: ContextSetDefaultRequest, options?: RawAxiosRequestConfig): AxiosPromise<LanguageSetDefault200Response> {
            return localVarFp.languageSetDefault(language, contextSetDefaultRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageShow(language: string, options?: RawAxiosRequestConfig): AxiosPromise<LanguageSetDefault200Response> {
            return localVarFp.languageShow(language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {LanguageStoreRequest} languageStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageStore(languageStoreRequest: LanguageStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<LanguageSetDefault200Response> {
            return localVarFp.languageStore(languageStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} language The language ID
         * @param {LanguageUpdateRequest} languageUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageUpdate(language: string, languageUpdateRequest: LanguageUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<LanguageSetDefault200Response> {
            return localVarFp.languageUpdate(language, languageUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LanguageApi - object-oriented interface
 * @export
 * @class LanguageApi
 * @extends {BaseAPI}
 */
export class LanguageApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} language The language ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageDestroy(language: string, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageDestroy(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the default Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageGetDefault(options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageGetDefault(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the english Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageGetEnglish(options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageGetEnglish(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageIndex(options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set a Language as the default one
     * @param {string} language The language ID
     * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageSetDefault(language: string, contextSetDefaultRequest: ContextSetDefaultRequest, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageSetDefault(language, contextSetDefaultRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} language The language ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageShow(language: string, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageShow(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {LanguageStoreRequest} languageStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageStore(languageStoreRequest: LanguageStoreRequest, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageStore(languageStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} language The language ID
     * @param {LanguageUpdateRequest} languageUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageUpdate(language: string, languageUpdateRequest: LanguageUpdateRequest, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageUpdate(language, languageUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationApi - axios parameter creator
 * @export
 */
export const LocationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified location
         * @param {string} location The location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationDestroy: async (location: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('locationDestroy', 'location', location)
            const localVarPath = `/location/{location}`
                .replace(`{${"location"}}`, encodeURIComponent(String(location)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified location
         * @param {string} location The location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationShow: async (location: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('locationShow', 'location', location)
            const localVarPath = `/location/{location}`
                .replace(`{${"location"}}`, encodeURIComponent(String(location)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created location
         * @param {LocationStoreRequest} locationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationStore: async (locationStoreRequest: LocationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationStoreRequest' is not null or undefined
            assertParamExists('locationStore', 'locationStoreRequest', locationStoreRequest)
            const localVarPath = `/location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified location
         * @param {string} location The location ID
         * @param {LocationUpdateRequest} locationUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationUpdate: async (location: string, locationUpdateRequest: LocationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('locationUpdate', 'location', location)
            // verify required parameter 'locationUpdateRequest' is not null or undefined
            assertParamExists('locationUpdate', 'locationUpdateRequest', locationUpdateRequest)
            const localVarPath = `/location/{location}`
                .replace(`{${"location"}}`, encodeURIComponent(String(location)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationApi - functional programming interface
 * @export
 */
export const LocationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified location
         * @param {string} location The location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationDestroy(location: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationDestroy(location, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified location
         * @param {string} location The location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationShow(location: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationShow(location, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created location
         * @param {LocationStoreRequest} locationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationStore(locationStoreRequest: LocationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationStore(locationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified location
         * @param {string} location The location ID
         * @param {LocationUpdateRequest} locationUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationUpdate(location: string, locationUpdateRequest: LocationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationUpdate(location, locationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationApi - factory interface
 * @export
 */
export const LocationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified location
         * @param {string} location The location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationDestroy(location: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.locationDestroy(location, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationIndex(options?: RawAxiosRequestConfig): AxiosPromise<LocationIndex200Response> {
            return localVarFp.locationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified location
         * @param {string} location The location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationShow(location: string, options?: RawAxiosRequestConfig): AxiosPromise<LocationStore201Response> {
            return localVarFp.locationShow(location, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created location
         * @param {LocationStoreRequest} locationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationStore(locationStoreRequest: LocationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationStore201Response> {
            return localVarFp.locationStore(locationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified location
         * @param {string} location The location ID
         * @param {LocationUpdateRequest} locationUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationUpdate(location: string, locationUpdateRequest: LocationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationStore201Response> {
            return localVarFp.locationUpdate(location, locationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationApi - object-oriented interface
 * @export
 * @class LocationApi
 * @extends {BaseAPI}
 */
export class LocationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified location
     * @param {string} location The location ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public locationDestroy(location: string, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationDestroy(location, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of locations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public locationIndex(options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified location
     * @param {string} location The location ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public locationShow(location: string, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationShow(location, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created location
     * @param {LocationStoreRequest} locationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public locationStore(locationStoreRequest: LocationStoreRequest, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationStore(locationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified location
     * @param {string} location The location ID
     * @param {LocationUpdateRequest} locationUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public locationUpdate(location: string, locationUpdateRequest: LocationUpdateRequest, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationUpdate(location, locationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationTranslationApi - axios parameter creator
 * @export
 */
export const LocationTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationDestroy: async (locationTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationTranslation' is not null or undefined
            assertParamExists('locationTranslationDestroy', 'locationTranslation', locationTranslation)
            const localVarPath = `/location-translation/{locationTranslation}`
                .replace(`{${"locationTranslation"}}`, encodeURIComponent(String(locationTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/location-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationShow: async (locationTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationTranslation' is not null or undefined
            assertParamExists('locationTranslationShow', 'locationTranslation', locationTranslation)
            const localVarPath = `/location-translation/{locationTranslation}`
                .replace(`{${"locationTranslation"}}`, encodeURIComponent(String(locationTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {LocationTranslationStoreRequest} locationTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationStore: async (locationTranslationStoreRequest: LocationTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationTranslationStoreRequest' is not null or undefined
            assertParamExists('locationTranslationStore', 'locationTranslationStoreRequest', locationTranslationStoreRequest)
            const localVarPath = `/location-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} locationTranslation The location translation ID
         * @param {LocationTranslationUpdateRequest} [locationTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationUpdate: async (locationTranslation: string, locationTranslationUpdateRequest?: LocationTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationTranslation' is not null or undefined
            assertParamExists('locationTranslationUpdate', 'locationTranslation', locationTranslation)
            const localVarPath = `/location-translation/{locationTranslation}`
                .replace(`{${"locationTranslation"}}`, encodeURIComponent(String(locationTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationTranslationApi - functional programming interface
 * @export
 */
export const LocationTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationDestroy(locationTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationDestroy(locationTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationShow(locationTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationShow(locationTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {LocationTranslationStoreRequest} locationTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationStore(locationTranslationStoreRequest: LocationTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationStore(locationTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} locationTranslation The location translation ID
         * @param {LocationTranslationUpdateRequest} [locationTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationUpdate(locationTranslation: string, locationTranslationUpdateRequest?: LocationTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationUpdate(locationTranslation, locationTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationTranslationApi - factory interface
 * @export
 */
export const LocationTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationDestroy(locationTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.locationTranslationDestroy(locationTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<LocationTranslationIndex200Response> {
            return localVarFp.locationTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationShow(locationTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<LocationTranslationStore200Response> {
            return localVarFp.locationTranslationShow(locationTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {LocationTranslationStoreRequest} locationTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationStore(locationTranslationStoreRequest: LocationTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationTranslationStore200Response> {
            return localVarFp.locationTranslationStore(locationTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} locationTranslation The location translation ID
         * @param {LocationTranslationUpdateRequest} [locationTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationUpdate(locationTranslation: string, locationTranslationUpdateRequest?: LocationTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationTranslationStore200Response> {
            return localVarFp.locationTranslationUpdate(locationTranslation, locationTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationTranslationApi - object-oriented interface
 * @export
 * @class LocationTranslationApi
 * @extends {BaseAPI}
 */
export class LocationTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} locationTranslation The location translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationTranslationApi
     */
    public locationTranslationDestroy(locationTranslation: string, options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationDestroy(locationTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationTranslationApi
     */
    public locationTranslationIndex(options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} locationTranslation The location translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationTranslationApi
     */
    public locationTranslationShow(locationTranslation: string, options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationShow(locationTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {LocationTranslationStoreRequest} locationTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationTranslationApi
     */
    public locationTranslationStore(locationTranslationStoreRequest: LocationTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationStore(locationTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} locationTranslation The location translation ID
     * @param {LocationTranslationUpdateRequest} [locationTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationTranslationApi
     */
    public locationTranslationUpdate(locationTranslation: string, locationTranslationUpdateRequest?: LocationTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationUpdate(locationTranslation, locationTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MarkdownApi - axios parameter creator
 * @export
 */
export const MarkdownApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownAllowedElements: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markdown/allowed-elements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownFromHtml: async (markdownFromHtmlRequest: MarkdownFromHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownFromHtmlRequest' is not null or undefined
            assertParamExists('markdownFromHtml', 'markdownFromHtmlRequest', markdownFromHtmlRequest)
            const localVarPath = `/markdown/from-html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownFromHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownIsMarkdown: async (markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownIsMarkdownRequest' is not null or undefined
            assertParamExists('markdownIsMarkdown', 'markdownIsMarkdownRequest', markdownIsMarkdownRequest)
            const localVarPath = `/markdown/is-markdown`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownIsMarkdownRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownPreview: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markdown/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownToHtml: async (markdownToHtmlRequest: MarkdownToHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownToHtmlRequest' is not null or undefined
            assertParamExists('markdownToHtml', 'markdownToHtmlRequest', markdownToHtmlRequest)
            const localVarPath = `/markdown/to-html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownToHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownValidate: async (markdownToHtmlRequest: MarkdownToHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownToHtmlRequest' is not null or undefined
            assertParamExists('markdownValidate', 'markdownToHtmlRequest', markdownToHtmlRequest)
            const localVarPath = `/markdown/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownToHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarkdownApi - functional programming interface
 * @export
 */
export const MarkdownApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarkdownApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownAllowedElements(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownAllowedElements(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownAllowedElements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownFromHtml(markdownFromHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownFromHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownIsMarkdown(markdownIsMarkdownRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownIsMarkdown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownPreview(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarkdownPreview200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownPreview(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownPreview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownToHtml(markdownToHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownToHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownValidate(markdownToHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownValidate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MarkdownApi - factory interface
 * @export
 */
export const MarkdownApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarkdownApiFp(configuration)
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownAllowedElements(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownAllowedElements(options).then((request) => request(axios, basePath));
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownFromHtml(markdownFromHtmlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownIsMarkdown(markdownIsMarkdownRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownPreview(options?: RawAxiosRequestConfig): AxiosPromise<MarkdownPreview200Response> {
            return localVarFp.markdownPreview(options).then((request) => request(axios, basePath));
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownToHtml(markdownToHtmlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownValidate(markdownToHtmlRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarkdownApi - object-oriented interface
 * @export
 * @class MarkdownApi
 * @extends {BaseAPI}
 */
export class MarkdownApi extends BaseAPI {
    /**
     * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
     * @summary Get allowed HTML tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownApi
     */
    public markdownAllowedElements(options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownAllowedElements(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
     * @summary Convert HTML to Markdown
     * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownApi
     */
    public markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownFromHtml(markdownFromHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
     * @summary Check if content is Markdown
     * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownApi
     */
    public markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownIsMarkdown(markdownIsMarkdownRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
     * @summary Preview Markdown content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownApi
     */
    public markdownPreview(options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownPreview(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
     * @summary Convert Markdown to HTML
     * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownApi
     */
    public markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownToHtml(markdownToHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates Markdown content without converting it, useful for form validation.
     * @summary Validate Markdown content
     * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownApi
     */
    public markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownValidate(markdownToHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi - axios parameter creator
 * @export
 */
export const MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownAllowedElements: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markdown/allowed-elements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownFromHtml: async (markdownFromHtmlRequest: MarkdownFromHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownFromHtmlRequest' is not null or undefined
            assertParamExists('markdownFromHtml', 'markdownFromHtmlRequest', markdownFromHtmlRequest)
            const localVarPath = `/markdown/from-html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownFromHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownIsMarkdown: async (markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownIsMarkdownRequest' is not null or undefined
            assertParamExists('markdownIsMarkdown', 'markdownIsMarkdownRequest', markdownIsMarkdownRequest)
            const localVarPath = `/markdown/is-markdown`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownIsMarkdownRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownPreview: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markdown/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownToHtml: async (markdownToHtmlRequest: MarkdownToHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownToHtmlRequest' is not null or undefined
            assertParamExists('markdownToHtml', 'markdownToHtmlRequest', markdownToHtmlRequest)
            const localVarPath = `/markdown/to-html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownToHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownValidate: async (markdownToHtmlRequest: MarkdownToHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownToHtmlRequest' is not null or undefined
            assertParamExists('markdownValidate', 'markdownToHtmlRequest', markdownToHtmlRequest)
            const localVarPath = `/markdown/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownToHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi - functional programming interface
 * @export
 */
export const MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownAllowedElements(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownAllowedElements(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownAllowedElements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownFromHtml(markdownFromHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownFromHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownIsMarkdown(markdownIsMarkdownRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownIsMarkdown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownPreview(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarkdownPreview200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownPreview(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownPreview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownToHtml(markdownToHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownToHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownValidate(markdownToHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownValidate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi - factory interface
 * @export
 */
export const MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(configuration)
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownAllowedElements(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownAllowedElements(options).then((request) => request(axios, basePath));
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownFromHtml(markdownFromHtmlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownIsMarkdown(markdownIsMarkdownRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownPreview(options?: RawAxiosRequestConfig): AxiosPromise<MarkdownPreview200Response> {
            return localVarFp.markdownPreview(options).then((request) => request(axios, basePath));
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownToHtml(markdownToHtmlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownValidate(markdownToHtmlRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi - object-oriented interface
 * @export
 * @class MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi
 * @extends {BaseAPI}
 */
export class MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi extends BaseAPI {
    /**
     * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
     * @summary Get allowed HTML tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi
     */
    public markdownAllowedElements(options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownAllowedElements(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
     * @summary Convert HTML to Markdown
     * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi
     */
    public markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownFromHtml(markdownFromHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
     * @summary Check if content is Markdown
     * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi
     */
    public markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownIsMarkdown(markdownIsMarkdownRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
     * @summary Preview Markdown content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi
     */
    public markdownPreview(options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownPreview(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
     * @summary Convert Markdown to HTML
     * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi
     */
    public markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownToHtml(markdownToHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates Markdown content without converting it, useful for form validation.
     * @summary Validate Markdown content
     * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi
     */
    public markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownValidate(markdownToHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MobileAppAuthenticationApi - axios parameter creator
 * @export
 */
export const MobileAppAuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Acquire a token for the user
         * @param {TokenAcquireRequest} tokenAcquireRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenAcquire: async (tokenAcquireRequest: TokenAcquireRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenAcquireRequest' is not null or undefined
            assertParamExists('tokenAcquire', 'tokenAcquireRequest', tokenAcquireRequest)
            const localVarPath = `/mobile/acquire-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenAcquireRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke all the token for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenWipe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mobile/wipe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MobileAppAuthenticationApi - functional programming interface
 * @export
 */
export const MobileAppAuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MobileAppAuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Acquire a token for the user
         * @param {TokenAcquireRequest} tokenAcquireRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenAcquire(tokenAcquireRequest: TokenAcquireRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenAcquire(tokenAcquireRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MobileAppAuthenticationApi.tokenAcquire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Revoke all the token for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenWipe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenWipe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MobileAppAuthenticationApi.tokenWipe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MobileAppAuthenticationApi - factory interface
 * @export
 */
export const MobileAppAuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MobileAppAuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary Acquire a token for the user
         * @param {TokenAcquireRequest} tokenAcquireRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenAcquire(tokenAcquireRequest: TokenAcquireRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.tokenAcquire(tokenAcquireRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke all the token for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenWipe(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tokenWipe(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MobileAppAuthenticationApi - object-oriented interface
 * @export
 * @class MobileAppAuthenticationApi
 * @extends {BaseAPI}
 */
export class MobileAppAuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Acquire a token for the user
     * @param {TokenAcquireRequest} tokenAcquireRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileAppAuthenticationApi
     */
    public tokenAcquire(tokenAcquireRequest: TokenAcquireRequest, options?: RawAxiosRequestConfig) {
        return MobileAppAuthenticationApiFp(this.configuration).tokenAcquire(tokenAcquireRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke all the token for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileAppAuthenticationApi
     */
    public tokenWipe(options?: RawAxiosRequestConfig) {
        return MobileAppAuthenticationApiFp(this.configuration).tokenWipe(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PartnerApi - axios parameter creator
 * @export
 */
export const PartnerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerDestroy: async (partner: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partner' is not null or undefined
            assertParamExists('partnerDestroy', 'partner', partner)
            const localVarPath = `/partner/{partner}`
                .replace(`{${"partner"}}`, encodeURIComponent(String(partner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/partner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerShow: async (partner: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partner' is not null or undefined
            assertParamExists('partnerShow', 'partner', partner)
            const localVarPath = `/partner/{partner}`
                .replace(`{${"partner"}}`, encodeURIComponent(String(partner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {PartnerStoreRequest} partnerStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerStore: async (partnerStoreRequest: PartnerStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerStoreRequest' is not null or undefined
            assertParamExists('partnerStore', 'partnerStoreRequest', partnerStoreRequest)
            const localVarPath = `/partner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partnerStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partner The partner ID
         * @param {PartnerStoreRequest} partnerStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerUpdate: async (partner: string, partnerStoreRequest: PartnerStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partner' is not null or undefined
            assertParamExists('partnerUpdate', 'partner', partner)
            // verify required parameter 'partnerStoreRequest' is not null or undefined
            assertParamExists('partnerUpdate', 'partnerStoreRequest', partnerStoreRequest)
            const localVarPath = `/partner/{partner}`
                .replace(`{${"partner"}}`, encodeURIComponent(String(partner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partnerStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnerApi - functional programming interface
 * @export
 */
export const PartnerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartnerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerDestroy(partner: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerDestroy(partner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerShow(partner: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerShow(partner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {PartnerStoreRequest} partnerStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerStore(partnerStoreRequest: PartnerStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerStore(partnerStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partner The partner ID
         * @param {PartnerStoreRequest} partnerStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerUpdate(partner: string, partnerStoreRequest: PartnerStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerUpdate(partner, partnerStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PartnerApi - factory interface
 * @export
 */
export const PartnerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartnerApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerDestroy(partner: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.partnerDestroy(partner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerIndex(options?: RawAxiosRequestConfig): AxiosPromise<PartnerIndex200Response> {
            return localVarFp.partnerIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerShow(partner: string, options?: RawAxiosRequestConfig): AxiosPromise<PartnerStore200Response> {
            return localVarFp.partnerShow(partner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {PartnerStoreRequest} partnerStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerStore(partnerStoreRequest: PartnerStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerStore200Response> {
            return localVarFp.partnerStore(partnerStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partner The partner ID
         * @param {PartnerStoreRequest} partnerStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerUpdate(partner: string, partnerStoreRequest: PartnerStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerStore200Response> {
            return localVarFp.partnerUpdate(partner, partnerStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartnerApi - object-oriented interface
 * @export
 * @class PartnerApi
 * @extends {BaseAPI}
 */
export class PartnerApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} partner The partner ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public partnerDestroy(partner: string, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerDestroy(partner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public partnerIndex(options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} partner The partner ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public partnerShow(partner: string, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerShow(partner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {PartnerStoreRequest} partnerStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public partnerStore(partnerStoreRequest: PartnerStoreRequest, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerStore(partnerStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} partner The partner ID
     * @param {PartnerStoreRequest} partnerStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public partnerUpdate(partner: string, partnerStoreRequest: PartnerStoreRequest, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerUpdate(partner, partnerStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PictureApi - axios parameter creator
 * @export
 */
export const PictureApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Attach an AvailableImage to a Detail
         * @param {string} detail The detail ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureAttachToDetail: async (detail: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detail' is not null or undefined
            assertParamExists('pictureAttachToDetail', 'detail', detail)
            const localVarPath = `/detail/{detail}/pictures`
                .replace(`{${"detail"}}`, encodeURIComponent(String(detail)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Attach an AvailableImage to an Item
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureAttachToItem: async (item: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('pictureAttachToItem', 'item', item)
            const localVarPath = `/item/{item}/pictures`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Attach an AvailableImage to a Partner
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureAttachToPartner: async (partner: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partner' is not null or undefined
            assertParamExists('pictureAttachToPartner', 'partner', partner)
            const localVarPath = `/partner/{partner}/pictures`
                .replace(`{${"partner"}}`, encodeURIComponent(String(partner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureDestroy: async (picture: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'picture' is not null or undefined
            assertParamExists('pictureDestroy', 'picture', picture)
            const localVarPath = `/picture/{picture}`
                .replace(`{${"picture"}}`, encodeURIComponent(String(picture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach a Picture from a Detail and convert it back to AvailableImage
         * @param {string} detail The detail ID
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureDetachFromDetail: async (detail: string, picture: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detail' is not null or undefined
            assertParamExists('pictureDetachFromDetail', 'detail', detail)
            // verify required parameter 'picture' is not null or undefined
            assertParamExists('pictureDetachFromDetail', 'picture', picture)
            const localVarPath = `/detail/{detail}/pictures/{picture}`
                .replace(`{${"detail"}}`, encodeURIComponent(String(detail)))
                .replace(`{${"picture"}}`, encodeURIComponent(String(picture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach a Picture from an Item and convert it back to AvailableImage
         * @param {string} item The item ID
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureDetachFromItem: async (item: string, picture: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('pictureDetachFromItem', 'item', item)
            // verify required parameter 'picture' is not null or undefined
            assertParamExists('pictureDetachFromItem', 'picture', picture)
            const localVarPath = `/item/{item}/pictures/{picture}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)))
                .replace(`{${"picture"}}`, encodeURIComponent(String(picture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach a Picture from a Partner and convert it back to AvailableImage
         * @param {string} partner The partner ID
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureDetachFromPartner: async (partner: string, picture: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partner' is not null or undefined
            assertParamExists('pictureDetachFromPartner', 'partner', partner)
            // verify required parameter 'picture' is not null or undefined
            assertParamExists('pictureDetachFromPartner', 'picture', picture)
            const localVarPath = `/partner/{partner}/pictures/{picture}`
                .replace(`{${"partner"}}`, encodeURIComponent(String(partner)))
                .replace(`{${"picture"}}`, encodeURIComponent(String(picture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the file to the caller for download
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureDownload: async (picture: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'picture' is not null or undefined
            assertParamExists('pictureDownload', 'picture', picture)
            const localVarPath = `/picture/{picture}/download`
                .replace(`{${"picture"}}`, encodeURIComponent(String(picture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/picture`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureShow: async (picture: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'picture' is not null or undefined
            assertParamExists('pictureShow', 'picture', picture)
            const localVarPath = `/picture/{picture}`
                .replace(`{${"picture"}}`, encodeURIComponent(String(picture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} picture The picture ID
         * @param {PictureUpdateRequest} pictureUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureUpdate: async (picture: string, pictureUpdateRequest: PictureUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'picture' is not null or undefined
            assertParamExists('pictureUpdate', 'picture', picture)
            // verify required parameter 'pictureUpdateRequest' is not null or undefined
            assertParamExists('pictureUpdate', 'pictureUpdateRequest', pictureUpdateRequest)
            const localVarPath = `/picture/{picture}`
                .replace(`{${"picture"}}`, encodeURIComponent(String(picture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pictureUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the picture file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureView: async (picture: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'picture' is not null or undefined
            assertParamExists('pictureView', 'picture', picture)
            const localVarPath = `/picture/{picture}/view`
                .replace(`{${"picture"}}`, encodeURIComponent(String(picture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PictureApi - functional programming interface
 * @export
 */
export const PictureApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PictureApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Attach an AvailableImage to a Detail
         * @param {string} detail The detail ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureAttachToDetail(detail: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureAttachToDetail(detail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureAttachToDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Attach an AvailableImage to an Item
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureAttachToItem(item: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureAttachToItem(item, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureAttachToItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Attach an AvailableImage to a Partner
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureAttachToPartner(partner: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureAttachToPartner(partner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureAttachToPartner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureDestroy(picture: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureDestroy(picture, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Detach a Picture from a Detail and convert it back to AvailableImage
         * @param {string} detail The detail ID
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureDetachFromDetail(detail: string, picture: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureDetachFromDetail(detail, picture, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureDetachFromDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Detach a Picture from an Item and convert it back to AvailableImage
         * @param {string} item The item ID
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureDetachFromItem(item: string, picture: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureDetachFromItem(item, picture, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureDetachFromItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Detach a Picture from a Partner and convert it back to AvailableImage
         * @param {string} partner The partner ID
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureDetachFromPartner(partner: string, picture: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureDetachFromPartner(partner, picture, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureDetachFromPartner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the file to the caller for download
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureDownload(picture: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureDownload(picture, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureDownload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PictureIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureShow(picture: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PictureShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureShow(picture, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} picture The picture ID
         * @param {PictureUpdateRequest} pictureUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureUpdate(picture: string, pictureUpdateRequest: PictureUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PictureShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureUpdate(picture, pictureUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the picture file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pictureView(picture: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pictureView(picture, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PictureApi.pictureView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PictureApi - factory interface
 * @export
 */
export const PictureApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PictureApiFp(configuration)
    return {
        /**
         * 
         * @summary Attach an AvailableImage to a Detail
         * @param {string} detail The detail ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureAttachToDetail(detail: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.pictureAttachToDetail(detail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Attach an AvailableImage to an Item
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureAttachToItem(item: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.pictureAttachToItem(item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Attach an AvailableImage to a Partner
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureAttachToPartner(partner: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.pictureAttachToPartner(partner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureDestroy(picture: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pictureDestroy(picture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detach a Picture from a Detail and convert it back to AvailableImage
         * @param {string} detail The detail ID
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureDetachFromDetail(detail: string, picture: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.pictureDetachFromDetail(detail, picture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detach a Picture from an Item and convert it back to AvailableImage
         * @param {string} item The item ID
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureDetachFromItem(item: string, picture: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.pictureDetachFromItem(item, picture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detach a Picture from a Partner and convert it back to AvailableImage
         * @param {string} partner The partner ID
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureDetachFromPartner(partner: string, picture: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.pictureDetachFromPartner(partner, picture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the file to the caller for download
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureDownload(picture: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.pictureDownload(picture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureIndex(options?: RawAxiosRequestConfig): AxiosPromise<PictureIndex200Response> {
            return localVarFp.pictureIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureShow(picture: string, options?: RawAxiosRequestConfig): AxiosPromise<PictureShow200Response> {
            return localVarFp.pictureShow(picture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} picture The picture ID
         * @param {PictureUpdateRequest} pictureUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureUpdate(picture: string, pictureUpdateRequest: PictureUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<PictureShow200Response> {
            return localVarFp.pictureUpdate(picture, pictureUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the picture file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} picture The picture ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureView(picture: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.pictureView(picture, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PictureApi - object-oriented interface
 * @export
 * @class PictureApi
 * @extends {BaseAPI}
 */
export class PictureApi extends BaseAPI {
    /**
     * 
     * @summary Attach an AvailableImage to a Detail
     * @param {string} detail The detail ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureAttachToDetail(detail: string, options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureAttachToDetail(detail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Attach an AvailableImage to an Item
     * @param {string} item The item ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureAttachToItem(item: string, options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureAttachToItem(item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Attach an AvailableImage to a Partner
     * @param {string} partner The partner ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureAttachToPartner(partner: string, options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureAttachToPartner(partner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} picture The picture ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureDestroy(picture: string, options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureDestroy(picture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detach a Picture from a Detail and convert it back to AvailableImage
     * @param {string} detail The detail ID
     * @param {string} picture The picture ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureDetachFromDetail(detail: string, picture: string, options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureDetachFromDetail(detail, picture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detach a Picture from an Item and convert it back to AvailableImage
     * @param {string} item The item ID
     * @param {string} picture The picture ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureDetachFromItem(item: string, picture: string, options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureDetachFromItem(item, picture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detach a Picture from a Partner and convert it back to AvailableImage
     * @param {string} partner The partner ID
     * @param {string} picture The picture ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureDetachFromPartner(partner: string, picture: string, options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureDetachFromPartner(partner, picture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the file to the caller for download
     * @param {string} picture The picture ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureDownload(picture: string, options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureDownload(picture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureIndex(options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} picture The picture ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureShow(picture: string, options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureShow(picture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} picture The picture ID
     * @param {PictureUpdateRequest} pictureUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureUpdate(picture: string, pictureUpdateRequest: PictureUpdateRequest, options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureUpdate(picture, pictureUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the picture file for direct viewing (e.g., for use in <img> src attribute)
     * @param {string} picture The picture ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PictureApi
     */
    public pictureView(picture: string, options?: RawAxiosRequestConfig) {
        return PictureApiFp(this.configuration).pictureView(picture, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectApi - axios parameter creator
 * @export
 */
export const ProjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} project The project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDestroy: async (project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectDestroy', 'project', project)
            const localVarPath = `/project/{project}`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all enabled projects (Enabled + launched)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEnabled: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project/enabled`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggle Enable/disable on a project
         * @param {string} project The project ID
         * @param {ProjectSetEnabledRequest} projectSetEnabledRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSetEnabled: async (project: string, projectSetEnabledRequest: ProjectSetEnabledRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectSetEnabled', 'project', project)
            // verify required parameter 'projectSetEnabledRequest' is not null or undefined
            assertParamExists('projectSetEnabled', 'projectSetEnabledRequest', projectSetEnabledRequest)
            const localVarPath = `/project/{project}/enabled`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectSetEnabledRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggle Launched/not-launched on a project
         * @param {string} project The project ID
         * @param {ProjectSetLaunchedRequest} [projectSetLaunchedRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSetLaunched: async (project: string, projectSetLaunchedRequest?: ProjectSetLaunchedRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectSetLaunched', 'project', project)
            const localVarPath = `/project/{project}/launched`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectSetLaunchedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} project The project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectShow: async (project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectShow', 'project', project)
            const localVarPath = `/project/{project}`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ProjectStoreRequest} projectStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStore: async (projectStoreRequest: ProjectStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectStoreRequest' is not null or undefined
            assertParamExists('projectStore', 'projectStoreRequest', projectStoreRequest)
            const localVarPath = `/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} project The project ID
         * @param {ProjectStoreRequest} projectStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectUpdate: async (project: string, projectStoreRequest: ProjectStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectUpdate', 'project', project)
            // verify required parameter 'projectStoreRequest' is not null or undefined
            assertParamExists('projectUpdate', 'projectStoreRequest', projectStoreRequest)
            const localVarPath = `/project/{project}`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} project The project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectDestroy(project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectDestroy(project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all enabled projects (Enabled + launched)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectEnabled(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectEnabled200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectEnabled(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectEnabled']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectEnabled200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Toggle Enable/disable on a project
         * @param {string} project The project ID
         * @param {ProjectSetEnabledRequest} projectSetEnabledRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectSetEnabled(project: string, projectSetEnabledRequest: ProjectSetEnabledRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSetLaunched200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectSetEnabled(project, projectSetEnabledRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectSetEnabled']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Toggle Launched/not-launched on a project
         * @param {string} project The project ID
         * @param {ProjectSetLaunchedRequest} [projectSetLaunchedRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectSetLaunched(project: string, projectSetLaunchedRequest?: ProjectSetLaunchedRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSetLaunched200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectSetLaunched(project, projectSetLaunchedRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectSetLaunched']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} project The project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectShow(project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSetLaunched200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectShow(project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ProjectStoreRequest} projectStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectStore(projectStoreRequest: ProjectStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSetLaunched200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectStore(projectStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} project The project ID
         * @param {ProjectStoreRequest} projectStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectUpdate(project: string, projectStoreRequest: ProjectStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSetLaunched200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectUpdate(project, projectStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} project The project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDestroy(project: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.projectDestroy(project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all enabled projects (Enabled + launched)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEnabled(options?: RawAxiosRequestConfig): AxiosPromise<ProjectEnabled200Response> {
            return localVarFp.projectEnabled(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectIndex(options?: RawAxiosRequestConfig): AxiosPromise<ProjectEnabled200Response> {
            return localVarFp.projectIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Toggle Enable/disable on a project
         * @param {string} project The project ID
         * @param {ProjectSetEnabledRequest} projectSetEnabledRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSetEnabled(project: string, projectSetEnabledRequest: ProjectSetEnabledRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectSetLaunched200Response> {
            return localVarFp.projectSetEnabled(project, projectSetEnabledRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Toggle Launched/not-launched on a project
         * @param {string} project The project ID
         * @param {ProjectSetLaunchedRequest} [projectSetLaunchedRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSetLaunched(project: string, projectSetLaunchedRequest?: ProjectSetLaunchedRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectSetLaunched200Response> {
            return localVarFp.projectSetLaunched(project, projectSetLaunchedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} project The project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectShow(project: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectSetLaunched200Response> {
            return localVarFp.projectShow(project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ProjectStoreRequest} projectStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStore(projectStoreRequest: ProjectStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectSetLaunched200Response> {
            return localVarFp.projectStore(projectStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} project The project ID
         * @param {ProjectStoreRequest} projectStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectUpdate(project: string, projectStoreRequest: ProjectStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectSetLaunched200Response> {
            return localVarFp.projectUpdate(project, projectStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} project The project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectDestroy(project: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectDestroy(project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all enabled projects (Enabled + launched)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectEnabled(options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectEnabled(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectIndex(options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Toggle Enable/disable on a project
     * @param {string} project The project ID
     * @param {ProjectSetEnabledRequest} projectSetEnabledRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectSetEnabled(project: string, projectSetEnabledRequest: ProjectSetEnabledRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectSetEnabled(project, projectSetEnabledRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Toggle Launched/not-launched on a project
     * @param {string} project The project ID
     * @param {ProjectSetLaunchedRequest} [projectSetLaunchedRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectSetLaunched(project: string, projectSetLaunchedRequest?: ProjectSetLaunchedRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectSetLaunched(project, projectSetLaunchedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} project The project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectShow(project: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectShow(project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {ProjectStoreRequest} projectStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectStore(projectStoreRequest: ProjectStoreRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectStore(projectStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} project The project ID
     * @param {ProjectStoreRequest} projectStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectUpdate(project: string, projectStoreRequest: ProjectStoreRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectUpdate(project, projectStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProvinceApi - axios parameter creator
 * @export
 */
export const ProvinceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified province
         * @param {string} province The province ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceDestroy: async (province: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'province' is not null or undefined
            assertParamExists('provinceDestroy', 'province', province)
            const localVarPath = `/province/{province}`
                .replace(`{${"province"}}`, encodeURIComponent(String(province)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of provinces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/province`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified province
         * @param {string} province The province ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceShow: async (province: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'province' is not null or undefined
            assertParamExists('provinceShow', 'province', province)
            const localVarPath = `/province/{province}`
                .replace(`{${"province"}}`, encodeURIComponent(String(province)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created province
         * @param {LocationStoreRequest} locationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceStore: async (locationStoreRequest: LocationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationStoreRequest' is not null or undefined
            assertParamExists('provinceStore', 'locationStoreRequest', locationStoreRequest)
            const localVarPath = `/province`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified province
         * @param {string} province The province ID
         * @param {LocationUpdateRequest} locationUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceUpdate: async (province: string, locationUpdateRequest: LocationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'province' is not null or undefined
            assertParamExists('provinceUpdate', 'province', province)
            // verify required parameter 'locationUpdateRequest' is not null or undefined
            assertParamExists('provinceUpdate', 'locationUpdateRequest', locationUpdateRequest)
            const localVarPath = `/province/{province}`
                .replace(`{${"province"}}`, encodeURIComponent(String(province)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvinceApi - functional programming interface
 * @export
 */
export const ProvinceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProvinceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified province
         * @param {string} province The province ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceDestroy(province: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceDestroy(province, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of provinces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified province
         * @param {string} province The province ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceShow(province: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceShow(province, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created province
         * @param {LocationStoreRequest} locationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceStore(locationStoreRequest: LocationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceStore(locationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified province
         * @param {string} province The province ID
         * @param {LocationUpdateRequest} locationUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceUpdate(province: string, locationUpdateRequest: LocationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceUpdate(province, locationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProvinceApi - factory interface
 * @export
 */
export const ProvinceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProvinceApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified province
         * @param {string} province The province ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceDestroy(province: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.provinceDestroy(province, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of provinces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceIndex(options?: RawAxiosRequestConfig): AxiosPromise<ProvinceIndex200Response> {
            return localVarFp.provinceIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified province
         * @param {string} province The province ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceShow(province: string, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceStore201Response> {
            return localVarFp.provinceShow(province, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created province
         * @param {LocationStoreRequest} locationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceStore(locationStoreRequest: LocationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceStore201Response> {
            return localVarFp.provinceStore(locationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified province
         * @param {string} province The province ID
         * @param {LocationUpdateRequest} locationUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceUpdate(province: string, locationUpdateRequest: LocationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceStore201Response> {
            return localVarFp.provinceUpdate(province, locationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProvinceApi - object-oriented interface
 * @export
 * @class ProvinceApi
 * @extends {BaseAPI}
 */
export class ProvinceApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified province
     * @param {string} province The province ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceApi
     */
    public provinceDestroy(province: string, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceDestroy(province, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of provinces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceApi
     */
    public provinceIndex(options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified province
     * @param {string} province The province ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceApi
     */
    public provinceShow(province: string, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceShow(province, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created province
     * @param {LocationStoreRequest} locationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceApi
     */
    public provinceStore(locationStoreRequest: LocationStoreRequest, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceStore(locationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified province
     * @param {string} province The province ID
     * @param {LocationUpdateRequest} locationUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceApi
     */
    public provinceUpdate(province: string, locationUpdateRequest: LocationUpdateRequest, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceUpdate(province, locationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProvinceTranslationApi - axios parameter creator
 * @export
 */
export const ProvinceTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationDestroy: async (provinceTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provinceTranslation' is not null or undefined
            assertParamExists('provinceTranslationDestroy', 'provinceTranslation', provinceTranslation)
            const localVarPath = `/province-translation/{provinceTranslation}`
                .replace(`{${"provinceTranslation"}}`, encodeURIComponent(String(provinceTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/province-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationShow: async (provinceTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provinceTranslation' is not null or undefined
            assertParamExists('provinceTranslationShow', 'provinceTranslation', provinceTranslation)
            const localVarPath = `/province-translation/{provinceTranslation}`
                .replace(`{${"provinceTranslation"}}`, encodeURIComponent(String(provinceTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ProvinceTranslationStoreRequest} provinceTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationStore: async (provinceTranslationStoreRequest: ProvinceTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provinceTranslationStoreRequest' is not null or undefined
            assertParamExists('provinceTranslationStore', 'provinceTranslationStoreRequest', provinceTranslationStoreRequest)
            const localVarPath = `/province-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provinceTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} provinceTranslation The province translation ID
         * @param {ProvinceTranslationUpdateRequest} [provinceTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationUpdate: async (provinceTranslation: string, provinceTranslationUpdateRequest?: ProvinceTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provinceTranslation' is not null or undefined
            assertParamExists('provinceTranslationUpdate', 'provinceTranslation', provinceTranslation)
            const localVarPath = `/province-translation/{provinceTranslation}`
                .replace(`{${"provinceTranslation"}}`, encodeURIComponent(String(provinceTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provinceTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvinceTranslationApi - functional programming interface
 * @export
 */
export const ProvinceTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProvinceTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationDestroy(provinceTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationDestroy(provinceTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationShow(provinceTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationShow(provinceTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ProvinceTranslationStoreRequest} provinceTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationStore(provinceTranslationStoreRequest: ProvinceTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationStore(provinceTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} provinceTranslation The province translation ID
         * @param {ProvinceTranslationUpdateRequest} [provinceTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationUpdate(provinceTranslation: string, provinceTranslationUpdateRequest?: ProvinceTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationUpdate(provinceTranslation, provinceTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProvinceTranslationApi - factory interface
 * @export
 */
export const ProvinceTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProvinceTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationDestroy(provinceTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.provinceTranslationDestroy(provinceTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<ProvinceTranslationIndex200Response> {
            return localVarFp.provinceTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationShow(provinceTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceTranslationStore200Response> {
            return localVarFp.provinceTranslationShow(provinceTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ProvinceTranslationStoreRequest} provinceTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationStore(provinceTranslationStoreRequest: ProvinceTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceTranslationStore200Response> {
            return localVarFp.provinceTranslationStore(provinceTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} provinceTranslation The province translation ID
         * @param {ProvinceTranslationUpdateRequest} [provinceTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationUpdate(provinceTranslation: string, provinceTranslationUpdateRequest?: ProvinceTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceTranslationStore200Response> {
            return localVarFp.provinceTranslationUpdate(provinceTranslation, provinceTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProvinceTranslationApi - object-oriented interface
 * @export
 * @class ProvinceTranslationApi
 * @extends {BaseAPI}
 */
export class ProvinceTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} provinceTranslation The province translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceTranslationApi
     */
    public provinceTranslationDestroy(provinceTranslation: string, options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationDestroy(provinceTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceTranslationApi
     */
    public provinceTranslationIndex(options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} provinceTranslation The province translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceTranslationApi
     */
    public provinceTranslationShow(provinceTranslation: string, options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationShow(provinceTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {ProvinceTranslationStoreRequest} provinceTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceTranslationApi
     */
    public provinceTranslationStore(provinceTranslationStoreRequest: ProvinceTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationStore(provinceTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} provinceTranslation The province translation ID
     * @param {ProvinceTranslationUpdateRequest} [provinceTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceTranslationApi
     */
    public provinceTranslationUpdate(provinceTranslation: string, provinceTranslationUpdateRequest?: ProvinceTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationUpdate(provinceTranslation, provinceTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagApi - axios parameter creator
 * @export
 */
export const TagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDestroy: async (tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('tagDestroy', 'tag', tag)
            const localVarPath = `/tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tags for a specific item
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagForItem: async (item: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('tagForItem', 'item', item)
            const localVarPath = `/tag/for-item/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagShow: async (tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('tagShow', 'tag', tag)
            const localVarPath = `/tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {TagStoreRequest} tagStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagStore: async (tagStoreRequest: TagStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagStoreRequest' is not null or undefined
            assertParamExists('tagStore', 'tagStoreRequest', tagStoreRequest)
            const localVarPath = `/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} tag The tag ID
         * @param {TagStoreRequest} tagStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagUpdate: async (tag: string, tagStoreRequest: TagStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('tagUpdate', 'tag', tag)
            // verify required parameter 'tagStoreRequest' is not null or undefined
            assertParamExists('tagUpdate', 'tagStoreRequest', tagStoreRequest)
            const localVarPath = `/tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagApi - functional programming interface
 * @export
 */
export const TagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagDestroy(tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagDestroy(tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get tags for a specific item
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagForItem(item: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagForItem(item, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagForItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagShow(tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagShow(tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {TagStoreRequest} tagStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagStore(tagStoreRequest: TagStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagStore(tagStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} tag The tag ID
         * @param {TagStoreRequest} tagStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagUpdate(tag: string, tagStoreRequest: TagStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagUpdate(tag, tagStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagApi - factory interface
 * @export
 */
export const TagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDestroy(tag: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tagDestroy(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tags for a specific item
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagForItem(item: string, options?: RawAxiosRequestConfig): AxiosPromise<TagIndex200Response> {
            return localVarFp.tagForItem(item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagIndex(options?: RawAxiosRequestConfig): AxiosPromise<TagIndex200Response> {
            return localVarFp.tagIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagShow(tag: string, options?: RawAxiosRequestConfig): AxiosPromise<TagStore200Response> {
            return localVarFp.tagShow(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {TagStoreRequest} tagStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagStore(tagStoreRequest: TagStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<TagStore200Response> {
            return localVarFp.tagStore(tagStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} tag The tag ID
         * @param {TagStoreRequest} tagStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagUpdate(tag: string, tagStoreRequest: TagStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<TagStore200Response> {
            return localVarFp.tagUpdate(tag, tagStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagApi - object-oriented interface
 * @export
 * @class TagApi
 * @extends {BaseAPI}
 */
export class TagApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} tag The tag ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public tagDestroy(tag: string, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagDestroy(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tags for a specific item
     * @param {string} item The item ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public tagForItem(item: string, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagForItem(item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public tagIndex(options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} tag The tag ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public tagShow(tag: string, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagShow(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {TagStoreRequest} tagStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public tagStore(tagStoreRequest: TagStoreRequest, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagStore(tagStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} tag The tag ID
     * @param {TagStoreRequest} tagStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public tagUpdate(tag: string, tagStoreRequest: TagStoreRequest, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagUpdate(tag, tagStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



