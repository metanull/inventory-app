/* tslint:disable */
/* eslint-disable */
/**
 * Inventory-App
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddressIndex200Response
 */
export interface AddressIndex200Response {
    /**
     * 
     * @type {Array<AddressResource>}
     * @memberof AddressIndex200Response
     */
    'data': Array<AddressResource>;
    /**
     * 
     * @type {AddressIndex200ResponseLinks}
     * @memberof AddressIndex200Response
     */
    'links': AddressIndex200ResponseLinks;
    /**
     * 
     * @type {AddressIndex200ResponseMeta}
     * @memberof AddressIndex200Response
     */
    'meta': AddressIndex200ResponseMeta;
}
/**
 * 
 * @export
 * @interface AddressIndex200ResponseLinks
 */
export interface AddressIndex200ResponseLinks {
    /**
     * 
     * @type {string}
     * @memberof AddressIndex200ResponseLinks
     */
    'first': string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressIndex200ResponseLinks
     */
    'last': string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressIndex200ResponseLinks
     */
    'prev': string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressIndex200ResponseLinks
     */
    'next': string | null;
}
/**
 * 
 * @export
 * @interface AddressIndex200ResponseMeta
 */
export interface AddressIndex200ResponseMeta {
    /**
     * 
     * @type {number}
     * @memberof AddressIndex200ResponseMeta
     */
    'current_page': number;
    /**
     * 
     * @type {number}
     * @memberof AddressIndex200ResponseMeta
     */
    'from': number | null;
    /**
     * 
     * @type {number}
     * @memberof AddressIndex200ResponseMeta
     */
    'last_page': number;
    /**
     * Generated paginator links.
     * @type {Array<AddressIndex200ResponseMetaLinksInner>}
     * @memberof AddressIndex200ResponseMeta
     */
    'links': Array<AddressIndex200ResponseMetaLinksInner>;
    /**
     * Base path for paginator generated URLs.
     * @type {string}
     * @memberof AddressIndex200ResponseMeta
     */
    'path': string | null;
    /**
     * Number of items shown per page.
     * @type {number}
     * @memberof AddressIndex200ResponseMeta
     */
    'per_page': number;
    /**
     * Number of the last item in the slice.
     * @type {number}
     * @memberof AddressIndex200ResponseMeta
     */
    'to': number | null;
    /**
     * Total number of items being paginated.
     * @type {number}
     * @memberof AddressIndex200ResponseMeta
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface AddressIndex200ResponseMetaLinksInner
 */
export interface AddressIndex200ResponseMetaLinksInner {
    /**
     * 
     * @type {string}
     * @memberof AddressIndex200ResponseMetaLinksInner
     */
    'url': string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressIndex200ResponseMetaLinksInner
     */
    'label': string;
    /**
     * 
     * @type {boolean}
     * @memberof AddressIndex200ResponseMetaLinksInner
     */
    'active': boolean;
}
/**
 * 
 * @export
 * @interface AddressResource
 */
export interface AddressResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof AddressResource
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     * @type {string}
     * @memberof AddressResource
     */
    'internal_name': string;
    /**
     * The country this address belongs to (CountryResource id)
     * @type {string}
     * @memberof AddressResource
     */
    'country_id': string;
    /**
     * Translations for this address (AddressTranslationResource[])
     * @type {Array<AddressTranslationResource>}
     * @memberof AddressResource
     */
    'translations'?: Array<AddressTranslationResource>;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof AddressResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof AddressResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface AddressStore201Response
 */
export interface AddressStore201Response {
    /**
     * 
     * @type {AddressResource}
     * @memberof AddressStore201Response
     */
    'data': AddressResource;
}
/**
 * 
 * @export
 * @interface AddressStoreRequest
 */
export interface AddressStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressStoreRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {number}
     * @memberof AddressStoreRequest
     */
    'country_id': number;
    /**
     * 
     * @type {Array<AddressStoreRequestTranslationsInner>}
     * @memberof AddressStoreRequest
     */
    'translations'?: Array<AddressStoreRequestTranslationsInner>;
}
/**
 * 
 * @export
 * @interface AddressStoreRequestTranslationsInner
 */
export interface AddressStoreRequestTranslationsInner {
    /**
     * 
     * @type {number}
     * @memberof AddressStoreRequestTranslationsInner
     */
    'language_id': number;
    /**
     * 
     * @type {string}
     * @memberof AddressStoreRequestTranslationsInner
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof AddressStoreRequestTranslationsInner
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface AddressTranslationIndex200Response
 */
export interface AddressTranslationIndex200Response {
    /**
     * 
     * @type {Array<AddressTranslationResource>}
     * @memberof AddressTranslationIndex200Response
     */
    'data': Array<AddressTranslationResource>;
}
/**
 * 
 * @export
 * @interface AddressTranslationResource
 */
export interface AddressTranslationResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof AddressTranslationResource
     */
    'id': string;
    /**
     * The address this translation belongs to (AddressResource id)
     * @type {string}
     * @memberof AddressTranslationResource
     */
    'address_id': string;
    /**
     * The language of this translation (LanguageResource id)
     * @type {string}
     * @memberof AddressTranslationResource
     */
    'language_id': string;
    /**
     * The address translation text
     * @type {string}
     * @memberof AddressTranslationResource
     */
    'address': string;
    /**
     * The description of the address translation
     * @type {string}
     * @memberof AddressTranslationResource
     */
    'description': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof AddressTranslationResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof AddressTranslationResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface AddressTranslationStore200Response
 */
export interface AddressTranslationStore200Response {
    /**
     * 
     * @type {AddressTranslationResource}
     * @memberof AddressTranslationStore200Response
     */
    'data': AddressTranslationResource;
}
/**
 * 
 * @export
 * @interface AddressTranslationStoreRequest
 */
export interface AddressTranslationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationStoreRequest
     */
    'address_id': string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationStoreRequest
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationStoreRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface AddressTranslationUpdateRequest
 */
export interface AddressTranslationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationUpdateRequest
     */
    'address_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationUpdateRequest
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressTranslationUpdateRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface AddressUpdateRequest
 */
export interface AddressUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressUpdateRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdateRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {number}
     * @memberof AddressUpdateRequest
     */
    'country_id': number;
    /**
     * 
     * @type {Array<AddressUpdateRequestTranslationsInner>}
     * @memberof AddressUpdateRequest
     */
    'translations'?: Array<AddressUpdateRequestTranslationsInner>;
}
/**
 * 
 * @export
 * @interface AddressUpdateRequestTranslationsInner
 */
export interface AddressUpdateRequestTranslationsInner {
    /**
     * 
     * @type {number}
     * @memberof AddressUpdateRequestTranslationsInner
     */
    'language_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdateRequestTranslationsInner
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdateRequestTranslationsInner
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface ArtistResource
 */
export interface ArtistResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof ArtistResource
     */
    'id': string;
    /**
     * The name of the artist
     * @type {string}
     * @memberof ArtistResource
     */
    'name': string;
    /**
     * The place of birth of the artist
     * @type {string}
     * @memberof ArtistResource
     */
    'place_of_birth': string | null;
    /**
     * The place of death of the artist
     * @type {string}
     * @memberof ArtistResource
     */
    'place_of_death': string | null;
    /**
     * The date of birth of the artist
     * @type {string}
     * @memberof ArtistResource
     */
    'date_of_birth': string | null;
    /**
     * The date of death of the artist
     * @type {string}
     * @memberof ArtistResource
     */
    'date_of_death': string | null;
    /**
     * The period of activity of the artist
     * @type {string}
     * @memberof ArtistResource
     */
    'period_of_activity': string | null;
    /**
     * A name for this resource, for internal use only.
     * @type {string}
     * @memberof ArtistResource
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     * @type {string}
     * @memberof ArtistResource
     */
    'backward_compatibility': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof ArtistResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof ArtistResource
     */
    'updated_at': string | null;
    /**
     * Items associated with this artist (ItemResource[])
     * @type {Array<ItemResource>}
     * @memberof ArtistResource
     */
    'items'?: Array<ItemResource>;
}
/**
 * 
 * @export
 * @interface AuthorResource
 */
export interface AuthorResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof AuthorResource
     */
    'id': string;
    /**
     * The name of the author
     * @type {string}
     * @memberof AuthorResource
     */
    'name': string;
    /**
     * A name for this resource, for internal use only.
     * @type {string}
     * @memberof AuthorResource
     */
    'internal_name': string | null;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     * @type {string}
     * @memberof AuthorResource
     */
    'backward_compatibility': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof AuthorResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof AuthorResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface AvailableImageIndex200Response
 */
export interface AvailableImageIndex200Response {
    /**
     * 
     * @type {Array<AvailableImageResource>}
     * @memberof AvailableImageIndex200Response
     */
    'data': Array<AvailableImageResource>;
    /**
     * 
     * @type {AddressIndex200ResponseLinks}
     * @memberof AvailableImageIndex200Response
     */
    'links': AddressIndex200ResponseLinks;
    /**
     * 
     * @type {AddressIndex200ResponseMeta}
     * @memberof AvailableImageIndex200Response
     */
    'meta': AddressIndex200ResponseMeta;
}
/**
 * 
 * @export
 * @interface AvailableImageResource
 */
export interface AvailableImageResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof AvailableImageResource
     */
    'id': string;
    /**
     * The path to the picture file
     * @type {string}
     * @memberof AvailableImageResource
     */
    'path': string | null;
    /**
     * A user defined comment associated with the file
     * @type {string}
     * @memberof AvailableImageResource
     */
    'comment': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof AvailableImageResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof AvailableImageResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface AvailableImageShow200Response
 */
export interface AvailableImageShow200Response {
    /**
     * 
     * @type {AvailableImageResource}
     * @memberof AvailableImageShow200Response
     */
    'data': AvailableImageResource;
}
/**
 * 
 * @export
 * @interface AvailableImageUpdateRequest
 */
export interface AvailableImageUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof AvailableImageUpdateRequest
     */
    'comment'?: string | null;
}
/**
 * 
 * @export
 * @interface CollectionAttachItem200Response
 */
export interface CollectionAttachItem200Response {
    /**
     * 
     * @type {boolean}
     * @memberof CollectionAttachItem200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof CollectionAttachItem200Response
     */
    'message': CollectionAttachItem200ResponseMessageEnum;
}

export const CollectionAttachItem200ResponseMessageEnum = {
    ItemAttachedToCollectionSuccessfully: 'Item attached to collection successfully'
} as const;

export type CollectionAttachItem200ResponseMessageEnum = typeof CollectionAttachItem200ResponseMessageEnum[keyof typeof CollectionAttachItem200ResponseMessageEnum];

/**
 * 
 * @export
 * @interface CollectionAttachItemRequest
 */
export interface CollectionAttachItemRequest {
    /**
     * 
     * @type {string}
     * @memberof CollectionAttachItemRequest
     */
    'item_id': string;
}
/**
 * 
 * @export
 * @interface CollectionAttachItems200Response
 */
export interface CollectionAttachItems200Response {
    /**
     * 
     * @type {boolean}
     * @memberof CollectionAttachItems200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof CollectionAttachItems200Response
     */
    'message': CollectionAttachItems200ResponseMessageEnum;
}

export const CollectionAttachItems200ResponseMessageEnum = {
    ItemsAttachedToCollectionSuccessfully: 'Items attached to collection successfully'
} as const;

export type CollectionAttachItems200ResponseMessageEnum = typeof CollectionAttachItems200ResponseMessageEnum[keyof typeof CollectionAttachItems200ResponseMessageEnum];

/**
 * 
 * @export
 * @interface CollectionAttachItemsRequest
 */
export interface CollectionAttachItemsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CollectionAttachItemsRequest
     */
    'item_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface CollectionByType200Response
 */
export interface CollectionByType200Response {
    /**
     * 
     * @type {Array<CollectionResource>}
     * @memberof CollectionByType200Response
     */
    'data': Array<CollectionResource>;
}
/**
 * 
 * @export
 * @interface CollectionDetachItem200Response
 */
export interface CollectionDetachItem200Response {
    /**
     * 
     * @type {boolean}
     * @memberof CollectionDetachItem200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof CollectionDetachItem200Response
     */
    'message': CollectionDetachItem200ResponseMessageEnum;
}

export const CollectionDetachItem200ResponseMessageEnum = {
    ItemDetachedFromCollectionSuccessfully: 'Item detached from collection successfully'
} as const;

export type CollectionDetachItem200ResponseMessageEnum = typeof CollectionDetachItem200ResponseMessageEnum[keyof typeof CollectionDetachItem200ResponseMessageEnum];

/**
 * 
 * @export
 * @interface CollectionDetachItems200Response
 */
export interface CollectionDetachItems200Response {
    /**
     * 
     * @type {boolean}
     * @memberof CollectionDetachItems200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof CollectionDetachItems200Response
     */
    'message': CollectionDetachItems200ResponseMessageEnum;
}

export const CollectionDetachItems200ResponseMessageEnum = {
    ItemsDetachedFromCollectionSuccessfully: 'Items detached from collection successfully'
} as const;

export type CollectionDetachItems200ResponseMessageEnum = typeof CollectionDetachItems200ResponseMessageEnum[keyof typeof CollectionDetachItems200ResponseMessageEnum];

/**
 * 
 * @export
 * @interface CollectionIndex200Response
 */
export interface CollectionIndex200Response {
    /**
     * 
     * @type {Array<CollectionResource>}
     * @memberof CollectionIndex200Response
     */
    'data': Array<CollectionResource>;
    /**
     * 
     * @type {AddressIndex200ResponseLinks}
     * @memberof CollectionIndex200Response
     */
    'links': AddressIndex200ResponseLinks;
    /**
     * 
     * @type {AddressIndex200ResponseMeta}
     * @memberof CollectionIndex200Response
     */
    'meta': AddressIndex200ResponseMeta;
}
/**
 * 
 * @export
 * @interface CollectionResource
 */
export interface CollectionResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof CollectionResource
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     * @type {string}
     * @memberof CollectionResource
     */
    'internal_name': string;
    /**
     * The type of collection: \'collection\', \'exhibition\', or \'gallery\'
     * @type {string}
     * @memberof CollectionResource
     */
    'type': string;
    /**
     * The language this collection belongs to (LanguageResource id)
     * @type {string}
     * @memberof CollectionResource
     */
    'language_id': string;
    /**
     * The context this collection belongs to (ContextResource id)
     * @type {string}
     * @memberof CollectionResource
     */
    'context_id': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     * @type {string}
     * @memberof CollectionResource
     */
    'backward_compatibility': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof CollectionResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof CollectionResource
     */
    'updated_at': string | null;
    /**
     * The language relationship (LanguageResource)
     * @type {LanguageResource}
     * @memberof CollectionResource
     */
    'language'?: LanguageResource;
    /**
     * The context relationship (ContextResource)
     * @type {ContextResource}
     * @memberof CollectionResource
     */
    'context'?: ContextResource;
    /**
     * Translations for this collection (CollectionTranslationResource[])
     * @type {Array<CollectionTranslationResource>}
     * @memberof CollectionResource
     */
    'translations'?: Array<CollectionTranslationResource>;
    /**
     * Partners associated with this collection (PartnerResource[])
     * @type {Array<PartnerResource>}
     * @memberof CollectionResource
     */
    'partners'?: Array<PartnerResource>;
    /**
     * Items associated with this collection - primary relationship (ItemResource[])
     * @type {Array<ItemResource>}
     * @memberof CollectionResource
     */
    'items'?: Array<ItemResource>;
    /**
     * Items attached to this collection via many-to-many relationship (ItemResource[])
     * @type {Array<ItemResource>}
     * @memberof CollectionResource
     */
    'attachedItems'?: Array<ItemResource>;
    /**
     * The number of items in this collection (computed)
     * @type {string}
     * @memberof CollectionResource
     */
    'items_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectionResource
     */
    'attached_items_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectionResource
     */
    'partners_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectionResource
     */
    'translations_count'?: string;
}
/**
 * 
 * @export
 * @interface CollectionStore200Response
 */
export interface CollectionStore200Response {
    /**
     * 
     * @type {CollectionResource}
     * @memberof CollectionStore200Response
     */
    'data': CollectionResource;
}
/**
 * 
 * @export
 * @interface CollectionStoreRequest
 */
export interface CollectionStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof CollectionStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof CollectionStoreRequest
     */
    'type': CollectionStoreRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CollectionStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof CollectionStoreRequest
     */
    'context_id': string;
    /**
     * 
     * @type {string}
     * @memberof CollectionStoreRequest
     */
    'backward_compatibility'?: string | null;
}

export const CollectionStoreRequestTypeEnum = {
    Collection: 'collection',
    Exhibition: 'exhibition',
    Gallery: 'gallery'
} as const;

export type CollectionStoreRequestTypeEnum = typeof CollectionStoreRequestTypeEnum[keyof typeof CollectionStoreRequestTypeEnum];

/**
 * 
 * @export
 * @interface CollectionTranslationResource
 */
export interface CollectionTranslationResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof CollectionTranslationResource
     */
    'id': string;
    /**
     * The collection this translation belongs to (CollectionResource id)
     * @type {string}
     * @memberof CollectionTranslationResource
     */
    'collection_id': string;
    /**
     * The language of this translation (LanguageResource id)
     * @type {string}
     * @memberof CollectionTranslationResource
     */
    'language_id': string;
    /**
     * The context of this translation (ContextResource id)
     * @type {string}
     * @memberof CollectionTranslationResource
     */
    'context_id': string;
    /**
     * The title of the collection translation
     * @type {string}
     * @memberof CollectionTranslationResource
     */
    'title': string;
    /**
     * The description of the collection translation
     * @type {string}
     * @memberof CollectionTranslationResource
     */
    'description': string;
    /**
     * The URL for the collection translation
     * @type {string}
     * @memberof CollectionTranslationResource
     */
    'url': string | null;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     * @type {string}
     * @memberof CollectionTranslationResource
     */
    'backward_compatibility': string | null;
    /**
     * Extra data for translation (object, may be null)
     * @type {object}
     * @memberof CollectionTranslationResource
     */
    'extra': object | null;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof CollectionTranslationResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof CollectionTranslationResource
     */
    'updated_at': string | null;
    /**
     * The collection relationship (CollectionResource)
     * @type {CollectionResource}
     * @memberof CollectionTranslationResource
     */
    'collection'?: CollectionResource;
    /**
     * The language relationship (LanguageResource)
     * @type {LanguageResource}
     * @memberof CollectionTranslationResource
     */
    'language'?: LanguageResource;
    /**
     * The context relationship (ContextResource)
     * @type {ContextResource}
     * @memberof CollectionTranslationResource
     */
    'context'?: ContextResource;
}
/**
 * 
 * @export
 * @interface CollectionUpdateRequest
 */
export interface CollectionUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof CollectionUpdateRequest
     */
    'internal_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectionUpdateRequest
     */
    'type'?: CollectionUpdateRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CollectionUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectionUpdateRequest
     */
    'context_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectionUpdateRequest
     */
    'backward_compatibility'?: string | null;
}

export const CollectionUpdateRequestTypeEnum = {
    Collection: 'collection',
    Exhibition: 'exhibition',
    Gallery: 'gallery'
} as const;

export type CollectionUpdateRequestTypeEnum = typeof CollectionUpdateRequestTypeEnum[keyof typeof CollectionUpdateRequestTypeEnum];

/**
 * 
 * @export
 * @interface ContactIndex200Response
 */
export interface ContactIndex200Response {
    /**
     * 
     * @type {Array<ContactResource>}
     * @memberof ContactIndex200Response
     */
    'data': Array<ContactResource>;
    /**
     * 
     * @type {AddressIndex200ResponseLinks}
     * @memberof ContactIndex200Response
     */
    'links': AddressIndex200ResponseLinks;
    /**
     * 
     * @type {AddressIndex200ResponseMeta}
     * @memberof ContactIndex200Response
     */
    'meta': AddressIndex200ResponseMeta;
}
/**
 * 
 * @export
 * @interface ContactResource
 */
export interface ContactResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof ContactResource
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     * @type {string}
     * @memberof ContactResource
     */
    'internal_name': string;
    /**
     * The phone number of the contact
     * @type {string}
     * @memberof ContactResource
     */
    'phone_number': string | null;
    /**
     * The formatted phone number of the contact
     * @type {string}
     * @memberof ContactResource
     */
    'formatted_phone_number': string | null;
    /**
     * The fax number of the contact
     * @type {string}
     * @memberof ContactResource
     */
    'fax_number': string | null;
    /**
     * The formatted fax number of the contact
     * @type {string}
     * @memberof ContactResource
     */
    'formatted_fax_number': string | null;
    /**
     * The email address of the contact
     * @type {string}
     * @memberof ContactResource
     */
    'email': string | null;
    /**
     * Translations for this contact (ContactTranslationResource[])
     * @type {Array<ContactTranslationResource>}
     * @memberof ContactResource
     */
    'translations'?: Array<ContactTranslationResource>;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof ContactResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof ContactResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ContactStore201Response
 */
export interface ContactStore201Response {
    /**
     * 
     * @type {ContactResource}
     * @memberof ContactStore201Response
     */
    'data': ContactResource;
}
/**
 * 
 * @export
 * @interface ContactStoreRequest
 */
export interface ContactStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ContactStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ContactStoreRequest
     */
    'phone_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactStoreRequest
     */
    'fax_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactStoreRequest
     */
    'email'?: string | null;
    /**
     * 
     * @type {Array<ContactStoreRequestTranslationsInner>}
     * @memberof ContactStoreRequest
     */
    'translations': Array<ContactStoreRequestTranslationsInner>;
}
/**
 * 
 * @export
 * @interface ContactStoreRequestTranslationsInner
 */
export interface ContactStoreRequestTranslationsInner {
    /**
     * 
     * @type {number}
     * @memberof ContactStoreRequestTranslationsInner
     */
    'language_id': number;
    /**
     * 
     * @type {string}
     * @memberof ContactStoreRequestTranslationsInner
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface ContactTranslationIndex200Response
 */
export interface ContactTranslationIndex200Response {
    /**
     * 
     * @type {Array<ContactTranslationResource>}
     * @memberof ContactTranslationIndex200Response
     */
    'data': Array<ContactTranslationResource>;
}
/**
 * 
 * @export
 * @interface ContactTranslationResource
 */
export interface ContactTranslationResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof ContactTranslationResource
     */
    'id': string;
    /**
     * The contact this translation belongs to (ContactResource id)
     * @type {string}
     * @memberof ContactTranslationResource
     */
    'contact_id': string;
    /**
     * The language of this translation (LanguageResource id)
     * @type {string}
     * @memberof ContactTranslationResource
     */
    'language_id': string;
    /**
     * The label for the contact translation
     * @type {string}
     * @memberof ContactTranslationResource
     */
    'label': string;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof ContactTranslationResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof ContactTranslationResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ContactTranslationStore200Response
 */
export interface ContactTranslationStore200Response {
    /**
     * 
     * @type {ContactTranslationResource}
     * @memberof ContactTranslationStore200Response
     */
    'data': ContactTranslationResource;
}
/**
 * 
 * @export
 * @interface ContactTranslationStoreRequest
 */
export interface ContactTranslationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationStoreRequest
     */
    'contact_id': string;
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationStoreRequest
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface ContactTranslationUpdateRequest
 */
export interface ContactTranslationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationUpdateRequest
     */
    'contact_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactTranslationUpdateRequest
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface ContactUpdateRequest
 */
export interface ContactUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateRequest
     */
    'phone_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateRequest
     */
    'fax_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateRequest
     */
    'email'?: string | null;
    /**
     * 
     * @type {Array<ContactUpdateRequestTranslationsInner>}
     * @memberof ContactUpdateRequest
     */
    'translations'?: Array<ContactUpdateRequestTranslationsInner>;
}
/**
 * 
 * @export
 * @interface ContactUpdateRequestTranslationsInner
 */
export interface ContactUpdateRequestTranslationsInner {
    /**
     * 
     * @type {number}
     * @memberof ContactUpdateRequestTranslationsInner
     */
    'language_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateRequestTranslationsInner
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface ContextClearDefault200Response
 */
export interface ContextClearDefault200Response {
    /**
     * 
     * @type {string}
     * @memberof ContextClearDefault200Response
     */
    'message': ContextClearDefault200ResponseMessageEnum;
}

export const ContextClearDefault200ResponseMessageEnum = {
    DefaultContextCleared: 'Default context cleared'
} as const;

export type ContextClearDefault200ResponseMessageEnum = typeof ContextClearDefault200ResponseMessageEnum[keyof typeof ContextClearDefault200ResponseMessageEnum];

/**
 * 
 * @export
 * @interface ContextGetDefault404Response
 */
export interface ContextGetDefault404Response {
    /**
     * 
     * @type {string}
     * @memberof ContextGetDefault404Response
     */
    'message': ContextGetDefault404ResponseMessageEnum;
}

export const ContextGetDefault404ResponseMessageEnum = {
    NoDefaultContextFound: 'No default context found'
} as const;

export type ContextGetDefault404ResponseMessageEnum = typeof ContextGetDefault404ResponseMessageEnum[keyof typeof ContextGetDefault404ResponseMessageEnum];

/**
 * 
 * @export
 * @interface ContextIndex200Response
 */
export interface ContextIndex200Response {
    /**
     * 
     * @type {Array<ContextResource>}
     * @memberof ContextIndex200Response
     */
    'data': Array<ContextResource>;
    /**
     * 
     * @type {AddressIndex200ResponseLinks}
     * @memberof ContextIndex200Response
     */
    'links': AddressIndex200ResponseLinks;
    /**
     * 
     * @type {AddressIndex200ResponseMeta}
     * @memberof ContextIndex200Response
     */
    'meta': AddressIndex200ResponseMeta;
}
/**
 * 
 * @export
 * @interface ContextResource
 */
export interface ContextResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof ContextResource
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     * @type {string}
     * @memberof ContextResource
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     * @type {string}
     * @memberof ContextResource
     */
    'backward_compatibility': string | null;
    /**
     * Indicates if this context is the default one. There is one single default context for the entire database.
     * @type {boolean}
     * @memberof ContextResource
     */
    'is_default': boolean;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof ContextResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof ContextResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ContextSetDefault200Response
 */
export interface ContextSetDefault200Response {
    /**
     * 
     * @type {ContextResource}
     * @memberof ContextSetDefault200Response
     */
    'data': ContextResource;
}
/**
 * 
 * @export
 * @interface ContextSetDefaultRequest
 */
export interface ContextSetDefaultRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ContextSetDefaultRequest
     */
    'is_default': boolean;
}
/**
 * 
 * @export
 * @interface ContextStoreRequest
 */
export interface ContextStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ContextStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ContextStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ContextStoreRequest
     */
    'is_default'?: boolean;
}
/**
 * 
 * @export
 * @interface CountryIndex200Response
 */
export interface CountryIndex200Response {
    /**
     * 
     * @type {Array<CountryResource>}
     * @memberof CountryIndex200Response
     */
    'data': Array<CountryResource>;
    /**
     * 
     * @type {AddressIndex200ResponseLinks}
     * @memberof CountryIndex200Response
     */
    'links': AddressIndex200ResponseLinks;
    /**
     * 
     * @type {AddressIndex200ResponseMeta}
     * @memberof CountryIndex200Response
     */
    'meta': AddressIndex200ResponseMeta;
}
/**
 * 
 * @export
 * @interface CountryResource
 */
export interface CountryResource {
    /**
     * The unique identifier (ISO 3166-1 alpha-3 code)
     * @type {string}
     * @memberof CountryResource
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     * @type {string}
     * @memberof CountryResource
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     * @type {string}
     * @memberof CountryResource
     */
    'backward_compatibility': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof CountryResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof CountryResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface CountryStore200Response
 */
export interface CountryStore200Response {
    /**
     * 
     * @type {CountryResource}
     * @memberof CountryStore200Response
     */
    'data': CountryResource;
}
/**
 * 
 * @export
 * @interface CountryStoreRequest
 */
export interface CountryStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof CountryStoreRequest
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CountryStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof CountryStoreRequest
     */
    'backward_compatibility'?: string | null;
}
/**
 * 
 * @export
 * @interface CountryUpdateRequest
 */
export interface CountryUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof CountryUpdateRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof CountryUpdateRequest
     */
    'backward_compatibility'?: string | null;
}
/**
 * 
 * @export
 * @interface ImageUploadIndex200Response
 */
export interface ImageUploadIndex200Response {
    /**
     * 
     * @type {Array<ImageUploadResource>}
     * @memberof ImageUploadIndex200Response
     */
    'data': Array<ImageUploadResource>;
}
/**
 * 
 * @export
 * @interface ImageUploadResource
 */
export interface ImageUploadResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof ImageUploadResource
     */
    'id': string;
    /**
     * The path to the picture file
     * @type {string}
     * @memberof ImageUploadResource
     */
    'path': string | null;
    /**
     * The original name of the uploaded file
     * @type {string}
     * @memberof ImageUploadResource
     */
    'name': string | null;
    /**
     * The file extension of the uploaded file
     * @type {string}
     * @memberof ImageUploadResource
     */
    'extension': string | null;
    /**
     * The MIME type of the uploaded file
     * @type {string}
     * @memberof ImageUploadResource
     */
    'mime_type': string | null;
    /**
     * The size of the uploaded file in bytes
     * @type {number}
     * @memberof ImageUploadResource
     */
    'size': number | null;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof ImageUploadResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof ImageUploadResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ImageUploadStatus200Response
 */
export interface ImageUploadStatus200Response {
    /**
     * 
     * @type {string}
     * @memberof ImageUploadStatus200Response
     */
    'status': ImageUploadStatus200ResponseStatusEnum;
    /**
     * 
     * @type {any}
     * @memberof ImageUploadStatus200Response
     */
    'available_image': any | null;
}

export const ImageUploadStatus200ResponseStatusEnum = {
    Processing: 'processing'
} as const;

export type ImageUploadStatus200ResponseStatusEnum = typeof ImageUploadStatus200ResponseStatusEnum[keyof typeof ImageUploadStatus200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface ImageUploadStatus200ResponseAnyOf
 */
export interface ImageUploadStatus200ResponseAnyOf {
    /**
     * 
     * @type {string}
     * @memberof ImageUploadStatus200ResponseAnyOf
     */
    'status': ImageUploadStatus200ResponseAnyOfStatusEnum;
    /**
     * 
     * @type {AvailableImageResource}
     * @memberof ImageUploadStatus200ResponseAnyOf
     */
    'available_image': AvailableImageResource;
}

export const ImageUploadStatus200ResponseAnyOfStatusEnum = {
    Processed: 'processed'
} as const;

export type ImageUploadStatus200ResponseAnyOfStatusEnum = typeof ImageUploadStatus200ResponseAnyOfStatusEnum[keyof typeof ImageUploadStatus200ResponseAnyOfStatusEnum];

/**
 * 
 * @export
 * @interface ImageUploadStatus200ResponseAnyOf1
 */
export interface ImageUploadStatus200ResponseAnyOf1 {
    /**
     * 
     * @type {string}
     * @memberof ImageUploadStatus200ResponseAnyOf1
     */
    'status': ImageUploadStatus200ResponseAnyOf1StatusEnum;
    /**
     * 
     * @type {any}
     * @memberof ImageUploadStatus200ResponseAnyOf1
     */
    'available_image': any | null;
}

export const ImageUploadStatus200ResponseAnyOf1StatusEnum = {
    Processing: 'processing'
} as const;

export type ImageUploadStatus200ResponseAnyOf1StatusEnum = typeof ImageUploadStatus200ResponseAnyOf1StatusEnum[keyof typeof ImageUploadStatus200ResponseAnyOf1StatusEnum];

/**
 * 
 * @export
 * @interface ImageUploadStatus404Response
 */
export interface ImageUploadStatus404Response {
    /**
     * 
     * @type {string}
     * @memberof ImageUploadStatus404Response
     */
    'status': ImageUploadStatus404ResponseStatusEnum;
    /**
     * 
     * @type {any}
     * @memberof ImageUploadStatus404Response
     */
    'available_image': any | null;
}

export const ImageUploadStatus404ResponseStatusEnum = {
    NotFound: 'not_found'
} as const;

export type ImageUploadStatus404ResponseStatusEnum = typeof ImageUploadStatus404ResponseStatusEnum[keyof typeof ImageUploadStatus404ResponseStatusEnum];

/**
 * 
 * @export
 * @interface ImageUploadStore200Response
 */
export interface ImageUploadStore200Response {
    /**
     * 
     * @type {ImageUploadResource}
     * @memberof ImageUploadStore200Response
     */
    'data': ImageUploadResource;
}
/**
 * 
 * @export
 * @interface InfoVersion200Response
 */
export interface InfoVersion200Response {
    /**
     * 
     * @type {any}
     * @memberof InfoVersion200Response
     */
    'repository': any | null;
    /**
     * 
     * @type {InfoVersion200ResponseAnyOfBuildTimestamp}
     * @memberof InfoVersion200Response
     */
    'build_timestamp': InfoVersion200ResponseAnyOfBuildTimestamp;
    /**
     * 
     * @type {any}
     * @memberof InfoVersion200Response
     */
    'repository_url': any | null;
    /**
     * 
     * @type {any}
     * @memberof InfoVersion200Response
     */
    'api_client_version': any | null;
    /**
     * 
     * @type {string}
     * @memberof InfoVersion200Response
     */
    'app_version': InfoVersion200ResponseAppVersionEnum;
    /**
     * 
     * @type {any}
     * @memberof InfoVersion200Response
     */
    'commit_sha': any | null;
}

export const InfoVersion200ResponseAppVersionEnum = {
    _100Dev: '1.0.0-dev'
} as const;

export type InfoVersion200ResponseAppVersionEnum = typeof InfoVersion200ResponseAppVersionEnum[keyof typeof InfoVersion200ResponseAppVersionEnum];

/**
 * 
 * @export
 * @interface InfoVersion200ResponseAnyOf
 */
export interface InfoVersion200ResponseAnyOf {
    /**
     * 
     * @type {any}
     * @memberof InfoVersion200ResponseAnyOf
     */
    'repository': any | null;
    /**
     * 
     * @type {InfoVersion200ResponseAnyOfBuildTimestamp}
     * @memberof InfoVersion200ResponseAnyOf
     */
    'build_timestamp': InfoVersion200ResponseAnyOfBuildTimestamp;
    /**
     * 
     * @type {any}
     * @memberof InfoVersion200ResponseAnyOf
     */
    'repository_url': any | null;
    /**
     * 
     * @type {any}
     * @memberof InfoVersion200ResponseAnyOf
     */
    'api_client_version': any | null;
    /**
     * 
     * @type {string}
     * @memberof InfoVersion200ResponseAnyOf
     */
    'app_version': InfoVersion200ResponseAnyOfAppVersionEnum;
    /**
     * 
     * @type {any}
     * @memberof InfoVersion200ResponseAnyOf
     */
    'commit_sha': any | null;
}

export const InfoVersion200ResponseAnyOfAppVersionEnum = {
    _100Dev: '1.0.0-dev'
} as const;

export type InfoVersion200ResponseAnyOfAppVersionEnum = typeof InfoVersion200ResponseAnyOfAppVersionEnum[keyof typeof InfoVersion200ResponseAnyOfAppVersionEnum];

/**
 * 
 * @export
 * @interface InfoVersion200ResponseAnyOfBuildTimestamp
 */
export interface InfoVersion200ResponseAnyOfBuildTimestamp {
    /**
     * 
     * @type {string}
     * @memberof InfoVersion200ResponseAnyOfBuildTimestamp
     */
    'value': string;
    /**
     * 
     * @type {number}
     * @memberof InfoVersion200ResponseAnyOfBuildTimestamp
     */
    'DisplayHint': InfoVersion200ResponseAnyOfBuildTimestampDisplayHintEnum;
    /**
     * 
     * @type {string}
     * @memberof InfoVersion200ResponseAnyOfBuildTimestamp
     */
    'DateTime': string;
}

export const InfoVersion200ResponseAnyOfBuildTimestampDisplayHintEnum = {
    NUMBER_2: 2
} as const;

export type InfoVersion200ResponseAnyOfBuildTimestampDisplayHintEnum = typeof InfoVersion200ResponseAnyOfBuildTimestampDisplayHintEnum[keyof typeof InfoVersion200ResponseAnyOfBuildTimestampDisplayHintEnum];

/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * Error overview.
     * @type {string}
     * @memberof InlineObject
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * Errors overview.
     * @type {string}
     * @memberof InlineObject1
     */
    'message': string;
    /**
     * A detailed description of each field that failed validation.
     * @type {{ [key: string]: Array<string>; }}
     * @memberof InlineObject1
     */
    'errors': { [key: string]: Array<string>; };
}
/**
 * 
 * @export
 * @interface ItemAttachImageRequest
 */
export interface ItemAttachImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemAttachImageRequest
     */
    'available_image_id': string;
}
/**
 * 
 * @export
 * @interface ItemForTag200Response
 */
export interface ItemForTag200Response {
    /**
     * 
     * @type {Array<ItemResource>}
     * @memberof ItemForTag200Response
     */
    'data': Array<ItemResource>;
}
/**
 * 
 * @export
 * @interface ItemImageDetach200Response
 */
export interface ItemImageDetach200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ItemImageDetach200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ItemImageDetach200Response
     */
    'message': ItemImageDetach200ResponseMessageEnum;
    /**
     * 
     * @type {string}
     * @memberof ItemImageDetach200Response
     */
    'available_image_id': string;
}

export const ItemImageDetach200ResponseMessageEnum = {
    ImageDetachedSuccessfully: 'Image detached successfully'
} as const;

export type ItemImageDetach200ResponseMessageEnum = typeof ItemImageDetach200ResponseMessageEnum[keyof typeof ItemImageDetach200ResponseMessageEnum];

/**
 * 
 * @export
 * @interface ItemImageResource
 */
export interface ItemImageResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof ItemImageResource
     */
    'id': string;
    /**
     * The item this image belongs to
     * @type {string}
     * @memberof ItemImageResource
     */
    'item_id': string;
    /**
     * The path to the image file
     * @type {string}
     * @memberof ItemImageResource
     */
    'path': string;
    /**
     * The original filename when uploaded
     * @type {string}
     * @memberof ItemImageResource
     */
    'original_name': string;
    /**
     * The MIME type of the image
     * @type {string}
     * @memberof ItemImageResource
     */
    'mime_type': string;
    /**
     * The file size in bytes
     * @type {number}
     * @memberof ItemImageResource
     */
    'size': number;
    /**
     * Alternative text for accessibility
     * @type {string}
     * @memberof ItemImageResource
     */
    'alt_text': string | null;
    /**
     * Display order for sorting images
     * @type {number}
     * @memberof ItemImageResource
     */
    'display_order': number;
    /**
     * The item this image belongs to (ItemResource)
     * @type {ItemResource}
     * @memberof ItemImageResource
     */
    'item'?: ItemResource;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof ItemImageResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof ItemImageResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ItemImageTightenOrdering200Response
 */
export interface ItemImageTightenOrdering200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ItemImageTightenOrdering200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ItemImageTightenOrdering200Response
     */
    'message': ItemImageTightenOrdering200ResponseMessageEnum;
}

export const ItemImageTightenOrdering200ResponseMessageEnum = {
    ImageOrderingTightenedSuccessfully: 'Image ordering tightened successfully'
} as const;

export type ItemImageTightenOrdering200ResponseMessageEnum = typeof ItemImageTightenOrdering200ResponseMessageEnum[keyof typeof ItemImageTightenOrdering200ResponseMessageEnum];

/**
 * 
 * @export
 * @interface ItemImagesIndex200Response
 */
export interface ItemImagesIndex200Response {
    /**
     * 
     * @type {Array<ItemImageResource>}
     * @memberof ItemImagesIndex200Response
     */
    'data': Array<ItemImageResource>;
}
/**
 * 
 * @export
 * @interface ItemImagesStore200Response
 */
export interface ItemImagesStore200Response {
    /**
     * 
     * @type {ItemImageResource}
     * @memberof ItemImagesStore200Response
     */
    'data': ItemImageResource;
}
/**
 * 
 * @export
 * @interface ItemIndex200Response
 */
export interface ItemIndex200Response {
    /**
     * 
     * @type {Array<ItemResource>}
     * @memberof ItemIndex200Response
     */
    'data': Array<ItemResource>;
    /**
     * 
     * @type {AddressIndex200ResponseLinks}
     * @memberof ItemIndex200Response
     */
    'links': AddressIndex200ResponseLinks;
    /**
     * 
     * @type {AddressIndex200ResponseMeta}
     * @memberof ItemIndex200Response
     */
    'meta': AddressIndex200ResponseMeta;
}
/**
 * 
 * @export
 * @interface ItemResource
 */
export interface ItemResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof ItemResource
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     * @type {string}
     * @memberof ItemResource
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     * @type {string}
     * @memberof ItemResource
     */
    'backward_compatibility': string | null;
    /**
     * The type of the item: \'object\', \'monument\', \'detail\', or \'picture\'.
     * @type {string}
     * @memberof ItemResource
     */
    'type': string;
    /**
     * The parent item ID (for hierarchical relationships), nullable
     * @type {string}
     * @memberof ItemResource
     */
    'parent_id': string | null;
    /**
     * Owner\'s reference number for the item (external reference from owner)
     * @type {string}
     * @memberof ItemResource
     */
    'owner_reference': string | null;
    /**
     * MWNF reference number for the item (reference from MWNF system)
     * @type {string}
     * @memberof ItemResource
     */
    'mwnf_reference': string | null;
    /**
     * The parent item (for hierarchical relationships), nullable (ItemResource)
     * @type {ItemResource}
     * @memberof ItemResource
     */
    'parent'?: ItemResource;
    /**
     * The child items (for hierarchical relationships) (ItemResource[])
     * @type {Array<ItemResource>}
     * @memberof ItemResource
     */
    'children'?: Array<ItemResource>;
    /**
     * The partner owning the item (PartnerResource)
     * @type {PartnerResource}
     * @memberof ItemResource
     */
    'partner'?: PartnerResource;
    /**
     * The project this item belongs to, nullable (ProjectResource)
     * @type {ProjectResource}
     * @memberof ItemResource
     */
    'project'?: ProjectResource;
    /**
     * The country this item is associated with, nullable (CountryResource)
     * @type {CountryResource}
     * @memberof ItemResource
     */
    'country'?: CountryResource;
    /**
     * The collection that contains this item (CollectionResource)
     * @type {CollectionResource}
     * @memberof ItemResource
     */
    'collection'?: CollectionResource;
    /**
     * Artists associated with this item (ArtistResource[])
     * @type {Array<ArtistResource>}
     * @memberof ItemResource
     */
    'artists'?: Array<ArtistResource>;
    /**
     * Workshops associated with this item (WorkshopResource[])
     * @type {Array<WorkshopResource>}
     * @memberof ItemResource
     */
    'workshops'?: Array<WorkshopResource>;
    /**
     * Tags associated with this item (TagResource[])
     * @type {Array<TagResource>}
     * @memberof ItemResource
     */
    'tags'?: Array<TagResource>;
    /**
     * Translations for this item (internationalization and contextualization) (ItemTranslationResource[])
     * @type {Array<ItemTranslationResource>}
     * @memberof ItemResource
     */
    'translations'?: Array<ItemTranslationResource>;
    /**
     * Item images attached to this item with display ordering (ItemImageResource[])
     * @type {Array<ItemImageResource>}
     * @memberof ItemResource
     */
    'itemImages'?: Array<ItemImageResource>;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof ItemResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof ItemResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ItemStore200Response
 */
export interface ItemStore200Response {
    /**
     * 
     * @type {ItemResource}
     * @memberof ItemStore200Response
     */
    'data': ItemResource;
}
/**
 * 
 * @export
 * @interface ItemTranslationResource
 */
export interface ItemTranslationResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'id': string;
    /**
     * The item this translation belongs to (ItemResource id)
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'item_id': string;
    /**
     * The language of this translation (LanguageResource id)
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'language_id': string;
    /**
     * The context of this translation (ContextResource id)
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'context_id': string;
    /**
     * The name of the item translation
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'name': string;
    /**
     * The alternate name of the item translation
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'alternate_name': string | null;
    /**
     * The description of the item translation
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'description': string;
    /**
     * The type of the item translation
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'type': string | null;
    /**
     * The holder of the item
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'holder': string | null;
    /**
     * The owner of the item
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'owner': string | null;
    /**
     * The initial owner of the item
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'initial_owner': string | null;
    /**
     * The dates associated with the item
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'dates': string | null;
    /**
     * The location associated with the item
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'location': string | null;
    /**
     * The dimensions of the item
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'dimensions': string | null;
    /**
     * The place of production of the item
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'place_of_production': string | null;
    /**
     * The method for datation of the item
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'method_for_datation': string | null;
    /**
     * The method for provenance of the item
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'method_for_provenance': string | null;
    /**
     * The obtention of the item
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'obtention': string | null;
    /**
     * The bibliography for the item
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'bibliography': string | null;
    /**
     * The author of the item (AuthorResource id)
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'author_id': string | null;
    /**
     * The copy-editor of the item (AuthorResource id)
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'text_copy_editor_id': string | null;
    /**
     * The translator of the item translation (AuthorResource id)
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'translator_id': string | null;
    /**
     * The copy-editor of the item translation (AuthorResource id)
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'translation_copy_editor_id': string | null;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'backward_compatibility': string | null;
    /**
     * Extra data for translation (object, may be null)
     * @type {object}
     * @memberof ItemTranslationResource
     */
    'extra': object | null;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof ItemTranslationResource
     */
    'updated_at': string | null;
    /**
     * The item relationship (ItemResource)
     * @type {ItemResource}
     * @memberof ItemTranslationResource
     */
    'item'?: ItemResource;
    /**
     * The language relationship (LanguageResource)
     * @type {LanguageResource}
     * @memberof ItemTranslationResource
     */
    'language'?: LanguageResource;
    /**
     * The context relationship (ContextResource)
     * @type {ContextResource}
     * @memberof ItemTranslationResource
     */
    'context'?: ContextResource;
    /**
     * The author relationship (AuthorResource)
     * @type {AuthorResource}
     * @memberof ItemTranslationResource
     */
    'author'?: AuthorResource;
    /**
     * The copy-editor relationship (AuthorResource)
     * @type {AuthorResource}
     * @memberof ItemTranslationResource
     */
    'text_copy_editor'?: AuthorResource;
    /**
     * The translator relationship (AuthorResource)
     * @type {AuthorResource}
     * @memberof ItemTranslationResource
     */
    'translator'?: AuthorResource;
    /**
     * The translation copy-editor relationship (AuthorResource)
     * @type {AuthorResource}
     * @memberof ItemTranslationResource
     */
    'translation_copy_editor'?: AuthorResource;
}
/**
 * 
 * @export
 * @interface ItemTranslationShow200Response
 */
export interface ItemTranslationShow200Response {
    /**
     * 
     * @type {ItemTranslationResource}
     * @memberof ItemTranslationShow200Response
     */
    'data': ItemTranslationResource;
}
/**
 * 
 * @export
 * @interface ItemTranslationStoreRequest
 */
export interface ItemTranslationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'item_id': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'context_id': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'alternate_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'holder'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'owner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'initial_owner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'dates'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'location'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'dimensions'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'place_of_production'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'method_for_datation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'method_for_provenance'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'obtention'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'bibliography'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'author_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'text_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'translator_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'translation_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationStoreRequest
     */
    'extra'?: string | null;
}
/**
 * 
 * @export
 * @interface ItemTranslationUpdateRequest
 */
export interface ItemTranslationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'item_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'context_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'alternate_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'holder'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'owner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'initial_owner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'dates'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'location'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'dimensions'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'place_of_production'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'method_for_datation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'method_for_provenance'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'obtention'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'bibliography'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'author_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'text_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'translator_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'translation_copy_editor_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemTranslationUpdateRequest
     */
    'extra'?: string | null;
}
/**
 * 
 * @export
 * @interface ItemUpdateTagsRequest
 */
export interface ItemUpdateTagsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemUpdateTagsRequest
     */
    'attach'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemUpdateTagsRequest
     */
    'detach'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ItemWithAllTagsRequest
 */
export interface ItemWithAllTagsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemWithAllTagsRequest
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface LanguageClearDefault200Response
 */
export interface LanguageClearDefault200Response {
    /**
     * 
     * @type {string}
     * @memberof LanguageClearDefault200Response
     */
    'message': LanguageClearDefault200ResponseMessageEnum;
}

export const LanguageClearDefault200ResponseMessageEnum = {
    DefaultLanguageCleared: 'Default language cleared'
} as const;

export type LanguageClearDefault200ResponseMessageEnum = typeof LanguageClearDefault200ResponseMessageEnum[keyof typeof LanguageClearDefault200ResponseMessageEnum];

/**
 * 
 * @export
 * @interface LanguageGetDefault404Response
 */
export interface LanguageGetDefault404Response {
    /**
     * 
     * @type {string}
     * @memberof LanguageGetDefault404Response
     */
    'message': LanguageGetDefault404ResponseMessageEnum;
}

export const LanguageGetDefault404ResponseMessageEnum = {
    NoDefaultLanguageFound: 'No default language found'
} as const;

export type LanguageGetDefault404ResponseMessageEnum = typeof LanguageGetDefault404ResponseMessageEnum[keyof typeof LanguageGetDefault404ResponseMessageEnum];

/**
 * 
 * @export
 * @interface LanguageGetEnglish404Response
 */
export interface LanguageGetEnglish404Response {
    /**
     * 
     * @type {string}
     * @memberof LanguageGetEnglish404Response
     */
    'message': LanguageGetEnglish404ResponseMessageEnum;
}

export const LanguageGetEnglish404ResponseMessageEnum = {
    NoEnglishLanguageFound: 'No English language found'
} as const;

export type LanguageGetEnglish404ResponseMessageEnum = typeof LanguageGetEnglish404ResponseMessageEnum[keyof typeof LanguageGetEnglish404ResponseMessageEnum];

/**
 * 
 * @export
 * @interface LanguageIndex200Response
 */
export interface LanguageIndex200Response {
    /**
     * 
     * @type {Array<LanguageResource>}
     * @memberof LanguageIndex200Response
     */
    'data': Array<LanguageResource>;
    /**
     * 
     * @type {AddressIndex200ResponseLinks}
     * @memberof LanguageIndex200Response
     */
    'links': AddressIndex200ResponseLinks;
    /**
     * 
     * @type {AddressIndex200ResponseMeta}
     * @memberof LanguageIndex200Response
     */
    'meta': AddressIndex200ResponseMeta;
}
/**
 * 
 * @export
 * @interface LanguageResource
 */
export interface LanguageResource {
    /**
     * The unique identifier (ISO 639-1 code)
     * @type {string}
     * @memberof LanguageResource
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     * @type {string}
     * @memberof LanguageResource
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     * @type {string}
     * @memberof LanguageResource
     */
    'backward_compatibility': string | null;
    /**
     * Indicates if this language is the default one. There is one single default language for the entire database.
     * @type {boolean}
     * @memberof LanguageResource
     */
    'is_default': boolean;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof LanguageResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof LanguageResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface LanguageSetDefault200Response
 */
export interface LanguageSetDefault200Response {
    /**
     * 
     * @type {LanguageResource}
     * @memberof LanguageSetDefault200Response
     */
    'data': LanguageResource;
}
/**
 * 
 * @export
 * @interface LanguageStoreRequest
 */
export interface LanguageStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof LanguageStoreRequest
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LanguageStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof LanguageStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof LanguageStoreRequest
     */
    'is_default'?: boolean;
}
/**
 * 
 * @export
 * @interface LanguageUpdateRequest
 */
export interface LanguageUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof LanguageUpdateRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof LanguageUpdateRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof LanguageUpdateRequest
     */
    'is_default'?: boolean;
}
/**
 * 
 * @export
 * @interface LocationIndex200Response
 */
export interface LocationIndex200Response {
    /**
     * 
     * @type {Array<LocationResource>}
     * @memberof LocationIndex200Response
     */
    'data': Array<LocationResource>;
    /**
     * 
     * @type {AddressIndex200ResponseLinks}
     * @memberof LocationIndex200Response
     */
    'links': AddressIndex200ResponseLinks;
    /**
     * 
     * @type {AddressIndex200ResponseMeta}
     * @memberof LocationIndex200Response
     */
    'meta': AddressIndex200ResponseMeta;
}
/**
 * 
 * @export
 * @interface LocationResource
 */
export interface LocationResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof LocationResource
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     * @type {string}
     * @memberof LocationResource
     */
    'internal_name': string;
    /**
     * The country this location belongs to (CountryResource id)
     * @type {string}
     * @memberof LocationResource
     */
    'country_id': string;
    /**
     * Translations for this location (LocationTranslationResource[])
     * @type {Array<LocationTranslationResource>}
     * @memberof LocationResource
     */
    'translations'?: Array<LocationTranslationResource>;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof LocationResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof LocationResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface LocationStore201Response
 */
export interface LocationStore201Response {
    /**
     * 
     * @type {LocationResource}
     * @memberof LocationStore201Response
     */
    'data': LocationResource;
}
/**
 * 
 * @export
 * @interface LocationStoreRequest
 */
export interface LocationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof LocationStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {number}
     * @memberof LocationStoreRequest
     */
    'country_id': number;
    /**
     * 
     * @type {Array<LocationStoreRequestTranslationsInner>}
     * @memberof LocationStoreRequest
     */
    'translations': Array<LocationStoreRequestTranslationsInner>;
}
/**
 * 
 * @export
 * @interface LocationStoreRequestTranslationsInner
 */
export interface LocationStoreRequestTranslationsInner {
    /**
     * 
     * @type {number}
     * @memberof LocationStoreRequestTranslationsInner
     */
    'language_id': number;
    /**
     * 
     * @type {string}
     * @memberof LocationStoreRequestTranslationsInner
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface LocationTranslationIndex200Response
 */
export interface LocationTranslationIndex200Response {
    /**
     * 
     * @type {Array<LocationTranslationResource>}
     * @memberof LocationTranslationIndex200Response
     */
    'data': Array<LocationTranslationResource>;
}
/**
 * 
 * @export
 * @interface LocationTranslationResource
 */
export interface LocationTranslationResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof LocationTranslationResource
     */
    'id': string;
    /**
     * The location this translation belongs to (LocationResource id)
     * @type {string}
     * @memberof LocationTranslationResource
     */
    'location_id': string;
    /**
     * The language of this translation (LanguageResource id)
     * @type {string}
     * @memberof LocationTranslationResource
     */
    'language_id': string;
    /**
     * The name of the location translation
     * @type {string}
     * @memberof LocationTranslationResource
     */
    'name': string;
    /**
     * The description of the location translation
     * @type {string}
     * @memberof LocationTranslationResource
     */
    'description': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof LocationTranslationResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof LocationTranslationResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface LocationTranslationStore200Response
 */
export interface LocationTranslationStore200Response {
    /**
     * 
     * @type {LocationTranslationResource}
     * @memberof LocationTranslationStore200Response
     */
    'data': LocationTranslationResource;
}
/**
 * 
 * @export
 * @interface LocationTranslationStoreRequest
 */
export interface LocationTranslationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationStoreRequest
     */
    'location_id': string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationStoreRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationStoreRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface LocationTranslationUpdateRequest
 */
export interface LocationTranslationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationUpdateRequest
     */
    'location_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationTranslationUpdateRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface LocationUpdateRequest
 */
export interface LocationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof LocationUpdateRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {number}
     * @memberof LocationUpdateRequest
     */
    'country_id': number;
    /**
     * 
     * @type {Array<LocationUpdateRequestTranslationsInner>}
     * @memberof LocationUpdateRequest
     */
    'translations'?: Array<LocationUpdateRequestTranslationsInner>;
}
/**
 * 
 * @export
 * @interface LocationUpdateRequestTranslationsInner
 */
export interface LocationUpdateRequestTranslationsInner {
    /**
     * 
     * @type {number}
     * @memberof LocationUpdateRequestTranslationsInner
     */
    'language_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof LocationUpdateRequestTranslationsInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface MarkdownFromHtmlRequest
 */
export interface MarkdownFromHtmlRequest {
    /**
     * 
     * @type {string}
     * @memberof MarkdownFromHtmlRequest
     */
    'html': string;
}
/**
 * 
 * @export
 * @interface MarkdownIsMarkdownRequest
 */
export interface MarkdownIsMarkdownRequest {
    /**
     * 
     * @type {string}
     * @memberof MarkdownIsMarkdownRequest
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface MarkdownPreview200Response
 */
export interface MarkdownPreview200Response {
    /**
     * 
     * @type {boolean}
     * @memberof MarkdownPreview200Response
     */
    'success': boolean;
    /**
     * 
     * @type {MarkdownPreview200ResponseData}
     * @memberof MarkdownPreview200Response
     */
    'data': MarkdownPreview200ResponseData;
}
/**
 * 
 * @export
 * @interface MarkdownPreview200ResponseData
 */
export interface MarkdownPreview200ResponseData {
    /**
     * 
     * @type {string}
     * @memberof MarkdownPreview200ResponseData
     */
    'html': string;
}
/**
 * 
 * @export
 * @interface MarkdownPreview422Response
 */
export interface MarkdownPreview422Response {
    /**
     * 
     * @type {boolean}
     * @memberof MarkdownPreview422Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof MarkdownPreview422Response
     */
    'message': MarkdownPreview422ResponseMessageEnum;
    /**
     * 
     * @type {string}
     * @memberof MarkdownPreview422Response
     */
    'errors': string;
}

export const MarkdownPreview422ResponseMessageEnum = {
    ValidationFailed: 'Validation failed'
} as const;

export type MarkdownPreview422ResponseMessageEnum = typeof MarkdownPreview422ResponseMessageEnum[keyof typeof MarkdownPreview422ResponseMessageEnum];

/**
 * 
 * @export
 * @interface MarkdownPreview500Response
 */
export interface MarkdownPreview500Response {
    /**
     * 
     * @type {boolean}
     * @memberof MarkdownPreview500Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof MarkdownPreview500Response
     */
    'message': MarkdownPreview500ResponseMessageEnum;
    /**
     * 
     * @type {string}
     * @memberof MarkdownPreview500Response
     */
    'error': string;
}

export const MarkdownPreview500ResponseMessageEnum = {
    FailedToConvertMarkdownToHtml: 'Failed to convert markdown to HTML'
} as const;

export type MarkdownPreview500ResponseMessageEnum = typeof MarkdownPreview500ResponseMessageEnum[keyof typeof MarkdownPreview500ResponseMessageEnum];

/**
 * 
 * @export
 * @interface MarkdownToHtmlRequest
 */
export interface MarkdownToHtmlRequest {
    /**
     * 
     * @type {string}
     * @memberof MarkdownToHtmlRequest
     */
    'markdown': string;
}
/**
 * 
 * @export
 * @interface PartnerIndex200Response
 */
export interface PartnerIndex200Response {
    /**
     * 
     * @type {Array<PartnerResource>}
     * @memberof PartnerIndex200Response
     */
    'data': Array<PartnerResource>;
    /**
     * 
     * @type {AddressIndex200ResponseLinks}
     * @memberof PartnerIndex200Response
     */
    'links': AddressIndex200ResponseLinks;
    /**
     * 
     * @type {AddressIndex200ResponseMeta}
     * @memberof PartnerIndex200Response
     */
    'meta': AddressIndex200ResponseMeta;
}
/**
 * 
 * @export
 * @interface PartnerResource
 */
export interface PartnerResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof PartnerResource
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     * @type {string}
     * @memberof PartnerResource
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     * @type {string}
     * @memberof PartnerResource
     */
    'backward_compatibility': string | null;
    /**
     * The type of the partner, either \'museum\', \'institution\' or \'individual\'.
     * @type {string}
     * @memberof PartnerResource
     */
    'type': string;
    /**
     * The country this partner is associated with, nullable (CountryResource)
     * @type {CountryResource}
     * @memberof PartnerResource
     */
    'country'?: CountryResource;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof PartnerResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof PartnerResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface PartnerStore200Response
 */
export interface PartnerStore200Response {
    /**
     * 
     * @type {PartnerResource}
     * @memberof PartnerStore200Response
     */
    'data': PartnerResource;
}
/**
 * 
 * @export
 * @interface PartnerStoreRequest
 */
export interface PartnerStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof PartnerStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof PartnerStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartnerStoreRequest
     */
    'type': PartnerStoreRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PartnerStoreRequest
     */
    'country_id'?: string | null;
}

export const PartnerStoreRequestTypeEnum = {
    Museum: 'museum',
    Institution: 'institution',
    Individual: 'individual'
} as const;

export type PartnerStoreRequestTypeEnum = typeof PartnerStoreRequestTypeEnum[keyof typeof PartnerStoreRequestTypeEnum];

/**
 * 
 * @export
 * @interface ProjectEnabled200Response
 */
export interface ProjectEnabled200Response {
    /**
     * 
     * @type {Array<ProjectResource>}
     * @memberof ProjectEnabled200Response
     */
    'data': Array<ProjectResource>;
}
/**
 * 
 * @export
 * @interface ProjectIndex200Response
 */
export interface ProjectIndex200Response {
    /**
     * 
     * @type {Array<ProjectResource>}
     * @memberof ProjectIndex200Response
     */
    'data': Array<ProjectResource>;
    /**
     * 
     * @type {AddressIndex200ResponseLinks}
     * @memberof ProjectIndex200Response
     */
    'links': AddressIndex200ResponseLinks;
    /**
     * 
     * @type {AddressIndex200ResponseMeta}
     * @memberof ProjectIndex200Response
     */
    'meta': AddressIndex200ResponseMeta;
}
/**
 * 
 * @export
 * @interface ProjectResource
 */
export interface ProjectResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof ProjectResource
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     * @type {string}
     * @memberof ProjectResource
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     * @type {string}
     * @memberof ProjectResource
     */
    'backward_compatibility': string | null;
    /**
     * Launch date of the project, nullable
     * @type {string}
     * @memberof ProjectResource
     */
    'launch_date': string | null;
    /**
     * Indicates if the project has been launched already
     * @type {boolean}
     * @memberof ProjectResource
     */
    'is_launched': boolean;
    /**
     * Indicates if the project is enabled (active)
     * @type {boolean}
     * @memberof ProjectResource
     */
    'is_enabled': boolean;
    /**
     * The default context used within the project (ContextResource)
     * @type {ContextResource}
     * @memberof ProjectResource
     */
    'context'?: ContextResource;
    /**
     * The default language used within the project (LanguageResource)
     * @type {LanguageResource}
     * @memberof ProjectResource
     */
    'language'?: LanguageResource;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof ProjectResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof ProjectResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ProjectSetEnabledRequest
 */
export interface ProjectSetEnabledRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ProjectSetEnabledRequest
     */
    'is_enabled': boolean;
}
/**
 * 
 * @export
 * @interface ProjectSetLaunched200Response
 */
export interface ProjectSetLaunched200Response {
    /**
     * 
     * @type {ProjectResource}
     * @memberof ProjectSetLaunched200Response
     */
    'data': ProjectResource;
}
/**
 * 
 * @export
 * @interface ProjectSetLaunchedRequest
 */
export interface ProjectSetLaunchedRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ProjectSetLaunchedRequest
     */
    'is_launched': boolean;
}
/**
 * 
 * @export
 * @interface ProjectStoreRequest
 */
export interface ProjectStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ProjectStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProjectStoreRequest
     */
    'launch_date'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectStoreRequest
     */
    'is_launched'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectStoreRequest
     */
    'is_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectStoreRequest
     */
    'context_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProjectStoreRequest
     */
    'language_id'?: string | null;
}
/**
 * 
 * @export
 * @interface ProvinceIndex200Response
 */
export interface ProvinceIndex200Response {
    /**
     * 
     * @type {Array<ProvinceResource>}
     * @memberof ProvinceIndex200Response
     */
    'data': Array<ProvinceResource>;
    /**
     * 
     * @type {AddressIndex200ResponseLinks}
     * @memberof ProvinceIndex200Response
     */
    'links': AddressIndex200ResponseLinks;
    /**
     * 
     * @type {AddressIndex200ResponseMeta}
     * @memberof ProvinceIndex200Response
     */
    'meta': AddressIndex200ResponseMeta;
}
/**
 * 
 * @export
 * @interface ProvinceResource
 */
export interface ProvinceResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof ProvinceResource
     */
    'id': string;
    /**
     * A name for this resource, for internal use only.
     * @type {string}
     * @memberof ProvinceResource
     */
    'internal_name': string;
    /**
     * The country this province belongs to (CountryResource id)
     * @type {string}
     * @memberof ProvinceResource
     */
    'country_id': string;
    /**
     * Translations for this province (ProvinceTranslationResource[])
     * @type {Array<ProvinceTranslationResource>}
     * @memberof ProvinceResource
     */
    'translations'?: Array<ProvinceTranslationResource>;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof ProvinceResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof ProvinceResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ProvinceStore201Response
 */
export interface ProvinceStore201Response {
    /**
     * 
     * @type {ProvinceResource}
     * @memberof ProvinceStore201Response
     */
    'data': ProvinceResource;
}
/**
 * 
 * @export
 * @interface ProvinceTranslationIndex200Response
 */
export interface ProvinceTranslationIndex200Response {
    /**
     * 
     * @type {Array<ProvinceTranslationResource>}
     * @memberof ProvinceTranslationIndex200Response
     */
    'data': Array<ProvinceTranslationResource>;
}
/**
 * 
 * @export
 * @interface ProvinceTranslationResource
 */
export interface ProvinceTranslationResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof ProvinceTranslationResource
     */
    'id': string;
    /**
     * The province this translation belongs to (ProvinceResource id)
     * @type {string}
     * @memberof ProvinceTranslationResource
     */
    'province_id': string;
    /**
     * The language of this translation (LanguageResource id)
     * @type {string}
     * @memberof ProvinceTranslationResource
     */
    'language_id': string;
    /**
     * The name of the province translation
     * @type {string}
     * @memberof ProvinceTranslationResource
     */
    'name': string;
    /**
     * The description of the province translation
     * @type {string}
     * @memberof ProvinceTranslationResource
     */
    'description': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof ProvinceTranslationResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof ProvinceTranslationResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ProvinceTranslationStore200Response
 */
export interface ProvinceTranslationStore200Response {
    /**
     * 
     * @type {ProvinceTranslationResource}
     * @memberof ProvinceTranslationStore200Response
     */
    'data': ProvinceTranslationResource;
}
/**
 * 
 * @export
 * @interface ProvinceTranslationStoreRequest
 */
export interface ProvinceTranslationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationStoreRequest
     */
    'province_id': string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationStoreRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationStoreRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface ProvinceTranslationUpdateRequest
 */
export interface ProvinceTranslationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationUpdateRequest
     */
    'province_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProvinceTranslationUpdateRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface StoreItemImageRequest
 */
export interface StoreItemImageRequest {
    /**
     * 
     * @type {string}
     * @memberof StoreItemImageRequest
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof StoreItemImageRequest
     */
    'original_name': string;
    /**
     * 
     * @type {string}
     * @memberof StoreItemImageRequest
     */
    'mime_type': string;
    /**
     * 
     * @type {number}
     * @memberof StoreItemImageRequest
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof StoreItemImageRequest
     */
    'alt_text'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof StoreItemImageRequest
     */
    'display_order'?: number;
}
/**
 * 
 * @export
 * @interface StoreItemRequest
 */
export interface StoreItemRequest {
    /**
     * 
     * @type {string}
     * @memberof StoreItemRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StoreItemRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof StoreItemRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StoreItemRequest
     */
    'type': StoreItemRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof StoreItemRequest
     */
    'parent_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StoreItemRequest
     */
    'country_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StoreItemRequest
     */
    'partner_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StoreItemRequest
     */
    'project_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StoreItemRequest
     */
    'collection_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StoreItemRequest
     */
    'owner_reference'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StoreItemRequest
     */
    'mwnf_reference'?: string | null;
}

export const StoreItemRequestTypeEnum = {
    Object: 'object',
    Monument: 'monument',
    Detail: 'detail',
    Picture: 'picture'
} as const;

export type StoreItemRequestTypeEnum = typeof StoreItemRequestTypeEnum[keyof typeof StoreItemRequestTypeEnum];

/**
 * 
 * @export
 * @interface TagIndex200Response
 */
export interface TagIndex200Response {
    /**
     * 
     * @type {Array<TagResource>}
     * @memberof TagIndex200Response
     */
    'data': Array<TagResource>;
    /**
     * 
     * @type {AddressIndex200ResponseLinks}
     * @memberof TagIndex200Response
     */
    'links': AddressIndex200ResponseLinks;
    /**
     * 
     * @type {AddressIndex200ResponseMeta}
     * @memberof TagIndex200Response
     */
    'meta': AddressIndex200ResponseMeta;
}
/**
 * 
 * @export
 * @interface TagResource
 */
export interface TagResource {
    /**
     * The unique identifier of the tag (GUID)
     * @type {string}
     * @memberof TagResource
     */
    'id': string;
    /**
     * The name of the tag, it shall only be used internally
     * @type {string}
     * @memberof TagResource
     */
    'internal_name': string;
    /**
     * The legacy Id when this tag corresponds to a legacy tag from the previous database, nullable
     * @type {string}
     * @memberof TagResource
     */
    'backward_compatibility': string | null;
    /**
     * The description of the tag
     * @type {string}
     * @memberof TagResource
     */
    'description': string;
    /**
     * Date of creation
     * @type {string}
     * @memberof TagResource
     */
    'created_at': string | null;
    /**
     * Date of last modification
     * @type {string}
     * @memberof TagResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface TagStore200Response
 */
export interface TagStore200Response {
    /**
     * 
     * @type {TagResource}
     * @memberof TagStore200Response
     */
    'data': TagResource;
}
/**
 * 
 * @export
 * @interface TagStoreRequest
 */
export interface TagStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof TagStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof TagStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TagStoreRequest
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface ThemeIndex200Response
 */
export interface ThemeIndex200Response {
    /**
     * 
     * @type {Array<ThemeResource>}
     * @memberof ThemeIndex200Response
     */
    'data': Array<ThemeResource>;
    /**
     * 
     * @type {AddressIndex200ResponseLinks}
     * @memberof ThemeIndex200Response
     */
    'links': AddressIndex200ResponseLinks;
    /**
     * 
     * @type {AddressIndex200ResponseMeta}
     * @memberof ThemeIndex200Response
     */
    'meta': AddressIndex200ResponseMeta;
}
/**
 * 
 * @export
 * @interface ThemeResource
 */
export interface ThemeResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof ThemeResource
     */
    'id': string;
    /**
     * The exhibition this theme belongs to (ExhibitionResource id)
     * @type {string}
     * @memberof ThemeResource
     */
    'exhibition_id': string;
    /**
     * The parent theme of this theme (ThemeResource id)
     * @type {string}
     * @memberof ThemeResource
     */
    'parent_id': string | null;
    /**
     * A name for this resource, for internal use only.
     * @type {string}
     * @memberof ThemeResource
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     * @type {string}
     * @memberof ThemeResource
     */
    'backward_compatibility': string | null;
    /**
     * Translations for this theme (ThemeTranslationResource[])
     * @type {Array<ThemeTranslationResource>}
     * @memberof ThemeResource
     */
    'translations'?: Array<ThemeTranslationResource>;
    /**
     * Subthemes of this theme (ThemeResource[])
     * @type {Array<ThemeResource>}
     * @memberof ThemeResource
     */
    'subthemes'?: Array<ThemeResource>;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof ThemeResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof ThemeResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ThemeStore200Response
 */
export interface ThemeStore200Response {
    /**
     * 
     * @type {ThemeResource}
     * @memberof ThemeStore200Response
     */
    'data': ThemeResource;
}
/**
 * 
 * @export
 * @interface ThemeStoreRequest
 */
export interface ThemeStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ThemeStoreRequest
     */
    'exhibition_id': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeStoreRequest
     */
    'parent_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ThemeStoreRequest
     */
    'internal_name': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeStoreRequest
     */
    'backward_compatibility'?: string | null;
}
/**
 * 
 * @export
 * @interface ThemeTranslationResource
 */
export interface ThemeTranslationResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof ThemeTranslationResource
     */
    'id': string;
    /**
     * The theme this translation belongs to (ThemeResource id)
     * @type {string}
     * @memberof ThemeTranslationResource
     */
    'theme_id': string;
    /**
     * The language of this translation (LanguageResource id)
     * @type {string}
     * @memberof ThemeTranslationResource
     */
    'language_id': string;
    /**
     * The context of this translation (ContextResource id)
     * @type {string}
     * @memberof ThemeTranslationResource
     */
    'context_id': string;
    /**
     * The title of the theme translation
     * @type {string}
     * @memberof ThemeTranslationResource
     */
    'title': string;
    /**
     * The description of the theme translation
     * @type {string}
     * @memberof ThemeTranslationResource
     */
    'description': string;
    /**
     * The introduction of the theme translation
     * @type {string}
     * @memberof ThemeTranslationResource
     */
    'introduction': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     * @type {string}
     * @memberof ThemeTranslationResource
     */
    'backward_compatibility': string | null;
    /**
     * Extra data for translation (object, may be null)
     * @type {object}
     * @memberof ThemeTranslationResource
     */
    'extra': object | null;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof ThemeTranslationResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof ThemeTranslationResource
     */
    'updated_at': string | null;
}
/**
 * 
 * @export
 * @interface ThemeTranslationStore200Response
 */
export interface ThemeTranslationStore200Response {
    /**
     * 
     * @type {ThemeTranslationResource}
     * @memberof ThemeTranslationStore200Response
     */
    'data': ThemeTranslationResource;
}
/**
 * 
 * @export
 * @interface ThemeTranslationStoreRequest
 */
export interface ThemeTranslationStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationStoreRequest
     */
    'theme_id': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationStoreRequest
     */
    'language_id': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationStoreRequest
     */
    'context_id': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationStoreRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationStoreRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationStoreRequest
     */
    'introduction': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationStoreRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationStoreRequest
     */
    'extra'?: string | null;
}
/**
 * 
 * @export
 * @interface ThemeTranslationUpdateRequest
 */
export interface ThemeTranslationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationUpdateRequest
     */
    'theme_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationUpdateRequest
     */
    'language_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationUpdateRequest
     */
    'context_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationUpdateRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationUpdateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationUpdateRequest
     */
    'introduction'?: string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationUpdateRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ThemeTranslationUpdateRequest
     */
    'extra'?: string | null;
}
/**
 * 
 * @export
 * @interface ThemeUpdateRequest
 */
export interface ThemeUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ThemeUpdateRequest
     */
    'internal_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ThemeUpdateRequest
     */
    'backward_compatibility'?: string | null;
}
/**
 * 
 * @export
 * @interface TokenAcquire201Response
 */
export interface TokenAcquire201Response {
    /**
     * 
     * @type {string}
     * @memberof TokenAcquire201Response
     */
    'token': string;
    /**
     * 
     * @type {TokenAcquire201ResponseUser}
     * @memberof TokenAcquire201Response
     */
    'user': TokenAcquire201ResponseUser;
}
/**
 * 
 * @export
 * @interface TokenAcquire201ResponseUser
 */
export interface TokenAcquire201ResponseUser {
    /**
     * 
     * @type {string}
     * @memberof TokenAcquire201ResponseUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TokenAcquire201ResponseUser
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TokenAcquire201ResponseUser
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof TokenAcquire201ResponseUser
     */
    'two_factor_enabled': boolean;
}
/**
 * 
 * @export
 * @interface TokenAcquire202Response
 */
export interface TokenAcquire202Response {
    /**
     * 
     * @type {boolean}
     * @memberof TokenAcquire202Response
     */
    'requires_two_factor': boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof TokenAcquire202Response
     */
    'available_methods': Array<any>;
    /**
     * 
     * @type {string}
     * @memberof TokenAcquire202Response
     */
    'primary_method': string | null;
    /**
     * 
     * @type {string}
     * @memberof TokenAcquire202Response
     */
    'message': TokenAcquire202ResponseMessageEnum;
}

export const TokenAcquire202ResponseMessageEnum = {
    TwoFactorAuthenticationRequiredPleaseProvideAVerificationCode: 'Two-factor authentication required. Please provide a verification code.'
} as const;

export type TokenAcquire202ResponseMessageEnum = typeof TokenAcquire202ResponseMessageEnum[keyof typeof TokenAcquire202ResponseMessageEnum];

/**
 * 
 * @export
 * @interface TokenAcquireRequest
 */
export interface TokenAcquireRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenAcquireRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TokenAcquireRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof TokenAcquireRequest
     */
    'device_name': string;
    /**
     * 
     * @type {boolean}
     * @memberof TokenAcquireRequest
     */
    'wipe_tokens'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TokenAcquireRequest
     */
    'two_factor_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenAcquireRequest
     */
    'recovery_code'?: string;
}
/**
 * 
 * @export
 * @interface TokenRequestEmailCode200Response
 */
export interface TokenRequestEmailCode200Response {
    /**
     * 
     * @type {string}
     * @memberof TokenRequestEmailCode200Response
     */
    'message': TokenRequestEmailCode200ResponseMessageEnum;
    /**
     * 
     * @type {string}
     * @memberof TokenRequestEmailCode200Response
     */
    'expires_in': string;
}

export const TokenRequestEmailCode200ResponseMessageEnum = {
    EmailVerificationCodeSentSuccessfully: 'Email verification code sent successfully.'
} as const;

export type TokenRequestEmailCode200ResponseMessageEnum = typeof TokenRequestEmailCode200ResponseMessageEnum[keyof typeof TokenRequestEmailCode200ResponseMessageEnum];

/**
 * 
 * @export
 * @interface TokenRequestEmailCodeRequest
 */
export interface TokenRequestEmailCodeRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenRequestEmailCodeRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TokenRequestEmailCodeRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface TokenTwoFactorStatus200Response
 */
export interface TokenTwoFactorStatus200Response {
    /**
     * 
     * @type {string}
     * @memberof TokenTwoFactorStatus200Response
     */
    'two_factor_enabled': string;
    /**
     * 
     * @type {string}
     * @memberof TokenTwoFactorStatus200Response
     */
    'available_methods': string;
    /**
     * 
     * @type {string}
     * @memberof TokenTwoFactorStatus200Response
     */
    'primary_method': string;
    /**
     * 
     * @type {string}
     * @memberof TokenTwoFactorStatus200Response
     */
    'requires_two_factor': string;
}
/**
 * 
 * @export
 * @interface TokenVerifyTwoFactor201Response
 */
export interface TokenVerifyTwoFactor201Response {
    /**
     * 
     * @type {string}
     * @memberof TokenVerifyTwoFactor201Response
     */
    'token': string;
    /**
     * 
     * @type {TokenVerifyTwoFactor201ResponseUser}
     * @memberof TokenVerifyTwoFactor201Response
     */
    'user': TokenVerifyTwoFactor201ResponseUser;
}
/**
 * 
 * @export
 * @interface TokenVerifyTwoFactor201ResponseUser
 */
export interface TokenVerifyTwoFactor201ResponseUser {
    /**
     * 
     * @type {string}
     * @memberof TokenVerifyTwoFactor201ResponseUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TokenVerifyTwoFactor201ResponseUser
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TokenVerifyTwoFactor201ResponseUser
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof TokenVerifyTwoFactor201ResponseUser
     */
    'two_factor_enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof TokenVerifyTwoFactor201ResponseUser
     */
    'two_factor_method': string;
}
/**
 * 
 * @export
 * @interface TokenVerifyTwoFactorRequest
 */
export interface TokenVerifyTwoFactorRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenVerifyTwoFactorRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TokenVerifyTwoFactorRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof TokenVerifyTwoFactorRequest
     */
    'device_name': string;
    /**
     * 
     * @type {string}
     * @memberof TokenVerifyTwoFactorRequest
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof TokenVerifyTwoFactorRequest
     */
    'method'?: TokenVerifyTwoFactorRequestMethodEnum;
    /**
     * 
     * @type {boolean}
     * @memberof TokenVerifyTwoFactorRequest
     */
    'wipe_tokens'?: boolean;
}

export const TokenVerifyTwoFactorRequestMethodEnum = {
    Totp: 'totp',
    Email: 'email'
} as const;

export type TokenVerifyTwoFactorRequestMethodEnum = typeof TokenVerifyTwoFactorRequestMethodEnum[keyof typeof TokenVerifyTwoFactorRequestMethodEnum];

/**
 * 
 * @export
 * @interface UpdateItemImageRequest
 */
export interface UpdateItemImageRequest {
    /**
     * Path and item_id are immutable - not allowed in updates
     * @type {string}
     * @memberof UpdateItemImageRequest
     */
    'original_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateItemImageRequest
     */
    'mime_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateItemImageRequest
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateItemImageRequest
     */
    'alt_text'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateItemImageRequest
     */
    'display_order'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateItemImageRequest
     */
    'include'?: string;
}
/**
 * 
 * @export
 * @interface UpdateItemRequest
 */
export interface UpdateItemRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateItemRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateItemRequest
     */
    'internal_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateItemRequest
     */
    'backward_compatibility'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateItemRequest
     */
    'type'?: UpdateItemRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateItemRequest
     */
    'parent_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateItemRequest
     */
    'country_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateItemRequest
     */
    'partner_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateItemRequest
     */
    'project_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateItemRequest
     */
    'collection_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateItemRequest
     */
    'owner_reference'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateItemRequest
     */
    'mwnf_reference'?: string | null;
}

export const UpdateItemRequestTypeEnum = {
    Object: 'object',
    Monument: 'monument',
    Detail: 'detail',
    Picture: 'picture'
} as const;

export type UpdateItemRequestTypeEnum = typeof UpdateItemRequestTypeEnum[keyof typeof UpdateItemRequestTypeEnum];

/**
 * 
 * @export
 * @interface UserPermissions200Response
 */
export interface UserPermissions200Response {
    /**
     * 
     * @type {string}
     * @memberof UserPermissions200Response
     */
    'data': string;
}
/**
 * 
 * @export
 * @interface WorkshopResource
 */
export interface WorkshopResource {
    /**
     * The unique identifier (GUID)
     * @type {string}
     * @memberof WorkshopResource
     */
    'id': string;
    /**
     * The name of the workshop
     * @type {string}
     * @memberof WorkshopResource
     */
    'name': string;
    /**
     * A name for this resource, for internal use only.
     * @type {string}
     * @memberof WorkshopResource
     */
    'internal_name': string;
    /**
     * The Id(s) of matching resource in the legacy system (if any).
     * @type {string}
     * @memberof WorkshopResource
     */
    'backward_compatibility': string | null;
    /**
     * The date of creation of the resource (managed by the system)
     * @type {string}
     * @memberof WorkshopResource
     */
    'created_at': string | null;
    /**
     * The date of last modification of the resource (managed by the system)
     * @type {string}
     * @memberof WorkshopResource
     */
    'updated_at': string | null;
    /**
     * Items associated with this workshop (ItemResource[])
     * @type {Array<ItemResource>}
     * @memberof WorkshopResource
     */
    'items'?: Array<ItemResource>;
}

/**
 * AddressApi - axios parameter creator
 * @export
 */
export const AddressApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified address
         * @param {string} address The address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressDestroy: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addressDestroy', 'address', address)
            const localVarPath = `/address/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of addresses
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified address
         * @param {string} address The address ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressShow: async (address: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addressShow', 'address', address)
            const localVarPath = `/address/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created address
         * @param {AddressStoreRequest} addressStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressStore: async (addressStoreRequest: AddressStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressStoreRequest' is not null or undefined
            assertParamExists('addressStore', 'addressStoreRequest', addressStoreRequest)
            const localVarPath = `/address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified address
         * @param {string} address The address ID
         * @param {AddressUpdateRequest} addressUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUpdate: async (address: string, addressUpdateRequest: AddressUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addressUpdate', 'address', address)
            // verify required parameter 'addressUpdateRequest' is not null or undefined
            assertParamExists('addressUpdate', 'addressUpdateRequest', addressUpdateRequest)
            const localVarPath = `/address/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressApi - functional programming interface
 * @export
 */
export const AddressApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified address
         * @param {string} address The address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressDestroy(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressDestroy(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.addressDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of addresses
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.addressIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified address
         * @param {string} address The address ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressShow(address: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressShow(address, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.addressShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created address
         * @param {AddressStoreRequest} addressStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressStore(addressStoreRequest: AddressStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressStore(addressStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.addressStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified address
         * @param {string} address The address ID
         * @param {AddressUpdateRequest} addressUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressUpdate(address: string, addressUpdateRequest: AddressUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressUpdate(address, addressUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.addressUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AddressApi - factory interface
 * @export
 */
export const AddressApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified address
         * @param {string} address The address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressDestroy(address: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addressDestroy(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of addresses
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressIndex200Response> {
            return localVarFp.addressIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified address
         * @param {string} address The address ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressShow(address: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressStore201Response> {
            return localVarFp.addressShow(address, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created address
         * @param {AddressStoreRequest} addressStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressStore(addressStoreRequest: AddressStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddressStore201Response> {
            return localVarFp.addressStore(addressStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified address
         * @param {string} address The address ID
         * @param {AddressUpdateRequest} addressUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUpdate(address: string, addressUpdateRequest: AddressUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddressStore201Response> {
            return localVarFp.addressUpdate(address, addressUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressApi - object-oriented interface
 * @export
 * @class AddressApi
 * @extends {BaseAPI}
 */
export class AddressApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified address
     * @param {string} address The address ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressDestroy(address: string, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).addressDestroy(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of addresses
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).addressIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified address
     * @param {string} address The address ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressShow(address: string, include?: string, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).addressShow(address, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created address
     * @param {AddressStoreRequest} addressStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressStore(addressStoreRequest: AddressStoreRequest, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).addressStore(addressStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified address
     * @param {string} address The address ID
     * @param {AddressUpdateRequest} addressUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressUpdate(address: string, addressUpdateRequest: AddressUpdateRequest, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).addressUpdate(address, addressUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AddressTranslationApi - axios parameter creator
 * @export
 */
export const AddressTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationDestroy: async (addressTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressTranslation' is not null or undefined
            assertParamExists('addressTranslationDestroy', 'addressTranslation', addressTranslation)
            const localVarPath = `/address-translation/{addressTranslation}`
                .replace(`{${"addressTranslation"}}`, encodeURIComponent(String(addressTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/address-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationShow: async (addressTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressTranslation' is not null or undefined
            assertParamExists('addressTranslationShow', 'addressTranslation', addressTranslation)
            const localVarPath = `/address-translation/{addressTranslation}`
                .replace(`{${"addressTranslation"}}`, encodeURIComponent(String(addressTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {AddressTranslationStoreRequest} addressTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationStore: async (addressTranslationStoreRequest: AddressTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressTranslationStoreRequest' is not null or undefined
            assertParamExists('addressTranslationStore', 'addressTranslationStoreRequest', addressTranslationStoreRequest)
            const localVarPath = `/address-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} addressTranslation The address translation ID
         * @param {AddressTranslationUpdateRequest} [addressTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationUpdate: async (addressTranslation: string, addressTranslationUpdateRequest?: AddressTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressTranslation' is not null or undefined
            assertParamExists('addressTranslationUpdate', 'addressTranslation', addressTranslation)
            const localVarPath = `/address-translation/{addressTranslation}`
                .replace(`{${"addressTranslation"}}`, encodeURIComponent(String(addressTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressTranslationApi - functional programming interface
 * @export
 */
export const AddressTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressTranslationDestroy(addressTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressTranslationDestroy(addressTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressTranslationApi.addressTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressTranslationApi.addressTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressTranslationShow(addressTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressTranslationShow(addressTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressTranslationApi.addressTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {AddressTranslationStoreRequest} addressTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressTranslationStore(addressTranslationStoreRequest: AddressTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressTranslationStore(addressTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressTranslationApi.addressTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} addressTranslation The address translation ID
         * @param {AddressTranslationUpdateRequest} [addressTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressTranslationUpdate(addressTranslation: string, addressTranslationUpdateRequest?: AddressTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressTranslationUpdate(addressTranslation, addressTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressTranslationApi.addressTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AddressTranslationApi - factory interface
 * @export
 */
export const AddressTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationDestroy(addressTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addressTranslationDestroy(addressTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<AddressTranslationIndex200Response> {
            return localVarFp.addressTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} addressTranslation The address translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationShow(addressTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressTranslationStore200Response> {
            return localVarFp.addressTranslationShow(addressTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {AddressTranslationStoreRequest} addressTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationStore(addressTranslationStoreRequest: AddressTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddressTranslationStore200Response> {
            return localVarFp.addressTranslationStore(addressTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} addressTranslation The address translation ID
         * @param {AddressTranslationUpdateRequest} [addressTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressTranslationUpdate(addressTranslation: string, addressTranslationUpdateRequest?: AddressTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddressTranslationStore200Response> {
            return localVarFp.addressTranslationUpdate(addressTranslation, addressTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressTranslationApi - object-oriented interface
 * @export
 * @class AddressTranslationApi
 * @extends {BaseAPI}
 */
export class AddressTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} addressTranslation The address translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressTranslationApi
     */
    public addressTranslationDestroy(addressTranslation: string, options?: RawAxiosRequestConfig) {
        return AddressTranslationApiFp(this.configuration).addressTranslationDestroy(addressTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressTranslationApi
     */
    public addressTranslationIndex(options?: RawAxiosRequestConfig) {
        return AddressTranslationApiFp(this.configuration).addressTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} addressTranslation The address translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressTranslationApi
     */
    public addressTranslationShow(addressTranslation: string, options?: RawAxiosRequestConfig) {
        return AddressTranslationApiFp(this.configuration).addressTranslationShow(addressTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {AddressTranslationStoreRequest} addressTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressTranslationApi
     */
    public addressTranslationStore(addressTranslationStoreRequest: AddressTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return AddressTranslationApiFp(this.configuration).addressTranslationStore(addressTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} addressTranslation The address translation ID
     * @param {AddressTranslationUpdateRequest} [addressTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressTranslationApi
     */
    public addressTranslationUpdate(addressTranslation: string, addressTranslationUpdateRequest?: AddressTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return AddressTranslationApiFp(this.configuration).addressTranslationUpdate(addressTranslation, addressTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AvailableImageApi - axios parameter creator
 * @export
 */
export const AvailableImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageDestroy: async (availableImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageDestroy', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageDownload: async (availableImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageDownload', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}/download`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/available-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageShow: async (availableImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageShow', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} availableImage The available image ID
         * @param {AvailableImageUpdateRequest} [availableImageUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageUpdate: async (availableImage: string, availableImageUpdateRequest?: AvailableImageUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageUpdate', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(availableImageUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageView: async (availableImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableImage' is not null or undefined
            assertParamExists('availableImageView', 'availableImage', availableImage)
            const localVarPath = `/available-image/{availableImage}/view`
                .replace(`{${"availableImage"}}`, encodeURIComponent(String(availableImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AvailableImageApi - functional programming interface
 * @export
 */
export const AvailableImageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AvailableImageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageDestroy(availableImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageDestroy(availableImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageDownload(availableImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageDownload(availableImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageDownload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableImageIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageShow(availableImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageShow(availableImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} availableImage The available image ID
         * @param {AvailableImageUpdateRequest} [availableImageUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageUpdate(availableImage: string, availableImageUpdateRequest?: AvailableImageUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableImageShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageUpdate(availableImage, availableImageUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableImageView(availableImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableImageView(availableImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvailableImageApi.availableImageView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AvailableImageApi - factory interface
 * @export
 */
export const AvailableImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AvailableImageApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageDestroy(availableImage: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.availableImageDestroy(availableImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the file to the caller
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageDownload(availableImage: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.availableImageDownload(availableImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<AvailableImageIndex200Response> {
            return localVarFp.availableImageIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageShow(availableImage: string, options?: RawAxiosRequestConfig): AxiosPromise<AvailableImageShow200Response> {
            return localVarFp.availableImageShow(availableImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} availableImage The available image ID
         * @param {AvailableImageUpdateRequest} [availableImageUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageUpdate(availableImage: string, availableImageUpdateRequest?: AvailableImageUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AvailableImageShow200Response> {
            return localVarFp.availableImageUpdate(availableImage, availableImageUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
         * @param {string} availableImage The available image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableImageView(availableImage: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.availableImageView(availableImage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AvailableImageApi - object-oriented interface
 * @export
 * @class AvailableImageApi
 * @extends {BaseAPI}
 */
export class AvailableImageApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} availableImage The available image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableImageApi
     */
    public availableImageDestroy(availableImage: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageDestroy(availableImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the file to the caller
     * @param {string} availableImage The available image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableImageApi
     */
    public availableImageDownload(availableImage: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageDownload(availableImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableImageApi
     */
    public availableImageIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} availableImage The available image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableImageApi
     */
    public availableImageShow(availableImage: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageShow(availableImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} availableImage The available image ID
     * @param {AvailableImageUpdateRequest} [availableImageUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableImageApi
     */
    public availableImageUpdate(availableImage: string, availableImageUpdateRequest?: AvailableImageUpdateRequest, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageUpdate(availableImage, availableImageUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the image file for direct viewing (e.g., for use in <img> src attribute)
     * @param {string} availableImage The available image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableImageApi
     */
    public availableImageView(availableImage: string, options?: RawAxiosRequestConfig) {
        return AvailableImageApiFp(this.configuration).availableImageView(availableImage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CollectionApi - axios parameter creator
 * @export
 */
export const CollectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Attach an item to a collection via many-to-many relationship
         * @param {string} collection The collection ID
         * @param {CollectionAttachItemRequest} collectionAttachItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionAttachItem: async (collection: string, collectionAttachItemRequest: CollectionAttachItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionAttachItem', 'collection', collection)
            // verify required parameter 'collectionAttachItemRequest' is not null or undefined
            assertParamExists('collectionAttachItem', 'collectionAttachItemRequest', collectionAttachItemRequest)
            const localVarPath = `/collection/{collection}/attach-item`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionAttachItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Attach multiple items to a collection
         * @param {string} collection The collection ID
         * @param {CollectionAttachItemsRequest} collectionAttachItemsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionAttachItems: async (collection: string, collectionAttachItemsRequest: CollectionAttachItemsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionAttachItems', 'collection', collection)
            // verify required parameter 'collectionAttachItemsRequest' is not null or undefined
            assertParamExists('collectionAttachItems', 'collectionAttachItemsRequest', collectionAttachItemsRequest)
            const localVarPath = `/collection/{collection}/attach-items`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionAttachItemsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get collections by type
         * @param {string} type 
         * @param {CollectionByTypeTypeEnum} type2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionByType: async (type: string, type2: CollectionByTypeTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('collectionByType', 'type', type)
            // verify required parameter 'type2' is not null or undefined
            assertParamExists('collectionByType', 'type2', type2)
            const localVarPath = `/collection/type/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type2 !== undefined) {
                localVarQueryParameter['type'] = type2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified collection from storage
         * @param {string} collection The collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionDestroy: async (collection: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionDestroy', 'collection', collection)
            const localVarPath = `/collection/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach an item from a collection
         * @param {string} collection The collection ID
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionDetachItem: async (collection: string, itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionDetachItem', 'collection', collection)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('collectionDetachItem', 'itemId', itemId)
            const localVarPath = `/collection/{collection}/detach-item`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (itemId !== undefined) {
                localVarQueryParameter['item_id'] = itemId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach multiple items from a collection
         * @param {string} collection The collection ID
         * @param {Array<string>} itemIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionDetachItems: async (collection: string, itemIds: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionDetachItems', 'collection', collection)
            // verify required parameter 'itemIds' is not null or undefined
            assertParamExists('collectionDetachItems', 'itemIds', itemIds)
            const localVarPath = `/collection/{collection}/detach-items`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (itemIds) {
                localVarQueryParameter['item_ids[]'] = itemIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the collections
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified collection
         * @param {string} collection The collection ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionShow: async (collection: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionShow', 'collection', collection)
            const localVarPath = `/collection/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created collection in storage
         * @param {CollectionStoreRequest} collectionStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionStore: async (collectionStoreRequest: CollectionStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionStoreRequest' is not null or undefined
            assertParamExists('collectionStore', 'collectionStoreRequest', collectionStoreRequest)
            const localVarPath = `/collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified collection in storage
         * @param {string} collection The collection ID
         * @param {CollectionUpdateRequest} [collectionUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionUpdate: async (collection: string, collectionUpdateRequest?: CollectionUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('collectionUpdate', 'collection', collection)
            const localVarPath = `/collection/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionApi - functional programming interface
 * @export
 */
export const CollectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Attach an item to a collection via many-to-many relationship
         * @param {string} collection The collection ID
         * @param {CollectionAttachItemRequest} collectionAttachItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionAttachItem(collection: string, collectionAttachItemRequest: CollectionAttachItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionAttachItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionAttachItem(collection, collectionAttachItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionAttachItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Attach multiple items to a collection
         * @param {string} collection The collection ID
         * @param {CollectionAttachItemsRequest} collectionAttachItemsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionAttachItems(collection: string, collectionAttachItemsRequest: CollectionAttachItemsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionAttachItems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionAttachItems(collection, collectionAttachItemsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionAttachItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get collections by type
         * @param {string} type 
         * @param {CollectionByTypeTypeEnum} type2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionByType(type: string, type2: CollectionByTypeTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionByType200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionByType(type, type2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionByType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified collection from storage
         * @param {string} collection The collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionDestroy(collection: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionDestroy(collection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Detach an item from a collection
         * @param {string} collection The collection ID
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionDetachItem(collection: string, itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionDetachItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionDetachItem(collection, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionDetachItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Detach multiple items from a collection
         * @param {string} collection The collection ID
         * @param {Array<string>} itemIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionDetachItems(collection: string, itemIds: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionDetachItems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionDetachItems(collection, itemIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionDetachItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the collections
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified collection
         * @param {string} collection The collection ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionShow(collection: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionShow(collection, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created collection in storage
         * @param {CollectionStoreRequest} collectionStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionStore(collectionStoreRequest: CollectionStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionStore(collectionStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified collection in storage
         * @param {string} collection The collection ID
         * @param {CollectionUpdateRequest} [collectionUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionUpdate(collection: string, collectionUpdateRequest?: CollectionUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionUpdate(collection, collectionUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.collectionUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CollectionApi - factory interface
 * @export
 */
export const CollectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionApiFp(configuration)
    return {
        /**
         * 
         * @summary Attach an item to a collection via many-to-many relationship
         * @param {string} collection The collection ID
         * @param {CollectionAttachItemRequest} collectionAttachItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionAttachItem(collection: string, collectionAttachItemRequest: CollectionAttachItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionAttachItem200Response> {
            return localVarFp.collectionAttachItem(collection, collectionAttachItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Attach multiple items to a collection
         * @param {string} collection The collection ID
         * @param {CollectionAttachItemsRequest} collectionAttachItemsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionAttachItems(collection: string, collectionAttachItemsRequest: CollectionAttachItemsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionAttachItems200Response> {
            return localVarFp.collectionAttachItems(collection, collectionAttachItemsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get collections by type
         * @param {string} type 
         * @param {CollectionByTypeTypeEnum} type2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionByType(type: string, type2: CollectionByTypeTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<CollectionByType200Response> {
            return localVarFp.collectionByType(type, type2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified collection from storage
         * @param {string} collection The collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionDestroy(collection: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.collectionDestroy(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detach an item from a collection
         * @param {string} collection The collection ID
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionDetachItem(collection: string, itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionDetachItem200Response> {
            return localVarFp.collectionDetachItem(collection, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detach multiple items from a collection
         * @param {string} collection The collection ID
         * @param {Array<string>} itemIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionDetachItems(collection: string, itemIds: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CollectionDetachItems200Response> {
            return localVarFp.collectionDetachItems(collection, itemIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the collections
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionIndex200Response> {
            return localVarFp.collectionIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified collection
         * @param {string} collection The collection ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionShow(collection: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionStore200Response> {
            return localVarFp.collectionShow(collection, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created collection in storage
         * @param {CollectionStoreRequest} collectionStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionStore(collectionStoreRequest: CollectionStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionStore200Response> {
            return localVarFp.collectionStore(collectionStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified collection in storage
         * @param {string} collection The collection ID
         * @param {CollectionUpdateRequest} [collectionUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionUpdate(collection: string, collectionUpdateRequest?: CollectionUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionStore200Response> {
            return localVarFp.collectionUpdate(collection, collectionUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionApi - object-oriented interface
 * @export
 * @class CollectionApi
 * @extends {BaseAPI}
 */
export class CollectionApi extends BaseAPI {
    /**
     * 
     * @summary Attach an item to a collection via many-to-many relationship
     * @param {string} collection The collection ID
     * @param {CollectionAttachItemRequest} collectionAttachItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public collectionAttachItem(collection: string, collectionAttachItemRequest: CollectionAttachItemRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionAttachItem(collection, collectionAttachItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Attach multiple items to a collection
     * @param {string} collection The collection ID
     * @param {CollectionAttachItemsRequest} collectionAttachItemsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public collectionAttachItems(collection: string, collectionAttachItemsRequest: CollectionAttachItemsRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionAttachItems(collection, collectionAttachItemsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get collections by type
     * @param {string} type 
     * @param {CollectionByTypeTypeEnum} type2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public collectionByType(type: string, type2: CollectionByTypeTypeEnum, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionByType(type, type2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified collection from storage
     * @param {string} collection The collection ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public collectionDestroy(collection: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionDestroy(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detach an item from a collection
     * @param {string} collection The collection ID
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public collectionDetachItem(collection: string, itemId: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionDetachItem(collection, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detach multiple items from a collection
     * @param {string} collection The collection ID
     * @param {Array<string>} itemIds 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public collectionDetachItems(collection: string, itemIds: Array<string>, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionDetachItems(collection, itemIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the collections
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public collectionIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified collection
     * @param {string} collection The collection ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public collectionShow(collection: string, include?: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionShow(collection, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created collection in storage
     * @param {CollectionStoreRequest} collectionStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public collectionStore(collectionStoreRequest: CollectionStoreRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionStore(collectionStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified collection in storage
     * @param {string} collection The collection ID
     * @param {CollectionUpdateRequest} [collectionUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public collectionUpdate(collection: string, collectionUpdateRequest?: CollectionUpdateRequest, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionUpdate(collection, collectionUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CollectionByTypeTypeEnum = {
    Collection: 'collection',
    Exhibition: 'exhibition',
    Gallery: 'gallery'
} as const;
export type CollectionByTypeTypeEnum = typeof CollectionByTypeTypeEnum[keyof typeof CollectionByTypeTypeEnum];


/**
 * ContactApi - axios parameter creator
 * @export
 */
export const ContactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified contact
         * @param {string} contact The contact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactDestroy: async (contact: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('contactDestroy', 'contact', contact)
            const localVarPath = `/contact/{contact}`
                .replace(`{${"contact"}}`, encodeURIComponent(String(contact)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of contacts
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified contact
         * @param {string} contact The contact ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactShow: async (contact: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('contactShow', 'contact', contact)
            const localVarPath = `/contact/{contact}`
                .replace(`{${"contact"}}`, encodeURIComponent(String(contact)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created contact
         * @param {ContactStoreRequest} contactStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactStore: async (contactStoreRequest: ContactStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactStoreRequest' is not null or undefined
            assertParamExists('contactStore', 'contactStoreRequest', contactStoreRequest)
            const localVarPath = `/contact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified contact
         * @param {string} contact The contact ID
         * @param {ContactUpdateRequest} contactUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactUpdate: async (contact: string, contactUpdateRequest: ContactUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('contactUpdate', 'contact', contact)
            // verify required parameter 'contactUpdateRequest' is not null or undefined
            assertParamExists('contactUpdate', 'contactUpdateRequest', contactUpdateRequest)
            const localVarPath = `/contact/{contact}`
                .replace(`{${"contact"}}`, encodeURIComponent(String(contact)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactApi - functional programming interface
 * @export
 */
export const ContactApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified contact
         * @param {string} contact The contact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactDestroy(contact: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactDestroy(contact, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.contactDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of contacts
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.contactIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified contact
         * @param {string} contact The contact ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactShow(contact: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactShow(contact, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.contactShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created contact
         * @param {ContactStoreRequest} contactStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactStore(contactStoreRequest: ContactStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactStore(contactStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.contactStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified contact
         * @param {string} contact The contact ID
         * @param {ContactUpdateRequest} contactUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactUpdate(contact: string, contactUpdateRequest: ContactUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactUpdate(contact, contactUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.contactUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactApi - factory interface
 * @export
 */
export const ContactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified contact
         * @param {string} contact The contact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactDestroy(contact: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.contactDestroy(contact, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of contacts
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContactIndex200Response> {
            return localVarFp.contactIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified contact
         * @param {string} contact The contact ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactShow(contact: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContactStore201Response> {
            return localVarFp.contactShow(contact, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created contact
         * @param {ContactStoreRequest} contactStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactStore(contactStoreRequest: ContactStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContactStore201Response> {
            return localVarFp.contactStore(contactStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified contact
         * @param {string} contact The contact ID
         * @param {ContactUpdateRequest} contactUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactUpdate(contact: string, contactUpdateRequest: ContactUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContactStore201Response> {
            return localVarFp.contactUpdate(contact, contactUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactApi - object-oriented interface
 * @export
 * @class ContactApi
 * @extends {BaseAPI}
 */
export class ContactApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified contact
     * @param {string} contact The contact ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactDestroy(contact: string, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactDestroy(contact, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of contacts
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified contact
     * @param {string} contact The contact ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactShow(contact: string, include?: string, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactShow(contact, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created contact
     * @param {ContactStoreRequest} contactStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactStore(contactStoreRequest: ContactStoreRequest, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactStore(contactStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified contact
     * @param {string} contact The contact ID
     * @param {ContactUpdateRequest} contactUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactUpdate(contact: string, contactUpdateRequest: ContactUpdateRequest, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).contactUpdate(contact, contactUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContactTranslationApi - axios parameter creator
 * @export
 */
export const ContactTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationDestroy: async (contactTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactTranslation' is not null or undefined
            assertParamExists('contactTranslationDestroy', 'contactTranslation', contactTranslation)
            const localVarPath = `/contact-translation/{contactTranslation}`
                .replace(`{${"contactTranslation"}}`, encodeURIComponent(String(contactTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contact-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationShow: async (contactTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactTranslation' is not null or undefined
            assertParamExists('contactTranslationShow', 'contactTranslation', contactTranslation)
            const localVarPath = `/contact-translation/{contactTranslation}`
                .replace(`{${"contactTranslation"}}`, encodeURIComponent(String(contactTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ContactTranslationStoreRequest} contactTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationStore: async (contactTranslationStoreRequest: ContactTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactTranslationStoreRequest' is not null or undefined
            assertParamExists('contactTranslationStore', 'contactTranslationStoreRequest', contactTranslationStoreRequest)
            const localVarPath = `/contact-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} contactTranslation The contact translation ID
         * @param {ContactTranslationUpdateRequest} [contactTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationUpdate: async (contactTranslation: string, contactTranslationUpdateRequest?: ContactTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactTranslation' is not null or undefined
            assertParamExists('contactTranslationUpdate', 'contactTranslation', contactTranslation)
            const localVarPath = `/contact-translation/{contactTranslation}`
                .replace(`{${"contactTranslation"}}`, encodeURIComponent(String(contactTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactTranslationApi - functional programming interface
 * @export
 */
export const ContactTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactTranslationDestroy(contactTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactTranslationDestroy(contactTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactTranslationApi.contactTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactTranslationApi.contactTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactTranslationShow(contactTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactTranslationShow(contactTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactTranslationApi.contactTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ContactTranslationStoreRequest} contactTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactTranslationStore(contactTranslationStoreRequest: ContactTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactTranslationStore(contactTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactTranslationApi.contactTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} contactTranslation The contact translation ID
         * @param {ContactTranslationUpdateRequest} [contactTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactTranslationUpdate(contactTranslation: string, contactTranslationUpdateRequest?: ContactTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactTranslationUpdate(contactTranslation, contactTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactTranslationApi.contactTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactTranslationApi - factory interface
 * @export
 */
export const ContactTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationDestroy(contactTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.contactTranslationDestroy(contactTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<ContactTranslationIndex200Response> {
            return localVarFp.contactTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} contactTranslation The contact translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationShow(contactTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ContactTranslationStore200Response> {
            return localVarFp.contactTranslationShow(contactTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ContactTranslationStoreRequest} contactTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationStore(contactTranslationStoreRequest: ContactTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContactTranslationStore200Response> {
            return localVarFp.contactTranslationStore(contactTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} contactTranslation The contact translation ID
         * @param {ContactTranslationUpdateRequest} [contactTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactTranslationUpdate(contactTranslation: string, contactTranslationUpdateRequest?: ContactTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContactTranslationStore200Response> {
            return localVarFp.contactTranslationUpdate(contactTranslation, contactTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactTranslationApi - object-oriented interface
 * @export
 * @class ContactTranslationApi
 * @extends {BaseAPI}
 */
export class ContactTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} contactTranslation The contact translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactTranslationApi
     */
    public contactTranslationDestroy(contactTranslation: string, options?: RawAxiosRequestConfig) {
        return ContactTranslationApiFp(this.configuration).contactTranslationDestroy(contactTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactTranslationApi
     */
    public contactTranslationIndex(options?: RawAxiosRequestConfig) {
        return ContactTranslationApiFp(this.configuration).contactTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} contactTranslation The contact translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactTranslationApi
     */
    public contactTranslationShow(contactTranslation: string, options?: RawAxiosRequestConfig) {
        return ContactTranslationApiFp(this.configuration).contactTranslationShow(contactTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {ContactTranslationStoreRequest} contactTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactTranslationApi
     */
    public contactTranslationStore(contactTranslationStoreRequest: ContactTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return ContactTranslationApiFp(this.configuration).contactTranslationStore(contactTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} contactTranslation The contact translation ID
     * @param {ContactTranslationUpdateRequest} [contactTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactTranslationApi
     */
    public contactTranslationUpdate(contactTranslation: string, contactTranslationUpdateRequest?: ContactTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return ContactTranslationApiFp(this.configuration).contactTranslationUpdate(contactTranslation, contactTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContextApi - axios parameter creator
 * @export
 */
export const ContextApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clear the default flag from any context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextClearDefault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/context/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} context The context ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDestroy: async (context: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('contextDestroy', 'context', context)
            const localVarPath = `/context/{context}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the default context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextGetDefault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/context/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set or unset a context as the default one
         * @param {string} context The context ID
         * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextSetDefault: async (context: string, contextSetDefaultRequest: ContextSetDefaultRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('contextSetDefault', 'context', context)
            // verify required parameter 'contextSetDefaultRequest' is not null or undefined
            assertParamExists('contextSetDefault', 'contextSetDefaultRequest', contextSetDefaultRequest)
            const localVarPath = `/context/{context}/default`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextSetDefaultRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} context The context ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextShow: async (context: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('contextShow', 'context', context)
            const localVarPath = `/context/{context}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ContextStoreRequest} contextStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextStore: async (contextStoreRequest: ContextStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contextStoreRequest' is not null or undefined
            assertParamExists('contextStore', 'contextStoreRequest', contextStoreRequest)
            const localVarPath = `/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} context The context ID
         * @param {ContextStoreRequest} contextStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextUpdate: async (context: string, contextStoreRequest: ContextStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('contextUpdate', 'context', context)
            // verify required parameter 'contextStoreRequest' is not null or undefined
            assertParamExists('contextUpdate', 'contextStoreRequest', contextStoreRequest)
            const localVarPath = `/context/{context}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContextApi - functional programming interface
 * @export
 */
export const ContextApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContextApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Clear the default flag from any context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextClearDefault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextClearDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextClearDefault(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextClearDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} context The context ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextDestroy(context: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextDestroy(context, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the default context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextGetDefault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextGetDefault(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextGetDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set or unset a context as the default one
         * @param {string} context The context ID
         * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextSetDefault(context: string, contextSetDefaultRequest: ContextSetDefaultRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextSetDefault(context, contextSetDefaultRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextSetDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} context The context ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextShow(context: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextShow(context, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ContextStoreRequest} contextStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextStore(contextStoreRequest: ContextStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextStore(contextStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} context The context ID
         * @param {ContextStoreRequest} contextStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextUpdate(context: string, contextStoreRequest: ContextStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextUpdate(context, contextStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContextApi.contextUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContextApi - factory interface
 * @export
 */
export const ContextApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContextApiFp(configuration)
    return {
        /**
         * 
         * @summary Clear the default flag from any context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextClearDefault(options?: RawAxiosRequestConfig): AxiosPromise<ContextClearDefault200Response> {
            return localVarFp.contextClearDefault(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} context The context ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDestroy(context: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.contextDestroy(context, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the default context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextGetDefault(options?: RawAxiosRequestConfig): AxiosPromise<ContextSetDefault200Response> {
            return localVarFp.contextGetDefault(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContextIndex200Response> {
            return localVarFp.contextIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set or unset a context as the default one
         * @param {string} context The context ID
         * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextSetDefault(context: string, contextSetDefaultRequest: ContextSetDefaultRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContextSetDefault200Response> {
            return localVarFp.contextSetDefault(context, contextSetDefaultRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} context The context ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextShow(context: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContextSetDefault200Response> {
            return localVarFp.contextShow(context, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ContextStoreRequest} contextStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextStore(contextStoreRequest: ContextStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContextSetDefault200Response> {
            return localVarFp.contextStore(contextStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} context The context ID
         * @param {ContextStoreRequest} contextStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextUpdate(context: string, contextStoreRequest: ContextStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContextSetDefault200Response> {
            return localVarFp.contextUpdate(context, contextStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContextApi - object-oriented interface
 * @export
 * @class ContextApi
 * @extends {BaseAPI}
 */
export class ContextApi extends BaseAPI {
    /**
     * 
     * @summary Clear the default flag from any context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public contextClearDefault(options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextClearDefault(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} context The context ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public contextDestroy(context: string, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextDestroy(context, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the default context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public contextGetDefault(options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextGetDefault(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public contextIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set or unset a context as the default one
     * @param {string} context The context ID
     * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public contextSetDefault(context: string, contextSetDefaultRequest: ContextSetDefaultRequest, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextSetDefault(context, contextSetDefaultRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} context The context ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public contextShow(context: string, include?: string, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextShow(context, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {ContextStoreRequest} contextStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public contextStore(contextStoreRequest: ContextStoreRequest, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextStore(contextStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} context The context ID
     * @param {ContextStoreRequest} contextStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public contextUpdate(context: string, contextStoreRequest: ContextStoreRequest, options?: RawAxiosRequestConfig) {
        return ContextApiFp(this.configuration).contextUpdate(context, contextStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CountryApi - axios parameter creator
 * @export
 */
export const CountryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} country The country ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryDestroy: async (country: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('countryDestroy', 'country', country)
            const localVarPath = `/country/{country}`
                .replace(`{${"country"}}`, encodeURIComponent(String(country)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/country`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} country The country ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryShow: async (country: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('countryShow', 'country', country)
            const localVarPath = `/country/{country}`
                .replace(`{${"country"}}`, encodeURIComponent(String(country)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {CountryStoreRequest} countryStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryStore: async (countryStoreRequest: CountryStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryStoreRequest' is not null or undefined
            assertParamExists('countryStore', 'countryStoreRequest', countryStoreRequest)
            const localVarPath = `/country`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(countryStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} country The country ID
         * @param {CountryUpdateRequest} countryUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryUpdate: async (country: string, countryUpdateRequest: CountryUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('countryUpdate', 'country', country)
            // verify required parameter 'countryUpdateRequest' is not null or undefined
            assertParamExists('countryUpdate', 'countryUpdateRequest', countryUpdateRequest)
            const localVarPath = `/country/{country}`
                .replace(`{${"country"}}`, encodeURIComponent(String(country)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(countryUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountryApi - functional programming interface
 * @export
 */
export const CountryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CountryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} country The country ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryDestroy(country: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryDestroy(country, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} country The country ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryShow(country: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryShow(country, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {CountryStoreRequest} countryStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryStore(countryStoreRequest: CountryStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryStore(countryStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} country The country ID
         * @param {CountryUpdateRequest} countryUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryUpdate(country: string, countryUpdateRequest: CountryUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryUpdate(country, countryUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CountryApi - factory interface
 * @export
 */
export const CountryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CountryApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} country The country ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryDestroy(country: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.countryDestroy(country, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<CountryIndex200Response> {
            return localVarFp.countryIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} country The country ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryShow(country: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<CountryStore200Response> {
            return localVarFp.countryShow(country, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {CountryStoreRequest} countryStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryStore(countryStoreRequest: CountryStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<CountryStore200Response> {
            return localVarFp.countryStore(countryStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} country The country ID
         * @param {CountryUpdateRequest} countryUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryUpdate(country: string, countryUpdateRequest: CountryUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CountryStore200Response> {
            return localVarFp.countryUpdate(country, countryUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CountryApi - object-oriented interface
 * @export
 * @class CountryApi
 * @extends {BaseAPI}
 */
export class CountryApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} country The country ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countryDestroy(country: string, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryDestroy(country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countryIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} country The country ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countryShow(country: string, include?: string, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryShow(country, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {CountryStoreRequest} countryStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countryStore(countryStoreRequest: CountryStoreRequest, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryStore(countryStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} country The country ID
     * @param {CountryUpdateRequest} countryUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countryUpdate(country: string, countryUpdateRequest: CountryUpdateRequest, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryUpdate(country, countryUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImageUploadApi - axios parameter creator
 * @export
 */
export const ImageUploadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadDestroy: async (imageUpload: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageUpload' is not null or undefined
            assertParamExists('imageUploadDestroy', 'imageUpload', imageUpload)
            const localVarPath = `/image-upload/{imageUpload}`
                .replace(`{${"imageUpload"}}`, encodeURIComponent(String(imageUpload)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/image-upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadShow: async (imageUpload: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageUpload' is not null or undefined
            assertParamExists('imageUploadShow', 'imageUpload', imageUpload)
            const localVarPath = `/image-upload/{imageUpload}`
                .replace(`{${"imageUpload"}}`, encodeURIComponent(String(imageUpload)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the processing status. If processing is complete, returns the AvailableImage details. If the ImageUpload no longer exists, check if an AvailableImage exists with the same ID.
         * @summary Get the processing status of an image upload
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadStatus: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageUploadStatus', 'id', id)
            const localVarPath = `/image-upload/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadStore: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('imageUploadStore', 'file', file)
            const localVarPath = `/image-upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageUploadApi - functional programming interface
 * @export
 */
export const ImageUploadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImageUploadApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadDestroy(imageUpload: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadDestroy(imageUpload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadShow(imageUpload: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadShow(imageUpload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the processing status. If processing is complete, returns the AvailableImage details. If the ImageUpload no longer exists, check if an AvailableImage exists with the same ID.
         * @summary Get the processing status of an image upload
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadStatus(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadStatus(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadStore(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadStore(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageUploadApi.imageUploadStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImageUploadApi - factory interface
 * @export
 */
export const ImageUploadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImageUploadApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadDestroy(imageUpload: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.imageUploadDestroy(imageUpload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadIndex(options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadIndex200Response> {
            return localVarFp.imageUploadIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} imageUpload The image upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadShow(imageUpload: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadStore200Response> {
            return localVarFp.imageUploadShow(imageUpload, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the processing status. If processing is complete, returns the AvailableImage details. If the ImageUpload no longer exists, check if an AvailableImage exists with the same ID.
         * @summary Get the processing status of an image upload
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadStatus(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadStatus200Response> {
            return localVarFp.imageUploadStatus(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadStore(file: File, options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadStore200Response> {
            return localVarFp.imageUploadStore(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImageUploadApi - object-oriented interface
 * @export
 * @class ImageUploadApi
 * @extends {BaseAPI}
 */
export class ImageUploadApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} imageUpload The image upload ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageUploadApi
     */
    public imageUploadDestroy(imageUpload: string, options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadDestroy(imageUpload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageUploadApi
     */
    public imageUploadIndex(options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} imageUpload The image upload ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageUploadApi
     */
    public imageUploadShow(imageUpload: string, options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadShow(imageUpload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the processing status. If processing is complete, returns the AvailableImage details. If the ImageUpload no longer exists, check if an AvailableImage exists with the same ID.
     * @summary Get the processing status of an image upload
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageUploadApi
     */
    public imageUploadStatus(id: string, options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadStatus(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageUploadApi
     */
    public imageUploadStore(file: File, options?: RawAxiosRequestConfig) {
        return ImageUploadApiFp(this.configuration).imageUploadStore(file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InfoApi - axios parameter creator
 * @export
 */
export const InfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lightweight endpoint for health monitoring that returns only the essential health status information.
         * @summary Get only the health check status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns basic application information including: - Application name and version - Health check status for key services - Timestamp of the response
         * @summary Get application information including version and health status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple endpoint that returns just the version information for deployment tracking and API compatibility checks.
         * @summary Get application version information only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoVersion: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoApi - functional programming interface
 * @export
 */
export const InfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfoApiAxiosParamCreator(configuration)
    return {
        /**
         * Lightweight endpoint for health monitoring that returns only the essential health status information.
         * @summary Get only the health check status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infoHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infoHealth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.infoHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns basic application information including: - Application name and version - Health check status for key services - Timestamp of the response
         * @summary Get application information including version and health status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infoIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infoIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.infoIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simple endpoint that returns just the version information for deployment tracking and API compatibility checks.
         * @summary Get application version information only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infoVersion(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InfoVersion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infoVersion(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.infoVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InfoApi - factory interface
 * @export
 */
export const InfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfoApiFp(configuration)
    return {
        /**
         * Lightweight endpoint for health monitoring that returns only the essential health status information.
         * @summary Get only the health check status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoHealth(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.infoHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns basic application information including: - Application name and version - Health check status for key services - Timestamp of the response
         * @summary Get application information including version and health status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoIndex(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.infoIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * Simple endpoint that returns just the version information for deployment tracking and API compatibility checks.
         * @summary Get application version information only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoVersion(options?: RawAxiosRequestConfig): AxiosPromise<InfoVersion200Response> {
            return localVarFp.infoVersion(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfoApi - object-oriented interface
 * @export
 * @class InfoApi
 * @extends {BaseAPI}
 */
export class InfoApi extends BaseAPI {
    /**
     * Lightweight endpoint for health monitoring that returns only the essential health status information.
     * @summary Get only the health check status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public infoHealth(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).infoHealth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns basic application information including: - Application name and version - Health check status for key services - Timestamp of the response
     * @summary Get application information including version and health status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public infoIndex(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).infoIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simple endpoint that returns just the version information for deployment tracking and API compatibility checks.
     * @summary Get application version information only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public infoVersion(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).infoVersion(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemApi - axios parameter creator
 * @export
 */
export const ItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get items by type
         * @param {string} type 
         * @param {ItemByTypeTypeEnum} type2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemByType: async (type: string, type2: ItemByTypeTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('itemByType', 'type', type)
            // verify required parameter 'type2' is not null or undefined
            assertParamExists('itemByType', 'type2', type2)
            const localVarPath = `/item/type/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type2 !== undefined) {
                localVarQueryParameter['type'] = type2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get child items (items with a parent)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemChildren: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item/children`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDestroy: async (item: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemDestroy', 'item', item)
            const localVarPath = `/item/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get items for a specific tag
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemForTag: async (tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('itemForTag', 'tag', tag)
            const localVarPath = `/item/for-tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get parent items (items with no parent)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemParents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item/parents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} item The item ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemShow: async (item: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemShow', 'item', item)
            const localVarPath = `/item/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreItemRequest} storeItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemStore: async (storeItemRequest: StoreItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeItemRequest' is not null or undefined
            assertParamExists('itemStore', 'storeItemRequest', storeItemRequest)
            const localVarPath = `/item`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} item The item ID
         * @param {UpdateItemRequest} [updateItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdate: async (item: string, updateItemRequest?: UpdateItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemUpdate', 'item', item)
            const localVarPath = `/item/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows quick editing of tag associations by specifying which tags to attach or detach from the item. It provides fine-grained control over tag operations without requiring a full item update.
         * @summary Update tags for the specified item without modifying other item properties
         * @param {string} item - The item to update tags for
         * @param {ItemUpdateTagsRequest} [itemUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdateTags: async (item: string, itemUpdateTagsRequest?: ItemUpdateTagsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemUpdateTags', 'item', item)
            const localVarPath = `/item/{item}/tags`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemUpdateTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get items that have ALL of the specified tags (AND condition)
         * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemWithAllTags: async (itemWithAllTagsRequest: ItemWithAllTagsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemWithAllTagsRequest' is not null or undefined
            assertParamExists('itemWithAllTags', 'itemWithAllTagsRequest', itemWithAllTagsRequest)
            const localVarPath = `/item/with-all-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemWithAllTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get items that have ANY of the specified tags (OR condition)
         * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemWithAnyTags: async (itemWithAllTagsRequest: ItemWithAllTagsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemWithAllTagsRequest' is not null or undefined
            assertParamExists('itemWithAnyTags', 'itemWithAllTagsRequest', itemWithAllTagsRequest)
            const localVarPath = `/item/with-any-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemWithAllTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemApi - functional programming interface
 * @export
 */
export const ItemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get items by type
         * @param {string} type 
         * @param {ItemByTypeTypeEnum} type2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemByType(type: string, type2: ItemByTypeTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemForTag200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemByType(type, type2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemByType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get child items (items with a parent)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemChildren(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemForTag200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemChildren(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemChildren']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemDestroy(item: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemDestroy(item, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get items for a specific tag
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemForTag(tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemForTag200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemForTag(tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemForTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get parent items (items with no parent)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemParents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemForTag200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemParents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemParents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} item The item ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemShow(item: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemShow(item, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreItemRequest} storeItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemStore(storeItemRequest: StoreItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemStore(storeItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} item The item ID
         * @param {UpdateItemRequest} [updateItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemUpdate(item: string, updateItemRequest?: UpdateItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemUpdate(item, updateItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint allows quick editing of tag associations by specifying which tags to attach or detach from the item. It provides fine-grained control over tag operations without requiring a full item update.
         * @summary Update tags for the specified item without modifying other item properties
         * @param {string} item - The item to update tags for
         * @param {ItemUpdateTagsRequest} [itemUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemUpdateTags(item: string, itemUpdateTagsRequest?: ItemUpdateTagsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemUpdateTags(item, itemUpdateTagsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemUpdateTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get items that have ALL of the specified tags (AND condition)
         * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemWithAllTags(itemWithAllTagsRequest: ItemWithAllTagsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemForTag200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemWithAllTags(itemWithAllTagsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemWithAllTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get items that have ANY of the specified tags (OR condition)
         * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemWithAnyTags(itemWithAllTagsRequest: ItemWithAllTagsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemForTag200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemWithAnyTags(itemWithAllTagsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemWithAnyTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemApi - factory interface
 * @export
 */
export const ItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemApiFp(configuration)
    return {
        /**
         * 
         * @summary Get items by type
         * @param {string} type 
         * @param {ItemByTypeTypeEnum} type2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemByType(type: string, type2: ItemByTypeTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<ItemForTag200Response> {
            return localVarFp.itemByType(type, type2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get child items (items with a parent)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemChildren(options?: RawAxiosRequestConfig): AxiosPromise<ItemForTag200Response> {
            return localVarFp.itemChildren(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} item The item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDestroy(item: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.itemDestroy(item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get items for a specific tag
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemForTag(tag: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemForTag200Response> {
            return localVarFp.itemForTag(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemIndex200Response> {
            return localVarFp.itemIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get parent items (items with no parent)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemParents(options?: RawAxiosRequestConfig): AxiosPromise<ItemForTag200Response> {
            return localVarFp.itemParents(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} item The item ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemShow(item: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemStore200Response> {
            return localVarFp.itemShow(item, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {StoreItemRequest} storeItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemStore(storeItemRequest: StoreItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemStore200Response> {
            return localVarFp.itemStore(storeItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} item The item ID
         * @param {UpdateItemRequest} [updateItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdate(item: string, updateItemRequest?: UpdateItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemStore200Response> {
            return localVarFp.itemUpdate(item, updateItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows quick editing of tag associations by specifying which tags to attach or detach from the item. It provides fine-grained control over tag operations without requiring a full item update.
         * @summary Update tags for the specified item without modifying other item properties
         * @param {string} item - The item to update tags for
         * @param {ItemUpdateTagsRequest} [itemUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdateTags(item: string, itemUpdateTagsRequest?: ItemUpdateTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemStore200Response> {
            return localVarFp.itemUpdateTags(item, itemUpdateTagsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get items that have ALL of the specified tags (AND condition)
         * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemWithAllTags(itemWithAllTagsRequest: ItemWithAllTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemForTag200Response> {
            return localVarFp.itemWithAllTags(itemWithAllTagsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get items that have ANY of the specified tags (OR condition)
         * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemWithAnyTags(itemWithAllTagsRequest: ItemWithAllTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemForTag200Response> {
            return localVarFp.itemWithAnyTags(itemWithAllTagsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemApi - object-oriented interface
 * @export
 * @class ItemApi
 * @extends {BaseAPI}
 */
export class ItemApi extends BaseAPI {
    /**
     * 
     * @summary Get items by type
     * @param {string} type 
     * @param {ItemByTypeTypeEnum} type2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemByType(type: string, type2: ItemByTypeTypeEnum, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemByType(type, type2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get child items (items with a parent)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemChildren(options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemChildren(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} item The item ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemDestroy(item: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemDestroy(item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get items for a specific tag
     * @param {string} tag The tag ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemForTag(tag: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemForTag(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get parent items (items with no parent)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemParents(options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemParents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} item The item ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemShow(item: string, include?: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemShow(item, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {StoreItemRequest} storeItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemStore(storeItemRequest: StoreItemRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemStore(storeItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} item The item ID
     * @param {UpdateItemRequest} [updateItemRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemUpdate(item: string, updateItemRequest?: UpdateItemRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemUpdate(item, updateItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows quick editing of tag associations by specifying which tags to attach or detach from the item. It provides fine-grained control over tag operations without requiring a full item update.
     * @summary Update tags for the specified item without modifying other item properties
     * @param {string} item - The item to update tags for
     * @param {ItemUpdateTagsRequest} [itemUpdateTagsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemUpdateTags(item: string, itemUpdateTagsRequest?: ItemUpdateTagsRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemUpdateTags(item, itemUpdateTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get items that have ALL of the specified tags (AND condition)
     * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemWithAllTags(itemWithAllTagsRequest: ItemWithAllTagsRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemWithAllTags(itemWithAllTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get items that have ANY of the specified tags (OR condition)
     * @param {ItemWithAllTagsRequest} itemWithAllTagsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemWithAnyTags(itemWithAllTagsRequest: ItemWithAllTagsRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemWithAnyTags(itemWithAllTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ItemByTypeTypeEnum = {
    Object: 'object',
    Monument: 'monument',
    Detail: 'detail',
    Picture: 'picture'
} as const;
export type ItemByTypeTypeEnum = typeof ItemByTypeTypeEnum[keyof typeof ItemByTypeTypeEnum];


/**
 * ItemImageApi - axios parameter creator
 * @export
 */
export const ItemImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Attach an available image to an item
         * @param {string} item The item ID
         * @param {ItemAttachImageRequest} itemAttachImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemAttachImage: async (item: string, itemAttachImageRequest: ItemAttachImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemAttachImage', 'item', item)
            // verify required parameter 'itemAttachImageRequest' is not null or undefined
            assertParamExists('itemAttachImage', 'itemAttachImageRequest', itemAttachImageRequest)
            const localVarPath = `/item/{item}/attach-image`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemAttachImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified item image
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageDestroy: async (itemImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageDestroy', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach an item image and convert it back to available image
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageDetach: async (itemImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageDetach', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}/detach`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move item image down in display order
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageMoveDown: async (itemImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageMoveDown', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}/move-down`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move item image up in display order
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageMoveUp: async (itemImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageMoveUp', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}/move-up`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified item image
         * @param {string} itemImage The item image ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageShow: async (itemImage: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageShow', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tighten ordering for all images of the item
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageTightenOrdering: async (itemImage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageTightenOrdering', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}/tighten-ordering`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified item image
         * @param {string} itemImage The item image ID
         * @param {UpdateItemImageRequest} [updateItemImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageUpdate: async (itemImage: string, updateItemImageRequest?: UpdateItemImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemImage' is not null or undefined
            assertParamExists('itemImageUpdate', 'itemImage', itemImage)
            const localVarPath = `/item-image/{itemImage}`
                .replace(`{${"itemImage"}}`, encodeURIComponent(String(itemImage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateItemImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of item images for a specific item
         * @param {string} item The item ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImagesIndex: async (item: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemImagesIndex', 'item', item)
            const localVarPath = `/item/{item}/images`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created item image
         * @param {string} item The item ID
         * @param {StoreItemImageRequest} storeItemImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImagesStore: async (item: string, storeItemImageRequest: StoreItemImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('itemImagesStore', 'item', item)
            // verify required parameter 'storeItemImageRequest' is not null or undefined
            assertParamExists('itemImagesStore', 'storeItemImageRequest', storeItemImageRequest)
            const localVarPath = `/item/{item}/images`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeItemImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemImageApi - functional programming interface
 * @export
 */
export const ItemImageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemImageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Attach an available image to an item
         * @param {string} item The item ID
         * @param {ItemAttachImageRequest} itemAttachImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemAttachImage(item: string, itemAttachImageRequest: ItemAttachImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemAttachImage(item, itemAttachImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemAttachImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified item image
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageDestroy(itemImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageDestroy(itemImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Detach an item image and convert it back to available image
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageDetach(itemImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImageDetach200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageDetach(itemImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageDetach']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move item image down in display order
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageMoveDown(itemImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageMoveDown(itemImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageMoveDown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move item image up in display order
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageMoveUp(itemImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageMoveUp(itemImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageMoveUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified item image
         * @param {string} itemImage The item image ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageShow(itemImage: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageShow(itemImage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tighten ordering for all images of the item
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageTightenOrdering(itemImage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImageTightenOrdering200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageTightenOrdering(itemImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageTightenOrdering']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified item image
         * @param {string} itemImage The item image ID
         * @param {UpdateItemImageRequest} [updateItemImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImageUpdate(itemImage: string, updateItemImageRequest?: UpdateItemImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImageUpdate(itemImage, updateItemImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImageUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of item images for a specific item
         * @param {string} item The item ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImagesIndex(item: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImagesIndex(item, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImagesIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created item image
         * @param {string} item The item ID
         * @param {StoreItemImageRequest} storeItemImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemImagesStore(item: string, storeItemImageRequest: StoreItemImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemImagesStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemImagesStore(item, storeItemImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemImageApi.itemImagesStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemImageApi - factory interface
 * @export
 */
export const ItemImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemImageApiFp(configuration)
    return {
        /**
         * 
         * @summary Attach an available image to an item
         * @param {string} item The item ID
         * @param {ItemAttachImageRequest} itemAttachImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemAttachImage(item: string, itemAttachImageRequest: ItemAttachImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesStore200Response> {
            return localVarFp.itemAttachImage(item, itemAttachImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified item image
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageDestroy(itemImage: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.itemImageDestroy(itemImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detach an item image and convert it back to available image
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageDetach(itemImage: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemImageDetach200Response> {
            return localVarFp.itemImageDetach(itemImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move item image down in display order
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageMoveDown(itemImage: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesStore200Response> {
            return localVarFp.itemImageMoveDown(itemImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move item image up in display order
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageMoveUp(itemImage: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesStore200Response> {
            return localVarFp.itemImageMoveUp(itemImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified item image
         * @param {string} itemImage The item image ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageShow(itemImage: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesStore200Response> {
            return localVarFp.itemImageShow(itemImage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Tighten ordering for all images of the item
         * @param {string} itemImage The item image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageTightenOrdering(itemImage: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemImageTightenOrdering200Response> {
            return localVarFp.itemImageTightenOrdering(itemImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified item image
         * @param {string} itemImage The item image ID
         * @param {UpdateItemImageRequest} [updateItemImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImageUpdate(itemImage: string, updateItemImageRequest?: UpdateItemImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesStore200Response> {
            return localVarFp.itemImageUpdate(itemImage, updateItemImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of item images for a specific item
         * @param {string} item The item ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImagesIndex(item: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesIndex200Response> {
            return localVarFp.itemImagesIndex(item, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created item image
         * @param {string} item The item ID
         * @param {StoreItemImageRequest} storeItemImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemImagesStore(item: string, storeItemImageRequest: StoreItemImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemImagesStore200Response> {
            return localVarFp.itemImagesStore(item, storeItemImageRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemImageApi - object-oriented interface
 * @export
 * @class ItemImageApi
 * @extends {BaseAPI}
 */
export class ItemImageApi extends BaseAPI {
    /**
     * 
     * @summary Attach an available image to an item
     * @param {string} item The item ID
     * @param {ItemAttachImageRequest} itemAttachImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemImageApi
     */
    public itemAttachImage(item: string, itemAttachImageRequest: ItemAttachImageRequest, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemAttachImage(item, itemAttachImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified item image
     * @param {string} itemImage The item image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemImageApi
     */
    public itemImageDestroy(itemImage: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageDestroy(itemImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detach an item image and convert it back to available image
     * @param {string} itemImage The item image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemImageApi
     */
    public itemImageDetach(itemImage: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageDetach(itemImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move item image down in display order
     * @param {string} itemImage The item image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemImageApi
     */
    public itemImageMoveDown(itemImage: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageMoveDown(itemImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move item image up in display order
     * @param {string} itemImage The item image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemImageApi
     */
    public itemImageMoveUp(itemImage: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageMoveUp(itemImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified item image
     * @param {string} itemImage The item image ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemImageApi
     */
    public itemImageShow(itemImage: string, include?: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageShow(itemImage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Tighten ordering for all images of the item
     * @param {string} itemImage The item image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemImageApi
     */
    public itemImageTightenOrdering(itemImage: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageTightenOrdering(itemImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified item image
     * @param {string} itemImage The item image ID
     * @param {UpdateItemImageRequest} [updateItemImageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemImageApi
     */
    public itemImageUpdate(itemImage: string, updateItemImageRequest?: UpdateItemImageRequest, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImageUpdate(itemImage, updateItemImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of item images for a specific item
     * @param {string} item The item ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemImageApi
     */
    public itemImagesIndex(item: string, include?: string, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImagesIndex(item, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created item image
     * @param {string} item The item ID
     * @param {StoreItemImageRequest} storeItemImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemImageApi
     */
    public itemImagesStore(item: string, storeItemImageRequest: StoreItemImageRequest, options?: RawAxiosRequestConfig) {
        return ItemImageApiFp(this.configuration).itemImagesStore(item, storeItemImageRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemTranslationApi - axios parameter creator
 * @export
 */
export const ItemTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationDestroy: async (itemTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationDestroy', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [itemId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationIndex: async (page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (itemId !== undefined) {
                localVarQueryParameter['item_id'] = itemId;
            }

            if (languageId !== undefined) {
                localVarQueryParameter['language_id'] = languageId;
            }

            if (contextId !== undefined) {
                localVarQueryParameter['context_id'] = contextId;
            }

            if (defaultContext !== undefined) {
                localVarQueryParameter['default_context'] = defaultContext;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationShow: async (itemTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationShow', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationStore: async (itemTranslationStoreRequest: ItemTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslationStoreRequest' is not null or undefined
            assertParamExists('itemTranslationStore', 'itemTranslationStoreRequest', itemTranslationStoreRequest)
            const localVarPath = `/item-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate: async (itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationUpdate', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemTranslationApi - functional programming interface
 * @export
 */
export const ItemTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationDestroy(itemTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [itemId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationIndex(page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemTranslationResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationIndex(page, perPage, itemId, languageId, contextId, defaultContext, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationShow(itemTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationShow(itemTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationStore(itemTranslationStoreRequest: ItemTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationStore(itemTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationUpdate(itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationUpdate(itemTranslation, itemTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationApi.itemTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemTranslationApi - factory interface
 * @export
 */
export const ItemTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.itemTranslationDestroy(itemTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [itemId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationIndex(page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<ItemTranslationResource>> {
            return localVarFp.itemTranslationIndex(page, perPage, itemId, languageId, contextId, defaultContext, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationShow(itemTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationShow(itemTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationStore(itemTranslationStoreRequest: ItemTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.itemTranslationStore(itemTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate(itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationUpdate(itemTranslation, itemTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemTranslationApi - object-oriented interface
 * @export
 * @class ItemTranslationApi
 * @extends {BaseAPI}
 */
export class ItemTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationApi
     */
    public itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationDestroy(itemTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of item translations
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [itemId] 
     * @param {string} [languageId] 
     * @param {string} [contextId] 
     * @param {boolean} [defaultContext] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationApi
     */
    public itemTranslationIndex(page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationIndex(page, perPage, itemId, languageId, contextId, defaultContext, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationApi
     */
    public itemTranslationShow(itemTranslation: string, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationShow(itemTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created item translation
     * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationApi
     */
    public itemTranslationStore(itemTranslationStoreRequest: ItemTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationStore(itemTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationApi
     */
    public itemTranslationUpdate(itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationApiFp(this.configuration).itemTranslationUpdate(itemTranslation, itemTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemTranslationsApi - axios parameter creator
 * @export
 */
export const ItemTranslationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationDestroy: async (itemTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationDestroy', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [itemId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationIndex: async (page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (itemId !== undefined) {
                localVarQueryParameter['item_id'] = itemId;
            }

            if (languageId !== undefined) {
                localVarQueryParameter['language_id'] = languageId;
            }

            if (contextId !== undefined) {
                localVarQueryParameter['context_id'] = contextId;
            }

            if (defaultContext !== undefined) {
                localVarQueryParameter['default_context'] = defaultContext;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationShow: async (itemTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationShow', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationStore: async (itemTranslationStoreRequest: ItemTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslationStoreRequest' is not null or undefined
            assertParamExists('itemTranslationStore', 'itemTranslationStoreRequest', itemTranslationStoreRequest)
            const localVarPath = `/item-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate: async (itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemTranslation' is not null or undefined
            assertParamExists('itemTranslationUpdate', 'itemTranslation', itemTranslation)
            const localVarPath = `/item-translation/{itemTranslation}`
                .replace(`{${"itemTranslation"}}`, encodeURIComponent(String(itemTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemTranslationsApi - functional programming interface
 * @export
 */
export const ItemTranslationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemTranslationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationDestroy(itemTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [itemId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationIndex(page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemTranslationResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationIndex(page, perPage, itemId, languageId, contextId, defaultContext, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationShow(itemTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationShow(itemTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationStore(itemTranslationStoreRequest: ItemTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationStore(itemTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTranslationUpdate(itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTranslationShow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTranslationUpdate(itemTranslation, itemTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemTranslationsApi.itemTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemTranslationsApi - factory interface
 * @export
 */
export const ItemTranslationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemTranslationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.itemTranslationDestroy(itemTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of item translations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [itemId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationIndex(page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<ItemTranslationResource>> {
            return localVarFp.itemTranslationIndex(page, perPage, itemId, languageId, contextId, defaultContext, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationShow(itemTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationShow(itemTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created item translation
         * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationStore(itemTranslationStoreRequest: ItemTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.itemTranslationStore(itemTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified item translation
         * @param {string} itemTranslation The item translation ID
         * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTranslationUpdate(itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemTranslationShow200Response> {
            return localVarFp.itemTranslationUpdate(itemTranslation, itemTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemTranslationsApi - object-oriented interface
 * @export
 * @class ItemTranslationsApi
 * @extends {BaseAPI}
 */
export class ItemTranslationsApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationsApi
     */
    public itemTranslationDestroy(itemTranslation: string, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationDestroy(itemTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of item translations
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [itemId] 
     * @param {string} [languageId] 
     * @param {string} [contextId] 
     * @param {boolean} [defaultContext] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationsApi
     */
    public itemTranslationIndex(page?: number, perPage?: number, itemId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationIndex(page, perPage, itemId, languageId, contextId, defaultContext, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationsApi
     */
    public itemTranslationShow(itemTranslation: string, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationShow(itemTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created item translation
     * @param {ItemTranslationStoreRequest} itemTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationsApi
     */
    public itemTranslationStore(itemTranslationStoreRequest: ItemTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationStore(itemTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified item translation
     * @param {string} itemTranslation The item translation ID
     * @param {ItemTranslationUpdateRequest} [itemTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTranslationsApi
     */
    public itemTranslationUpdate(itemTranslation: string, itemTranslationUpdateRequest?: ItemTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return ItemTranslationsApiFp(this.configuration).itemTranslationUpdate(itemTranslation, itemTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LanguageApi - axios parameter creator
 * @export
 */
export const LanguageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clear the default flag from any language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageClearDefault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/language/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageDestroy: async (language: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('languageDestroy', 'language', language)
            const localVarPath = `/language/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the default Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageGetDefault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/language/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the english Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageGetEnglish: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/language/english`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageIndex: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/language`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set or unset a Language as the default one
         * @param {string} language The language ID
         * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageSetDefault: async (language: string, contextSetDefaultRequest: ContextSetDefaultRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('languageSetDefault', 'language', language)
            // verify required parameter 'contextSetDefaultRequest' is not null or undefined
            assertParamExists('languageSetDefault', 'contextSetDefaultRequest', contextSetDefaultRequest)
            const localVarPath = `/language/{language}/default`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextSetDefaultRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageShow: async (language: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('languageShow', 'language', language)
            const localVarPath = `/language/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {LanguageStoreRequest} languageStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageStore: async (languageStoreRequest: LanguageStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'languageStoreRequest' is not null or undefined
            assertParamExists('languageStore', 'languageStoreRequest', languageStoreRequest)
            const localVarPath = `/language`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(languageStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} language The language ID
         * @param {LanguageUpdateRequest} languageUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageUpdate: async (language: string, languageUpdateRequest: LanguageUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('languageUpdate', 'language', language)
            // verify required parameter 'languageUpdateRequest' is not null or undefined
            assertParamExists('languageUpdate', 'languageUpdateRequest', languageUpdateRequest)
            const localVarPath = `/language/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(languageUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LanguageApi - functional programming interface
 * @export
 */
export const LanguageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LanguageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Clear the default flag from any language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageClearDefault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageClearDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageClearDefault(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageClearDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageDestroy(language: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageDestroy(language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the default Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageGetDefault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageGetDefault(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageGetDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the english Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageGetEnglish(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageGetEnglish(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageGetEnglish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageIndex(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageIndex(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set or unset a Language as the default one
         * @param {string} language The language ID
         * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageSetDefault(language: string, contextSetDefaultRequest: ContextSetDefaultRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageSetDefault(language, contextSetDefaultRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageSetDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageShow(language: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageShow(language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {LanguageStoreRequest} languageStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageStore(languageStoreRequest: LanguageStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageStore(languageStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} language The language ID
         * @param {LanguageUpdateRequest} languageUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languageUpdate(language: string, languageUpdateRequest: LanguageUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageSetDefault200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languageUpdate(language, languageUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguageApi.languageUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LanguageApi - factory interface
 * @export
 */
export const LanguageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LanguageApiFp(configuration)
    return {
        /**
         * 
         * @summary Clear the default flag from any language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageClearDefault(options?: RawAxiosRequestConfig): AxiosPromise<LanguageClearDefault200Response> {
            return localVarFp.languageClearDefault(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageDestroy(language: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.languageDestroy(language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the default Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageGetDefault(options?: RawAxiosRequestConfig): AxiosPromise<LanguageSetDefault200Response> {
            return localVarFp.languageGetDefault(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the english Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageGetEnglish(options?: RawAxiosRequestConfig): AxiosPromise<LanguageSetDefault200Response> {
            return localVarFp.languageGetEnglish(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageIndex(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<LanguageIndex200Response> {
            return localVarFp.languageIndex(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set or unset a Language as the default one
         * @param {string} language The language ID
         * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageSetDefault(language: string, contextSetDefaultRequest: ContextSetDefaultRequest, options?: RawAxiosRequestConfig): AxiosPromise<LanguageSetDefault200Response> {
            return localVarFp.languageSetDefault(language, contextSetDefaultRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} language The language ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageShow(language: string, options?: RawAxiosRequestConfig): AxiosPromise<LanguageSetDefault200Response> {
            return localVarFp.languageShow(language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {LanguageStoreRequest} languageStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageStore(languageStoreRequest: LanguageStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<LanguageSetDefault200Response> {
            return localVarFp.languageStore(languageStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} language The language ID
         * @param {LanguageUpdateRequest} languageUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languageUpdate(language: string, languageUpdateRequest: LanguageUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<LanguageSetDefault200Response> {
            return localVarFp.languageUpdate(language, languageUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LanguageApi - object-oriented interface
 * @export
 * @class LanguageApi
 * @extends {BaseAPI}
 */
export class LanguageApi extends BaseAPI {
    /**
     * 
     * @summary Clear the default flag from any language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageClearDefault(options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageClearDefault(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} language The language ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageDestroy(language: string, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageDestroy(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the default Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageGetDefault(options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageGetDefault(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the english Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageGetEnglish(options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageGetEnglish(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageIndex(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageIndex(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set or unset a Language as the default one
     * @param {string} language The language ID
     * @param {ContextSetDefaultRequest} contextSetDefaultRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageSetDefault(language: string, contextSetDefaultRequest: ContextSetDefaultRequest, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageSetDefault(language, contextSetDefaultRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} language The language ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageShow(language: string, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageShow(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {LanguageStoreRequest} languageStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageStore(languageStoreRequest: LanguageStoreRequest, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageStore(languageStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} language The language ID
     * @param {LanguageUpdateRequest} languageUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public languageUpdate(language: string, languageUpdateRequest: LanguageUpdateRequest, options?: RawAxiosRequestConfig) {
        return LanguageApiFp(this.configuration).languageUpdate(language, languageUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationApi - axios parameter creator
 * @export
 */
export const LocationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified location
         * @param {string} location The location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationDestroy: async (location: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('locationDestroy', 'location', location)
            const localVarPath = `/location/{location}`
                .replace(`{${"location"}}`, encodeURIComponent(String(location)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of locations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified location
         * @param {string} location The location ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationShow: async (location: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('locationShow', 'location', location)
            const localVarPath = `/location/{location}`
                .replace(`{${"location"}}`, encodeURIComponent(String(location)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created location
         * @param {LocationStoreRequest} locationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationStore: async (locationStoreRequest: LocationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationStoreRequest' is not null or undefined
            assertParamExists('locationStore', 'locationStoreRequest', locationStoreRequest)
            const localVarPath = `/location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified location
         * @param {string} location The location ID
         * @param {LocationUpdateRequest} locationUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationUpdate: async (location: string, locationUpdateRequest: LocationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('locationUpdate', 'location', location)
            // verify required parameter 'locationUpdateRequest' is not null or undefined
            assertParamExists('locationUpdate', 'locationUpdateRequest', locationUpdateRequest)
            const localVarPath = `/location/{location}`
                .replace(`{${"location"}}`, encodeURIComponent(String(location)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationApi - functional programming interface
 * @export
 */
export const LocationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified location
         * @param {string} location The location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationDestroy(location: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationDestroy(location, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of locations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified location
         * @param {string} location The location ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationShow(location: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationShow(location, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created location
         * @param {LocationStoreRequest} locationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationStore(locationStoreRequest: LocationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationStore(locationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified location
         * @param {string} location The location ID
         * @param {LocationUpdateRequest} locationUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationUpdate(location: string, locationUpdateRequest: LocationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationUpdate(location, locationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationApi - factory interface
 * @export
 */
export const LocationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified location
         * @param {string} location The location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationDestroy(location: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.locationDestroy(location, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of locations
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<LocationIndex200Response> {
            return localVarFp.locationIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified location
         * @param {string} location The location ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationShow(location: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<LocationStore201Response> {
            return localVarFp.locationShow(location, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created location
         * @param {LocationStoreRequest} locationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationStore(locationStoreRequest: LocationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationStore201Response> {
            return localVarFp.locationStore(locationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified location
         * @param {string} location The location ID
         * @param {LocationUpdateRequest} locationUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationUpdate(location: string, locationUpdateRequest: LocationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationStore201Response> {
            return localVarFp.locationUpdate(location, locationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationApi - object-oriented interface
 * @export
 * @class LocationApi
 * @extends {BaseAPI}
 */
export class LocationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified location
     * @param {string} location The location ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public locationDestroy(location: string, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationDestroy(location, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of locations
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public locationIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified location
     * @param {string} location The location ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public locationShow(location: string, include?: string, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationShow(location, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created location
     * @param {LocationStoreRequest} locationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public locationStore(locationStoreRequest: LocationStoreRequest, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationStore(locationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified location
     * @param {string} location The location ID
     * @param {LocationUpdateRequest} locationUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public locationUpdate(location: string, locationUpdateRequest: LocationUpdateRequest, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationUpdate(location, locationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationTranslationApi - axios parameter creator
 * @export
 */
export const LocationTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationDestroy: async (locationTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationTranslation' is not null or undefined
            assertParamExists('locationTranslationDestroy', 'locationTranslation', locationTranslation)
            const localVarPath = `/location-translation/{locationTranslation}`
                .replace(`{${"locationTranslation"}}`, encodeURIComponent(String(locationTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/location-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationShow: async (locationTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationTranslation' is not null or undefined
            assertParamExists('locationTranslationShow', 'locationTranslation', locationTranslation)
            const localVarPath = `/location-translation/{locationTranslation}`
                .replace(`{${"locationTranslation"}}`, encodeURIComponent(String(locationTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {LocationTranslationStoreRequest} locationTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationStore: async (locationTranslationStoreRequest: LocationTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationTranslationStoreRequest' is not null or undefined
            assertParamExists('locationTranslationStore', 'locationTranslationStoreRequest', locationTranslationStoreRequest)
            const localVarPath = `/location-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} locationTranslation The location translation ID
         * @param {LocationTranslationUpdateRequest} [locationTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationUpdate: async (locationTranslation: string, locationTranslationUpdateRequest?: LocationTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationTranslation' is not null or undefined
            assertParamExists('locationTranslationUpdate', 'locationTranslation', locationTranslation)
            const localVarPath = `/location-translation/{locationTranslation}`
                .replace(`{${"locationTranslation"}}`, encodeURIComponent(String(locationTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationTranslationApi - functional programming interface
 * @export
 */
export const LocationTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationDestroy(locationTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationDestroy(locationTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationShow(locationTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationShow(locationTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {LocationTranslationStoreRequest} locationTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationStore(locationTranslationStoreRequest: LocationTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationStore(locationTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} locationTranslation The location translation ID
         * @param {LocationTranslationUpdateRequest} [locationTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationTranslationUpdate(locationTranslation: string, locationTranslationUpdateRequest?: LocationTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationTranslationUpdate(locationTranslation, locationTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationTranslationApi.locationTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationTranslationApi - factory interface
 * @export
 */
export const LocationTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationDestroy(locationTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.locationTranslationDestroy(locationTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<LocationTranslationIndex200Response> {
            return localVarFp.locationTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} locationTranslation The location translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationShow(locationTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<LocationTranslationStore200Response> {
            return localVarFp.locationTranslationShow(locationTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {LocationTranslationStoreRequest} locationTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationStore(locationTranslationStoreRequest: LocationTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationTranslationStore200Response> {
            return localVarFp.locationTranslationStore(locationTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} locationTranslation The location translation ID
         * @param {LocationTranslationUpdateRequest} [locationTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationTranslationUpdate(locationTranslation: string, locationTranslationUpdateRequest?: LocationTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationTranslationStore200Response> {
            return localVarFp.locationTranslationUpdate(locationTranslation, locationTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationTranslationApi - object-oriented interface
 * @export
 * @class LocationTranslationApi
 * @extends {BaseAPI}
 */
export class LocationTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} locationTranslation The location translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationTranslationApi
     */
    public locationTranslationDestroy(locationTranslation: string, options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationDestroy(locationTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationTranslationApi
     */
    public locationTranslationIndex(options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} locationTranslation The location translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationTranslationApi
     */
    public locationTranslationShow(locationTranslation: string, options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationShow(locationTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {LocationTranslationStoreRequest} locationTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationTranslationApi
     */
    public locationTranslationStore(locationTranslationStoreRequest: LocationTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationStore(locationTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} locationTranslation The location translation ID
     * @param {LocationTranslationUpdateRequest} [locationTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationTranslationApi
     */
    public locationTranslationUpdate(locationTranslation: string, locationTranslationUpdateRequest?: LocationTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return LocationTranslationApiFp(this.configuration).locationTranslationUpdate(locationTranslation, locationTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MarkdownApi - axios parameter creator
 * @export
 */
export const MarkdownApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownAllowedElements: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markdown/allowed-elements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownFromHtml: async (markdownFromHtmlRequest: MarkdownFromHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownFromHtmlRequest' is not null or undefined
            assertParamExists('markdownFromHtml', 'markdownFromHtmlRequest', markdownFromHtmlRequest)
            const localVarPath = `/markdown/from-html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownFromHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownIsMarkdown: async (markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownIsMarkdownRequest' is not null or undefined
            assertParamExists('markdownIsMarkdown', 'markdownIsMarkdownRequest', markdownIsMarkdownRequest)
            const localVarPath = `/markdown/is-markdown`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownIsMarkdownRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownPreview: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markdown/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownToHtml: async (markdownToHtmlRequest: MarkdownToHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownToHtmlRequest' is not null or undefined
            assertParamExists('markdownToHtml', 'markdownToHtmlRequest', markdownToHtmlRequest)
            const localVarPath = `/markdown/to-html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownToHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownValidate: async (markdownToHtmlRequest: MarkdownToHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownToHtmlRequest' is not null or undefined
            assertParamExists('markdownValidate', 'markdownToHtmlRequest', markdownToHtmlRequest)
            const localVarPath = `/markdown/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownToHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarkdownApi - functional programming interface
 * @export
 */
export const MarkdownApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarkdownApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownAllowedElements(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownAllowedElements(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownAllowedElements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownFromHtml(markdownFromHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownFromHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownIsMarkdown(markdownIsMarkdownRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownIsMarkdown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownPreview(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarkdownPreview200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownPreview(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownPreview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownToHtml(markdownToHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownToHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownValidate(markdownToHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownApi.markdownValidate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MarkdownApi - factory interface
 * @export
 */
export const MarkdownApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarkdownApiFp(configuration)
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownAllowedElements(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownAllowedElements(options).then((request) => request(axios, basePath));
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownFromHtml(markdownFromHtmlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownIsMarkdown(markdownIsMarkdownRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownPreview(options?: RawAxiosRequestConfig): AxiosPromise<MarkdownPreview200Response> {
            return localVarFp.markdownPreview(options).then((request) => request(axios, basePath));
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownToHtml(markdownToHtmlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownValidate(markdownToHtmlRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarkdownApi - object-oriented interface
 * @export
 * @class MarkdownApi
 * @extends {BaseAPI}
 */
export class MarkdownApi extends BaseAPI {
    /**
     * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
     * @summary Get allowed HTML tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownApi
     */
    public markdownAllowedElements(options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownAllowedElements(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
     * @summary Convert HTML to Markdown
     * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownApi
     */
    public markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownFromHtml(markdownFromHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
     * @summary Check if content is Markdown
     * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownApi
     */
    public markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownIsMarkdown(markdownIsMarkdownRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
     * @summary Preview Markdown content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownApi
     */
    public markdownPreview(options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownPreview(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
     * @summary Convert Markdown to HTML
     * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownApi
     */
    public markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownToHtml(markdownToHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates Markdown content without converting it, useful for form validation.
     * @summary Validate Markdown content
     * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownApi
     */
    public markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownApiFp(this.configuration).markdownValidate(markdownToHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi - axios parameter creator
 * @export
 */
export const MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownAllowedElements: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markdown/allowed-elements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownFromHtml: async (markdownFromHtmlRequest: MarkdownFromHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownFromHtmlRequest' is not null or undefined
            assertParamExists('markdownFromHtml', 'markdownFromHtmlRequest', markdownFromHtmlRequest)
            const localVarPath = `/markdown/from-html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownFromHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownIsMarkdown: async (markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownIsMarkdownRequest' is not null or undefined
            assertParamExists('markdownIsMarkdown', 'markdownIsMarkdownRequest', markdownIsMarkdownRequest)
            const localVarPath = `/markdown/is-markdown`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownIsMarkdownRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownPreview: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markdown/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownToHtml: async (markdownToHtmlRequest: MarkdownToHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownToHtmlRequest' is not null or undefined
            assertParamExists('markdownToHtml', 'markdownToHtmlRequest', markdownToHtmlRequest)
            const localVarPath = `/markdown/to-html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownToHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownValidate: async (markdownToHtmlRequest: MarkdownToHtmlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markdownToHtmlRequest' is not null or undefined
            assertParamExists('markdownValidate', 'markdownToHtmlRequest', markdownToHtmlRequest)
            const localVarPath = `/markdown/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownToHtmlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi - functional programming interface
 * @export
 */
export const MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownAllowedElements(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownAllowedElements(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownAllowedElements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownFromHtml(markdownFromHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownFromHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownIsMarkdown(markdownIsMarkdownRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownIsMarkdown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownPreview(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarkdownPreview200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownPreview(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownPreview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownToHtml(markdownToHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownToHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markdownValidate(markdownToHtmlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi.markdownValidate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi - factory interface
 * @export
 */
export const MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(configuration)
    return {
        /**
         * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
         * @summary Get allowed HTML tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownAllowedElements(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownAllowedElements(options).then((request) => request(axios, basePath));
        },
        /**
         * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
         * @summary Convert HTML to Markdown
         * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownFromHtml(markdownFromHtmlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
         * @summary Check if content is Markdown
         * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownIsMarkdown(markdownIsMarkdownRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
         * @summary Preview Markdown content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownPreview(options?: RawAxiosRequestConfig): AxiosPromise<MarkdownPreview200Response> {
            return localVarFp.markdownPreview(options).then((request) => request(axios, basePath));
        },
        /**
         * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
         * @summary Convert Markdown to HTML
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownToHtml(markdownToHtmlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates Markdown content without converting it, useful for form validation.
         * @summary Validate Markdown content
         * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.markdownValidate(markdownToHtmlRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi - object-oriented interface
 * @export
 * @class MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi
 * @extends {BaseAPI}
 */
export class MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi extends BaseAPI {
    /**
     * Returns the list of HTML tags that are supported for HTML-to-Markdown conversion.
     * @summary Get allowed HTML tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi
     */
    public markdownAllowedElements(options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownAllowedElements(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts HTML content to Markdown format with controlled tag support. Only allowed HTML tags will be processed, others will be stripped.
     * @summary Convert HTML to Markdown
     * @param {MarkdownFromHtmlRequest} markdownFromHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi
     */
    public markdownFromHtml(markdownFromHtmlRequest: MarkdownFromHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownFromHtml(markdownFromHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Analyzes content to determine if it appears to contain Markdown formatting. Useful for automatic detection of content type.
     * @summary Check if content is Markdown
     * @param {MarkdownIsMarkdownRequest} markdownIsMarkdownRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi
     */
    public markdownIsMarkdown(markdownIsMarkdownRequest: MarkdownIsMarkdownRequest, options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownIsMarkdown(markdownIsMarkdownRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates an HTML preview of Markdown content for display purposes. This is essentially the same as markdownToHtml but with a different semantic meaning.
     * @summary Preview Markdown content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi
     */
    public markdownPreview(options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownPreview(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts Markdown formatted text to HTML for display purposes. The input is validated to ensure it contains safe Markdown content.
     * @summary Convert Markdown to HTML
     * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi
     */
    public markdownToHtml(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownToHtml(markdownToHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates Markdown content without converting it, useful for form validation.
     * @summary Validate Markdown content
     * @param {MarkdownToHtmlRequest} markdownToHtmlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkdownAPIEndpointsForMarkdownProcessingAndConversionApi
     */
    public markdownValidate(markdownToHtmlRequest: MarkdownToHtmlRequest, options?: RawAxiosRequestConfig) {
        return MarkdownAPIEndpointsForMarkdownProcessingAndConversionApiFp(this.configuration).markdownValidate(markdownToHtmlRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MobileAppAuthenticationApi - axios parameter creator
 * @export
 */
export const MobileAppAuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Acquire a token for the user
         * @param {TokenAcquireRequest} tokenAcquireRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenAcquire: async (tokenAcquireRequest: TokenAcquireRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenAcquireRequest' is not null or undefined
            assertParamExists('tokenAcquire', 'tokenAcquireRequest', tokenAcquireRequest)
            const localVarPath = `/mobile/acquire-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenAcquireRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request an email 2FA code for mobile authentication
         * @param {TokenRequestEmailCodeRequest} tokenRequestEmailCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenRequestEmailCode: async (tokenRequestEmailCodeRequest: TokenRequestEmailCodeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRequestEmailCodeRequest' is not null or undefined
            assertParamExists('tokenRequestEmailCode', 'tokenRequestEmailCodeRequest', tokenRequestEmailCodeRequest)
            const localVarPath = `/mobile/request-email-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRequestEmailCodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user\'s 2FA status and available methods
         * @param {TokenRequestEmailCodeRequest} tokenRequestEmailCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenTwoFactorStatus: async (tokenRequestEmailCodeRequest: TokenRequestEmailCodeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRequestEmailCodeRequest' is not null or undefined
            assertParamExists('tokenTwoFactorStatus', 'tokenRequestEmailCodeRequest', tokenRequestEmailCodeRequest)
            const localVarPath = `/mobile/two-factor-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRequestEmailCodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify two-factor authentication and acquire token
         * @param {TokenVerifyTwoFactorRequest} tokenVerifyTwoFactorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenVerifyTwoFactor: async (tokenVerifyTwoFactorRequest: TokenVerifyTwoFactorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenVerifyTwoFactorRequest' is not null or undefined
            assertParamExists('tokenVerifyTwoFactor', 'tokenVerifyTwoFactorRequest', tokenVerifyTwoFactorRequest)
            const localVarPath = `/mobile/verify-two-factor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenVerifyTwoFactorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke all the token for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenWipe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mobile/wipe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MobileAppAuthenticationApi - functional programming interface
 * @export
 */
export const MobileAppAuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MobileAppAuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Acquire a token for the user
         * @param {TokenAcquireRequest} tokenAcquireRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenAcquire(tokenAcquireRequest: TokenAcquireRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenAcquire201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenAcquire(tokenAcquireRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MobileAppAuthenticationApi.tokenAcquire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Request an email 2FA code for mobile authentication
         * @param {TokenRequestEmailCodeRequest} tokenRequestEmailCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenRequestEmailCode(tokenRequestEmailCodeRequest: TokenRequestEmailCodeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRequestEmailCode200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenRequestEmailCode(tokenRequestEmailCodeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MobileAppAuthenticationApi.tokenRequestEmailCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user\'s 2FA status and available methods
         * @param {TokenRequestEmailCodeRequest} tokenRequestEmailCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenTwoFactorStatus(tokenRequestEmailCodeRequest: TokenRequestEmailCodeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenTwoFactorStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenTwoFactorStatus(tokenRequestEmailCodeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MobileAppAuthenticationApi.tokenTwoFactorStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify two-factor authentication and acquire token
         * @param {TokenVerifyTwoFactorRequest} tokenVerifyTwoFactorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenVerifyTwoFactor(tokenVerifyTwoFactorRequest: TokenVerifyTwoFactorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenVerifyTwoFactor201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenVerifyTwoFactor(tokenVerifyTwoFactorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MobileAppAuthenticationApi.tokenVerifyTwoFactor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Revoke all the token for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenWipe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenWipe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MobileAppAuthenticationApi.tokenWipe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MobileAppAuthenticationApi - factory interface
 * @export
 */
export const MobileAppAuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MobileAppAuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary Acquire a token for the user
         * @param {TokenAcquireRequest} tokenAcquireRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenAcquire(tokenAcquireRequest: TokenAcquireRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenAcquire201Response> {
            return localVarFp.tokenAcquire(tokenAcquireRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request an email 2FA code for mobile authentication
         * @param {TokenRequestEmailCodeRequest} tokenRequestEmailCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenRequestEmailCode(tokenRequestEmailCodeRequest: TokenRequestEmailCodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenRequestEmailCode200Response> {
            return localVarFp.tokenRequestEmailCode(tokenRequestEmailCodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user\'s 2FA status and available methods
         * @param {TokenRequestEmailCodeRequest} tokenRequestEmailCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenTwoFactorStatus(tokenRequestEmailCodeRequest: TokenRequestEmailCodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenTwoFactorStatus200Response> {
            return localVarFp.tokenTwoFactorStatus(tokenRequestEmailCodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify two-factor authentication and acquire token
         * @param {TokenVerifyTwoFactorRequest} tokenVerifyTwoFactorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenVerifyTwoFactor(tokenVerifyTwoFactorRequest: TokenVerifyTwoFactorRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenVerifyTwoFactor201Response> {
            return localVarFp.tokenVerifyTwoFactor(tokenVerifyTwoFactorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke all the token for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenWipe(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tokenWipe(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MobileAppAuthenticationApi - object-oriented interface
 * @export
 * @class MobileAppAuthenticationApi
 * @extends {BaseAPI}
 */
export class MobileAppAuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Acquire a token for the user
     * @param {TokenAcquireRequest} tokenAcquireRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileAppAuthenticationApi
     */
    public tokenAcquire(tokenAcquireRequest: TokenAcquireRequest, options?: RawAxiosRequestConfig) {
        return MobileAppAuthenticationApiFp(this.configuration).tokenAcquire(tokenAcquireRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request an email 2FA code for mobile authentication
     * @param {TokenRequestEmailCodeRequest} tokenRequestEmailCodeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileAppAuthenticationApi
     */
    public tokenRequestEmailCode(tokenRequestEmailCodeRequest: TokenRequestEmailCodeRequest, options?: RawAxiosRequestConfig) {
        return MobileAppAuthenticationApiFp(this.configuration).tokenRequestEmailCode(tokenRequestEmailCodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user\'s 2FA status and available methods
     * @param {TokenRequestEmailCodeRequest} tokenRequestEmailCodeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileAppAuthenticationApi
     */
    public tokenTwoFactorStatus(tokenRequestEmailCodeRequest: TokenRequestEmailCodeRequest, options?: RawAxiosRequestConfig) {
        return MobileAppAuthenticationApiFp(this.configuration).tokenTwoFactorStatus(tokenRequestEmailCodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify two-factor authentication and acquire token
     * @param {TokenVerifyTwoFactorRequest} tokenVerifyTwoFactorRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileAppAuthenticationApi
     */
    public tokenVerifyTwoFactor(tokenVerifyTwoFactorRequest: TokenVerifyTwoFactorRequest, options?: RawAxiosRequestConfig) {
        return MobileAppAuthenticationApiFp(this.configuration).tokenVerifyTwoFactor(tokenVerifyTwoFactorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke all the token for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileAppAuthenticationApi
     */
    public tokenWipe(options?: RawAxiosRequestConfig) {
        return MobileAppAuthenticationApiFp(this.configuration).tokenWipe(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PartnerApi - axios parameter creator
 * @export
 */
export const PartnerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerDestroy: async (partner: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partner' is not null or undefined
            assertParamExists('partnerDestroy', 'partner', partner)
            const localVarPath = `/partner/{partner}`
                .replace(`{${"partner"}}`, encodeURIComponent(String(partner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/partner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partner The partner ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerShow: async (partner: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partner' is not null or undefined
            assertParamExists('partnerShow', 'partner', partner)
            const localVarPath = `/partner/{partner}`
                .replace(`{${"partner"}}`, encodeURIComponent(String(partner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {PartnerStoreRequest} partnerStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerStore: async (partnerStoreRequest: PartnerStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerStoreRequest' is not null or undefined
            assertParamExists('partnerStore', 'partnerStoreRequest', partnerStoreRequest)
            const localVarPath = `/partner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partnerStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partner The partner ID
         * @param {PartnerStoreRequest} partnerStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerUpdate: async (partner: string, partnerStoreRequest: PartnerStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partner' is not null or undefined
            assertParamExists('partnerUpdate', 'partner', partner)
            // verify required parameter 'partnerStoreRequest' is not null or undefined
            assertParamExists('partnerUpdate', 'partnerStoreRequest', partnerStoreRequest)
            const localVarPath = `/partner/{partner}`
                .replace(`{${"partner"}}`, encodeURIComponent(String(partner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partnerStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnerApi - functional programming interface
 * @export
 */
export const PartnerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartnerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerDestroy(partner: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerDestroy(partner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partner The partner ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerShow(partner: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerShow(partner, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {PartnerStoreRequest} partnerStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerStore(partnerStoreRequest: PartnerStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerStore(partnerStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partner The partner ID
         * @param {PartnerStoreRequest} partnerStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerUpdate(partner: string, partnerStoreRequest: PartnerStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerUpdate(partner, partnerStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.partnerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PartnerApi - factory interface
 * @export
 */
export const PartnerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartnerApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} partner The partner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerDestroy(partner: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.partnerDestroy(partner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<PartnerIndex200Response> {
            return localVarFp.partnerIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} partner The partner ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerShow(partner: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<PartnerStore200Response> {
            return localVarFp.partnerShow(partner, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {PartnerStoreRequest} partnerStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerStore(partnerStoreRequest: PartnerStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerStore200Response> {
            return localVarFp.partnerStore(partnerStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} partner The partner ID
         * @param {PartnerStoreRequest} partnerStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerUpdate(partner: string, partnerStoreRequest: PartnerStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerStore200Response> {
            return localVarFp.partnerUpdate(partner, partnerStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartnerApi - object-oriented interface
 * @export
 * @class PartnerApi
 * @extends {BaseAPI}
 */
export class PartnerApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} partner The partner ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public partnerDestroy(partner: string, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerDestroy(partner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public partnerIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} partner The partner ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public partnerShow(partner: string, include?: string, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerShow(partner, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {PartnerStoreRequest} partnerStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public partnerStore(partnerStoreRequest: PartnerStoreRequest, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerStore(partnerStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} partner The partner ID
     * @param {PartnerStoreRequest} partnerStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public partnerUpdate(partner: string, partnerStoreRequest: PartnerStoreRequest, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).partnerUpdate(partner, partnerStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectApi - axios parameter creator
 * @export
 */
export const ProjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} project The project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDestroy: async (project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectDestroy', 'project', project)
            const localVarPath = `/project/{project}`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all visible projects. The project becomes \"visible\" when all conditions are matched: - is_enabled is true - is_launched is true - current date >= launch_date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEnabled: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project/enabled`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggle Enable/disable on a project
         * @param {string} project The project ID
         * @param {ProjectSetEnabledRequest} projectSetEnabledRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSetEnabled: async (project: string, projectSetEnabledRequest: ProjectSetEnabledRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectSetEnabled', 'project', project)
            // verify required parameter 'projectSetEnabledRequest' is not null or undefined
            assertParamExists('projectSetEnabled', 'projectSetEnabledRequest', projectSetEnabledRequest)
            const localVarPath = `/project/{project}/enabled`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectSetEnabledRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggle Launched/not-launched on a project. Important: It is independant from the `launch_date` value. It is an idicator showing that the project is to be considered \'laucnhed\' as soon as the launch date it reached
         * @param {string} project The project ID
         * @param {ProjectSetLaunchedRequest} projectSetLaunchedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSetLaunched: async (project: string, projectSetLaunchedRequest: ProjectSetLaunchedRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectSetLaunched', 'project', project)
            // verify required parameter 'projectSetLaunchedRequest' is not null or undefined
            assertParamExists('projectSetLaunched', 'projectSetLaunchedRequest', projectSetLaunchedRequest)
            const localVarPath = `/project/{project}/launched`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectSetLaunchedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} project The project ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectShow: async (project: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectShow', 'project', project)
            const localVarPath = `/project/{project}`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ProjectStoreRequest} projectStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStore: async (projectStoreRequest: ProjectStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectStoreRequest' is not null or undefined
            assertParamExists('projectStore', 'projectStoreRequest', projectStoreRequest)
            const localVarPath = `/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} project The project ID
         * @param {ProjectStoreRequest} projectStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectUpdate: async (project: string, projectStoreRequest: ProjectStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectUpdate', 'project', project)
            // verify required parameter 'projectStoreRequest' is not null or undefined
            assertParamExists('projectUpdate', 'projectStoreRequest', projectStoreRequest)
            const localVarPath = `/project/{project}`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} project The project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectDestroy(project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectDestroy(project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all visible projects. The project becomes \"visible\" when all conditions are matched: - is_enabled is true - is_launched is true - current date >= launch_date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectEnabled(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectEnabled200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectEnabled(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectEnabled']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Toggle Enable/disable on a project
         * @param {string} project The project ID
         * @param {ProjectSetEnabledRequest} projectSetEnabledRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectSetEnabled(project: string, projectSetEnabledRequest: ProjectSetEnabledRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSetLaunched200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectSetEnabled(project, projectSetEnabledRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectSetEnabled']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Toggle Launched/not-launched on a project. Important: It is independant from the `launch_date` value. It is an idicator showing that the project is to be considered \'laucnhed\' as soon as the launch date it reached
         * @param {string} project The project ID
         * @param {ProjectSetLaunchedRequest} projectSetLaunchedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectSetLaunched(project: string, projectSetLaunchedRequest: ProjectSetLaunchedRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSetLaunched200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectSetLaunched(project, projectSetLaunchedRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectSetLaunched']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} project The project ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectShow(project: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSetLaunched200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectShow(project, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ProjectStoreRequest} projectStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectStore(projectStoreRequest: ProjectStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSetLaunched200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectStore(projectStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} project The project ID
         * @param {ProjectStoreRequest} projectStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectUpdate(project: string, projectStoreRequest: ProjectStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSetLaunched200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectUpdate(project, projectStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} project The project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDestroy(project: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.projectDestroy(project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all visible projects. The project becomes \"visible\" when all conditions are matched: - is_enabled is true - is_launched is true - current date >= launch_date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEnabled(options?: RawAxiosRequestConfig): AxiosPromise<ProjectEnabled200Response> {
            return localVarFp.projectEnabled(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectIndex200Response> {
            return localVarFp.projectIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Toggle Enable/disable on a project
         * @param {string} project The project ID
         * @param {ProjectSetEnabledRequest} projectSetEnabledRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSetEnabled(project: string, projectSetEnabledRequest: ProjectSetEnabledRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectSetLaunched200Response> {
            return localVarFp.projectSetEnabled(project, projectSetEnabledRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Toggle Launched/not-launched on a project. Important: It is independant from the `launch_date` value. It is an idicator showing that the project is to be considered \'laucnhed\' as soon as the launch date it reached
         * @param {string} project The project ID
         * @param {ProjectSetLaunchedRequest} projectSetLaunchedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSetLaunched(project: string, projectSetLaunchedRequest: ProjectSetLaunchedRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectSetLaunched200Response> {
            return localVarFp.projectSetLaunched(project, projectSetLaunchedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} project The project ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectShow(project: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectSetLaunched200Response> {
            return localVarFp.projectShow(project, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ProjectStoreRequest} projectStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStore(projectStoreRequest: ProjectStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectSetLaunched200Response> {
            return localVarFp.projectStore(projectStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} project The project ID
         * @param {ProjectStoreRequest} projectStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectUpdate(project: string, projectStoreRequest: ProjectStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectSetLaunched200Response> {
            return localVarFp.projectUpdate(project, projectStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} project The project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectDestroy(project: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectDestroy(project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all visible projects. The project becomes \"visible\" when all conditions are matched: - is_enabled is true - is_launched is true - current date >= launch_date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectEnabled(options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectEnabled(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Toggle Enable/disable on a project
     * @param {string} project The project ID
     * @param {ProjectSetEnabledRequest} projectSetEnabledRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectSetEnabled(project: string, projectSetEnabledRequest: ProjectSetEnabledRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectSetEnabled(project, projectSetEnabledRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Toggle Launched/not-launched on a project. Important: It is independant from the `launch_date` value. It is an idicator showing that the project is to be considered \'laucnhed\' as soon as the launch date it reached
     * @param {string} project The project ID
     * @param {ProjectSetLaunchedRequest} projectSetLaunchedRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectSetLaunched(project: string, projectSetLaunchedRequest: ProjectSetLaunchedRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectSetLaunched(project, projectSetLaunchedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} project The project ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectShow(project: string, include?: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectShow(project, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {ProjectStoreRequest} projectStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectStore(projectStoreRequest: ProjectStoreRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectStore(projectStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} project The project ID
     * @param {ProjectStoreRequest} projectStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectUpdate(project: string, projectStoreRequest: ProjectStoreRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectUpdate(project, projectStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProvinceApi - axios parameter creator
 * @export
 */
export const ProvinceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified province
         * @param {string} province The province ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceDestroy: async (province: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'province' is not null or undefined
            assertParamExists('provinceDestroy', 'province', province)
            const localVarPath = `/province/{province}`
                .replace(`{${"province"}}`, encodeURIComponent(String(province)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of provinces
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/province`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified province
         * @param {string} province The province ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceShow: async (province: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'province' is not null or undefined
            assertParamExists('provinceShow', 'province', province)
            const localVarPath = `/province/{province}`
                .replace(`{${"province"}}`, encodeURIComponent(String(province)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created province
         * @param {LocationStoreRequest} locationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceStore: async (locationStoreRequest: LocationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationStoreRequest' is not null or undefined
            assertParamExists('provinceStore', 'locationStoreRequest', locationStoreRequest)
            const localVarPath = `/province`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified province
         * @param {string} province The province ID
         * @param {LocationUpdateRequest} locationUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceUpdate: async (province: string, locationUpdateRequest: LocationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'province' is not null or undefined
            assertParamExists('provinceUpdate', 'province', province)
            // verify required parameter 'locationUpdateRequest' is not null or undefined
            assertParamExists('provinceUpdate', 'locationUpdateRequest', locationUpdateRequest)
            const localVarPath = `/province/{province}`
                .replace(`{${"province"}}`, encodeURIComponent(String(province)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvinceApi - functional programming interface
 * @export
 */
export const ProvinceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProvinceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified province
         * @param {string} province The province ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceDestroy(province: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceDestroy(province, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of provinces
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified province
         * @param {string} province The province ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceShow(province: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceShow(province, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created province
         * @param {LocationStoreRequest} locationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceStore(locationStoreRequest: LocationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceStore(locationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified province
         * @param {string} province The province ID
         * @param {LocationUpdateRequest} locationUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceUpdate(province: string, locationUpdateRequest: LocationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceStore201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceUpdate(province, locationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceApi.provinceUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProvinceApi - factory interface
 * @export
 */
export const ProvinceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProvinceApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified province
         * @param {string} province The province ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceDestroy(province: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.provinceDestroy(province, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of provinces
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceIndex200Response> {
            return localVarFp.provinceIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified province
         * @param {string} province The province ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceShow(province: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceStore201Response> {
            return localVarFp.provinceShow(province, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created province
         * @param {LocationStoreRequest} locationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceStore(locationStoreRequest: LocationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceStore201Response> {
            return localVarFp.provinceStore(locationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified province
         * @param {string} province The province ID
         * @param {LocationUpdateRequest} locationUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceUpdate(province: string, locationUpdateRequest: LocationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceStore201Response> {
            return localVarFp.provinceUpdate(province, locationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProvinceApi - object-oriented interface
 * @export
 * @class ProvinceApi
 * @extends {BaseAPI}
 */
export class ProvinceApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified province
     * @param {string} province The province ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceApi
     */
    public provinceDestroy(province: string, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceDestroy(province, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of provinces
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceApi
     */
    public provinceIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified province
     * @param {string} province The province ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceApi
     */
    public provinceShow(province: string, include?: string, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceShow(province, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created province
     * @param {LocationStoreRequest} locationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceApi
     */
    public provinceStore(locationStoreRequest: LocationStoreRequest, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceStore(locationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified province
     * @param {string} province The province ID
     * @param {LocationUpdateRequest} locationUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceApi
     */
    public provinceUpdate(province: string, locationUpdateRequest: LocationUpdateRequest, options?: RawAxiosRequestConfig) {
        return ProvinceApiFp(this.configuration).provinceUpdate(province, locationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProvinceTranslationApi - axios parameter creator
 * @export
 */
export const ProvinceTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationDestroy: async (provinceTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provinceTranslation' is not null or undefined
            assertParamExists('provinceTranslationDestroy', 'provinceTranslation', provinceTranslation)
            const localVarPath = `/province-translation/{provinceTranslation}`
                .replace(`{${"provinceTranslation"}}`, encodeURIComponent(String(provinceTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationIndex: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/province-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationShow: async (provinceTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provinceTranslation' is not null or undefined
            assertParamExists('provinceTranslationShow', 'provinceTranslation', provinceTranslation)
            const localVarPath = `/province-translation/{provinceTranslation}`
                .replace(`{${"provinceTranslation"}}`, encodeURIComponent(String(provinceTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ProvinceTranslationStoreRequest} provinceTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationStore: async (provinceTranslationStoreRequest: ProvinceTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provinceTranslationStoreRequest' is not null or undefined
            assertParamExists('provinceTranslationStore', 'provinceTranslationStoreRequest', provinceTranslationStoreRequest)
            const localVarPath = `/province-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provinceTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} provinceTranslation The province translation ID
         * @param {ProvinceTranslationUpdateRequest} [provinceTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationUpdate: async (provinceTranslation: string, provinceTranslationUpdateRequest?: ProvinceTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provinceTranslation' is not null or undefined
            assertParamExists('provinceTranslationUpdate', 'provinceTranslation', provinceTranslation)
            const localVarPath = `/province-translation/{provinceTranslation}`
                .replace(`{${"provinceTranslation"}}`, encodeURIComponent(String(provinceTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provinceTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvinceTranslationApi - functional programming interface
 * @export
 */
export const ProvinceTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProvinceTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationDestroy(provinceTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationDestroy(provinceTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationIndex(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceTranslationIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationIndex(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationShow(provinceTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationShow(provinceTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ProvinceTranslationStoreRequest} provinceTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationStore(provinceTranslationStoreRequest: ProvinceTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationStore(provinceTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} provinceTranslation The province translation ID
         * @param {ProvinceTranslationUpdateRequest} [provinceTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provinceTranslationUpdate(provinceTranslation: string, provinceTranslationUpdateRequest?: ProvinceTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvinceTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provinceTranslationUpdate(provinceTranslation, provinceTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvinceTranslationApi.provinceTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProvinceTranslationApi - factory interface
 * @export
 */
export const ProvinceTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProvinceTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationDestroy(provinceTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.provinceTranslationDestroy(provinceTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationIndex(options?: RawAxiosRequestConfig): AxiosPromise<ProvinceTranslationIndex200Response> {
            return localVarFp.provinceTranslationIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} provinceTranslation The province translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationShow(provinceTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceTranslationStore200Response> {
            return localVarFp.provinceTranslationShow(provinceTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {ProvinceTranslationStoreRequest} provinceTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationStore(provinceTranslationStoreRequest: ProvinceTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceTranslationStore200Response> {
            return localVarFp.provinceTranslationStore(provinceTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} provinceTranslation The province translation ID
         * @param {ProvinceTranslationUpdateRequest} [provinceTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceTranslationUpdate(provinceTranslation: string, provinceTranslationUpdateRequest?: ProvinceTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvinceTranslationStore200Response> {
            return localVarFp.provinceTranslationUpdate(provinceTranslation, provinceTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProvinceTranslationApi - object-oriented interface
 * @export
 * @class ProvinceTranslationApi
 * @extends {BaseAPI}
 */
export class ProvinceTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} provinceTranslation The province translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceTranslationApi
     */
    public provinceTranslationDestroy(provinceTranslation: string, options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationDestroy(provinceTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceTranslationApi
     */
    public provinceTranslationIndex(options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} provinceTranslation The province translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceTranslationApi
     */
    public provinceTranslationShow(provinceTranslation: string, options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationShow(provinceTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {ProvinceTranslationStoreRequest} provinceTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceTranslationApi
     */
    public provinceTranslationStore(provinceTranslationStoreRequest: ProvinceTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationStore(provinceTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} provinceTranslation The province translation ID
     * @param {ProvinceTranslationUpdateRequest} [provinceTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvinceTranslationApi
     */
    public provinceTranslationUpdate(provinceTranslation: string, provinceTranslationUpdateRequest?: ProvinceTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return ProvinceTranslationApiFp(this.configuration).provinceTranslationUpdate(provinceTranslation, provinceTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagApi - axios parameter creator
 * @export
 */
export const TagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDestroy: async (tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('tagDestroy', 'tag', tag)
            const localVarPath = `/tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tags for a specific item
         * @param {string} item The item ID
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagForItem: async (item: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('tagForItem', 'item', item)
            const localVarPath = `/tag/for-item/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagIndex: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagShow: async (tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('tagShow', 'tag', tag)
            const localVarPath = `/tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {TagStoreRequest} tagStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagStore: async (tagStoreRequest: TagStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagStoreRequest' is not null or undefined
            assertParamExists('tagStore', 'tagStoreRequest', tagStoreRequest)
            const localVarPath = `/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} tag The tag ID
         * @param {TagStoreRequest} tagStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagUpdate: async (tag: string, tagStoreRequest: TagStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('tagUpdate', 'tag', tag)
            // verify required parameter 'tagStoreRequest' is not null or undefined
            assertParamExists('tagUpdate', 'tagStoreRequest', tagStoreRequest)
            const localVarPath = `/tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagApi - functional programming interface
 * @export
 */
export const TagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagDestroy(tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagDestroy(tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get tags for a specific item
         * @param {string} item The item ID
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagForItem(item: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagForItem(item, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagForItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagIndex(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagIndex(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagShow(tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagShow(tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {TagStoreRequest} tagStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagStore(tagStoreRequest: TagStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagStore(tagStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} tag The tag ID
         * @param {TagStoreRequest} tagStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagUpdate(tag: string, tagStoreRequest: TagStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagUpdate(tag, tagStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagApi - factory interface
 * @export
 */
export const TagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified resource from storage
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDestroy(tag: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tagDestroy(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tags for a specific item
         * @param {string} item The item ID
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagForItem(item: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<TagIndex200Response> {
            return localVarFp.tagForItem(item, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagIndex(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<TagIndex200Response> {
            return localVarFp.tagIndex(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} tag The tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagShow(tag: string, options?: RawAxiosRequestConfig): AxiosPromise<TagStore200Response> {
            return localVarFp.tagShow(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created resource in storage
         * @param {TagStoreRequest} tagStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagStore(tagStoreRequest: TagStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<TagStore200Response> {
            return localVarFp.tagStore(tagStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified resource in storage
         * @param {string} tag The tag ID
         * @param {TagStoreRequest} tagStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagUpdate(tag: string, tagStoreRequest: TagStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<TagStore200Response> {
            return localVarFp.tagUpdate(tag, tagStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagApi - object-oriented interface
 * @export
 * @class TagApi
 * @extends {BaseAPI}
 */
export class TagApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified resource from storage
     * @param {string} tag The tag ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public tagDestroy(tag: string, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagDestroy(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tags for a specific item
     * @param {string} item The item ID
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public tagForItem(item: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagForItem(item, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public tagIndex(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagIndex(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} tag The tag ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public tagShow(tag: string, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagShow(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created resource in storage
     * @param {TagStoreRequest} tagStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public tagStore(tagStoreRequest: TagStoreRequest, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagStore(tagStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified resource in storage
     * @param {string} tag The tag ID
     * @param {TagStoreRequest} tagStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public tagUpdate(tag: string, tagStoreRequest: TagStoreRequest, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagUpdate(tag, tagStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ThemeApi - axios parameter creator
 * @export
 */
export const ThemeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified theme from storage
         * @param {string} theme The theme ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeDestroy: async (theme: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'theme' is not null or undefined
            assertParamExists('themeDestroy', 'theme', theme)
            const localVarPath = `/theme/{theme}`
                .replace(`{${"theme"}}`, encodeURIComponent(String(theme)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeIndex: async (page?: number, perPage?: number, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/theme`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} theme The theme ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeShow: async (theme: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'theme' is not null or undefined
            assertParamExists('themeShow', 'theme', theme)
            const localVarPath = `/theme/{theme}`
                .replace(`{${"theme"}}`, encodeURIComponent(String(theme)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created theme in storage
         * @param {ThemeStoreRequest} themeStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeStore: async (themeStoreRequest: ThemeStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeStoreRequest' is not null or undefined
            assertParamExists('themeStore', 'themeStoreRequest', themeStoreRequest)
            const localVarPath = `/theme`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(themeStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified theme in storage
         * @param {string} theme The theme ID
         * @param {ThemeUpdateRequest} [themeUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeUpdate: async (theme: string, themeUpdateRequest?: ThemeUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'theme' is not null or undefined
            assertParamExists('themeUpdate', 'theme', theme)
            const localVarPath = `/theme/{theme}`
                .replace(`{${"theme"}}`, encodeURIComponent(String(theme)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(themeUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThemeApi - functional programming interface
 * @export
 */
export const ThemeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThemeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme from storage
         * @param {string} theme The theme ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeDestroy(theme: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeDestroy(theme, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeApi.themeDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeIndex(page, perPage, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeApi.themeIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} theme The theme ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeShow(theme: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeShow(theme, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeApi.themeShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created theme in storage
         * @param {ThemeStoreRequest} themeStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeStore(themeStoreRequest: ThemeStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeStore(themeStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeApi.themeStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified theme in storage
         * @param {string} theme The theme ID
         * @param {ThemeUpdateRequest} [themeUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeUpdate(theme: string, themeUpdateRequest?: ThemeUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeUpdate(theme, themeUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeApi.themeUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ThemeApi - factory interface
 * @export
 */
export const ThemeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThemeApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme from storage
         * @param {string} theme The theme ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeDestroy(theme: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.themeDestroy(theme, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of the resource
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ThemeIndex200Response> {
            return localVarFp.themeIndex(page, perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified resource
         * @param {string} theme The theme ID
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeShow(theme: string, include?: string, options?: RawAxiosRequestConfig): AxiosPromise<ThemeStore200Response> {
            return localVarFp.themeShow(theme, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created theme in storage
         * @param {ThemeStoreRequest} themeStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeStore(themeStoreRequest: ThemeStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeStore200Response> {
            return localVarFp.themeStore(themeStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified theme in storage
         * @param {string} theme The theme ID
         * @param {ThemeUpdateRequest} [themeUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeUpdate(theme: string, themeUpdateRequest?: ThemeUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeStore200Response> {
            return localVarFp.themeUpdate(theme, themeUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThemeApi - object-oriented interface
 * @export
 * @class ThemeApi
 * @extends {BaseAPI}
 */
export class ThemeApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified theme from storage
     * @param {string} theme The theme ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeApi
     */
    public themeDestroy(theme: string, options?: RawAxiosRequestConfig) {
        return ThemeApiFp(this.configuration).themeDestroy(theme, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of the resource
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeApi
     */
    public themeIndex(page?: number, perPage?: number, include?: string, options?: RawAxiosRequestConfig) {
        return ThemeApiFp(this.configuration).themeIndex(page, perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified resource
     * @param {string} theme The theme ID
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeApi
     */
    public themeShow(theme: string, include?: string, options?: RawAxiosRequestConfig) {
        return ThemeApiFp(this.configuration).themeShow(theme, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created theme in storage
     * @param {ThemeStoreRequest} themeStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeApi
     */
    public themeStore(themeStoreRequest: ThemeStoreRequest, options?: RawAxiosRequestConfig) {
        return ThemeApiFp(this.configuration).themeStore(themeStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified theme in storage
     * @param {string} theme The theme ID
     * @param {ThemeUpdateRequest} [themeUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeApi
     */
    public themeUpdate(theme: string, themeUpdateRequest?: ThemeUpdateRequest, options?: RawAxiosRequestConfig) {
        return ThemeApiFp(this.configuration).themeUpdate(theme, themeUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ThemeTranslationApi - axios parameter creator
 * @export
 */
export const ThemeTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationDestroy: async (themeTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationDestroy', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {string} [themeId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationIndex: async (themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/theme-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (themeId !== undefined) {
                localVarQueryParameter['theme_id'] = themeId;
            }

            if (languageId !== undefined) {
                localVarQueryParameter['language_id'] = languageId;
            }

            if (contextId !== undefined) {
                localVarQueryParameter['context_id'] = contextId;
            }

            if (defaultContext !== undefined) {
                localVarQueryParameter['default_context'] = defaultContext;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationShow: async (themeTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationShow', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {ThemeTranslationStoreRequest} themeTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationStore: async (themeTranslationStoreRequest: ThemeTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslationStoreRequest' is not null or undefined
            assertParamExists('themeTranslationStore', 'themeTranslationStoreRequest', themeTranslationStoreRequest)
            const localVarPath = `/theme-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(themeTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {ThemeTranslationUpdateRequest} [themeTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate: async (themeTranslation: string, themeTranslationUpdateRequest?: ThemeTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationUpdate', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(themeTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThemeTranslationApi - functional programming interface
 * @export
 */
export const ThemeTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThemeTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationDestroy(themeTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationApi.themeTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {string} [themeId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationIndex(themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThemeTranslationResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationIndex(themeId, languageId, contextId, defaultContext, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationApi.themeTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationShow(themeTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationApi.themeTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {ThemeTranslationStoreRequest} themeTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationStore(themeTranslationStoreRequest: ThemeTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationStore(themeTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationApi.themeTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {ThemeTranslationUpdateRequest} [themeTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationUpdate(themeTranslation: string, themeTranslationUpdateRequest?: ThemeTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationUpdate(themeTranslation, themeTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationApi.themeTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ThemeTranslationApi - factory interface
 * @export
 */
export const ThemeTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThemeTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.themeTranslationDestroy(themeTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {string} [themeId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationIndex(themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<ThemeTranslationResource>> {
            return localVarFp.themeTranslationIndex(themeId, languageId, contextId, defaultContext, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationStore200Response> {
            return localVarFp.themeTranslationShow(themeTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {ThemeTranslationStoreRequest} themeTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationStore(themeTranslationStoreRequest: ThemeTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationStore200Response> {
            return localVarFp.themeTranslationStore(themeTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {ThemeTranslationUpdateRequest} [themeTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate(themeTranslation: string, themeTranslationUpdateRequest?: ThemeTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationStore200Response> {
            return localVarFp.themeTranslationUpdate(themeTranslation, themeTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThemeTranslationApi - object-oriented interface
 * @export
 * @class ThemeTranslationApi
 * @extends {BaseAPI}
 */
export class ThemeTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeTranslationApi
     */
    public themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig) {
        return ThemeTranslationApiFp(this.configuration).themeTranslationDestroy(themeTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of theme translations
     * @param {string} [themeId] 
     * @param {string} [languageId] 
     * @param {string} [contextId] 
     * @param {boolean} [defaultContext] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeTranslationApi
     */
    public themeTranslationIndex(themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig) {
        return ThemeTranslationApiFp(this.configuration).themeTranslationIndex(themeId, languageId, contextId, defaultContext, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeTranslationApi
     */
    public themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig) {
        return ThemeTranslationApiFp(this.configuration).themeTranslationShow(themeTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created theme translation
     * @param {ThemeTranslationStoreRequest} themeTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeTranslationApi
     */
    public themeTranslationStore(themeTranslationStoreRequest: ThemeTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return ThemeTranslationApiFp(this.configuration).themeTranslationStore(themeTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {ThemeTranslationUpdateRequest} [themeTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeTranslationApi
     */
    public themeTranslationUpdate(themeTranslation: string, themeTranslationUpdateRequest?: ThemeTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return ThemeTranslationApiFp(this.configuration).themeTranslationUpdate(themeTranslation, themeTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ThemeTranslationsApi - axios parameter creator
 * @export
 */
export const ThemeTranslationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationDestroy: async (themeTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationDestroy', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {string} [themeId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationIndex: async (themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/theme-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (themeId !== undefined) {
                localVarQueryParameter['theme_id'] = themeId;
            }

            if (languageId !== undefined) {
                localVarQueryParameter['language_id'] = languageId;
            }

            if (contextId !== undefined) {
                localVarQueryParameter['context_id'] = contextId;
            }

            if (defaultContext !== undefined) {
                localVarQueryParameter['default_context'] = defaultContext;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationShow: async (themeTranslation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationShow', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {ThemeTranslationStoreRequest} themeTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationStore: async (themeTranslationStoreRequest: ThemeTranslationStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslationStoreRequest' is not null or undefined
            assertParamExists('themeTranslationStore', 'themeTranslationStoreRequest', themeTranslationStoreRequest)
            const localVarPath = `/theme-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(themeTranslationStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {ThemeTranslationUpdateRequest} [themeTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate: async (themeTranslation: string, themeTranslationUpdateRequest?: ThemeTranslationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeTranslation' is not null or undefined
            assertParamExists('themeTranslationUpdate', 'themeTranslation', themeTranslation)
            const localVarPath = `/theme-translation/{themeTranslation}`
                .replace(`{${"themeTranslation"}}`, encodeURIComponent(String(themeTranslation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(themeTranslationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThemeTranslationsApi - functional programming interface
 * @export
 */
export const ThemeTranslationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThemeTranslationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationDestroy(themeTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationsApi.themeTranslationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {string} [themeId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationIndex(themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThemeTranslationResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationIndex(themeId, languageId, contextId, defaultContext, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationsApi.themeTranslationIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationShow(themeTranslation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationsApi.themeTranslationShow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {ThemeTranslationStoreRequest} themeTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationStore(themeTranslationStoreRequest: ThemeTranslationStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationStore(themeTranslationStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationsApi.themeTranslationStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {ThemeTranslationUpdateRequest} [themeTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeTranslationUpdate(themeTranslation: string, themeTranslationUpdateRequest?: ThemeTranslationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeTranslationStore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeTranslationUpdate(themeTranslation, themeTranslationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThemeTranslationsApi.themeTranslationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ThemeTranslationsApi - factory interface
 * @export
 */
export const ThemeTranslationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThemeTranslationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.themeTranslationDestroy(themeTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display a listing of theme translations
         * @param {string} [themeId] 
         * @param {string} [languageId] 
         * @param {string} [contextId] 
         * @param {boolean} [defaultContext] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationIndex(themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<ThemeTranslationResource>> {
            return localVarFp.themeTranslationIndex(themeId, languageId, contextId, defaultContext, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Display the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationStore200Response> {
            return localVarFp.themeTranslationShow(themeTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store a newly created theme translation
         * @param {ThemeTranslationStoreRequest} themeTranslationStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationStore(themeTranslationStoreRequest: ThemeTranslationStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationStore200Response> {
            return localVarFp.themeTranslationStore(themeTranslationStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified theme translation
         * @param {string} themeTranslation The theme translation ID
         * @param {ThemeTranslationUpdateRequest} [themeTranslationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeTranslationUpdate(themeTranslation: string, themeTranslationUpdateRequest?: ThemeTranslationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThemeTranslationStore200Response> {
            return localVarFp.themeTranslationUpdate(themeTranslation, themeTranslationUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThemeTranslationsApi - object-oriented interface
 * @export
 * @class ThemeTranslationsApi
 * @extends {BaseAPI}
 */
export class ThemeTranslationsApi extends BaseAPI {
    /**
     * 
     * @summary Remove the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeTranslationsApi
     */
    public themeTranslationDestroy(themeTranslation: string, options?: RawAxiosRequestConfig) {
        return ThemeTranslationsApiFp(this.configuration).themeTranslationDestroy(themeTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display a listing of theme translations
     * @param {string} [themeId] 
     * @param {string} [languageId] 
     * @param {string} [contextId] 
     * @param {boolean} [defaultContext] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeTranslationsApi
     */
    public themeTranslationIndex(themeId?: string, languageId?: string, contextId?: string, defaultContext?: boolean, options?: RawAxiosRequestConfig) {
        return ThemeTranslationsApiFp(this.configuration).themeTranslationIndex(themeId, languageId, contextId, defaultContext, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Display the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeTranslationsApi
     */
    public themeTranslationShow(themeTranslation: string, options?: RawAxiosRequestConfig) {
        return ThemeTranslationsApiFp(this.configuration).themeTranslationShow(themeTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store a newly created theme translation
     * @param {ThemeTranslationStoreRequest} themeTranslationStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeTranslationsApi
     */
    public themeTranslationStore(themeTranslationStoreRequest: ThemeTranslationStoreRequest, options?: RawAxiosRequestConfig) {
        return ThemeTranslationsApiFp(this.configuration).themeTranslationStore(themeTranslationStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified theme translation
     * @param {string} themeTranslation The theme translation ID
     * @param {ThemeTranslationUpdateRequest} [themeTranslationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemeTranslationsApi
     */
    public themeTranslationUpdate(themeTranslation: string, themeTranslationUpdateRequest?: ThemeTranslationUpdateRequest, options?: RawAxiosRequestConfig) {
        return ThemeTranslationsApiFp(this.configuration).themeTranslationUpdate(themeTranslation, themeTranslationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserPermissionsApi - axios parameter creator
 * @export
 */
export const UserPermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the authenticated user\'s permissions.    Returns a list of permission names that the authenticated user has.  This is a read-only endpoint for UI clients to determine what features  to show to the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPermissions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserPermissionsApi - functional programming interface
 * @export
 */
export const UserPermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserPermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the authenticated user\'s permissions.    Returns a list of permission names that the authenticated user has.  This is a read-only endpoint for UI clients to determine what features  to show to the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPermissions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPermissions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPermissions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserPermissionsApi.userPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserPermissionsApi - factory interface
 * @export
 */
export const UserPermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserPermissionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the authenticated user\'s permissions.    Returns a list of permission names that the authenticated user has.  This is a read-only endpoint for UI clients to determine what features  to show to the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPermissions(options?: RawAxiosRequestConfig): AxiosPromise<UserPermissions200Response> {
            return localVarFp.userPermissions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserPermissionsApi - object-oriented interface
 * @export
 * @class UserPermissionsApi
 * @extends {BaseAPI}
 */
export class UserPermissionsApi extends BaseAPI {
    /**
     * 
     * @summary Get the authenticated user\'s permissions.    Returns a list of permission names that the authenticated user has.  This is a read-only endpoint for UI clients to determine what features  to show to the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPermissionsApi
     */
    public userPermissions(options?: RawAxiosRequestConfig) {
        return UserPermissionsApiFp(this.configuration).userPermissions(options).then((request) => request(this.axios, this.basePath));
    }
}



